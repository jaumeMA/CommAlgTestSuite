# 1 "test_smartPtr.cpp"
# 1 "/home/marta/workspace/editorFrameworkTestSuite/YTL//"
# 1 "<command-line>"
# 1 "test_smartPtr.cpp"
# 1 "/usr/include/unittest++/UnitTest++.h" 1





# 1 "/usr/include/unittest++/Config.h" 1
# 7 "/usr/include/unittest++/UnitTest++.h" 2
# 1 "/usr/include/unittest++/Test.h" 1



# 1 "/usr/include/unittest++/TestDetails.h" 1



namespace UnitTest {

class TestDetails
{
public:
    TestDetails(char const* testName, char const* suiteName, char const* filename, int lineNumber);
    TestDetails(const TestDetails& details, int lineNumber);

    char const* const suiteName;
    char const* const testName;
    char const* const filename;
    int const lineNumber;

    TestDetails(TestDetails const&);
private:
    TestDetails& operator=(TestDetails const&);
};

}
# 5 "/usr/include/unittest++/Test.h" 2

namespace UnitTest {

class TestResults;
class TestList;

class Test
{
public:
    explicit Test(char const* testName, char const* suiteName = "DefaultSuite", char const* filename = "", int lineNumber = 0);
    virtual ~Test();
    void Run();

    TestDetails const m_details;
    Test* next;
    mutable bool m_timeConstraintExempt;

    static TestList& GetTestList();

    virtual void RunImpl() const;

private:
 Test(Test const&);
    Test& operator =(Test const&);
};


}
# 8 "/usr/include/unittest++/UnitTest++.h" 2
# 1 "/usr/include/unittest++/TestList.h" 1




namespace UnitTest {

class Test;

class TestList
{
public:
    TestList();
    void Add (Test* test);

    Test* GetHead() const;

private:
    Test* m_head;
    Test* m_tail;
};


class ListAdder
{
public:
    ListAdder(TestList& list, Test* test);
};

}
# 9 "/usr/include/unittest++/UnitTest++.h" 2
# 1 "/usr/include/unittest++/TestSuite.h" 1



namespace UnitTestSuite {

    inline char const* GetSuiteName ()
    {
        return "DefaultSuite";
    }

}
# 10 "/usr/include/unittest++/UnitTest++.h" 2
# 1 "/usr/include/unittest++/TestResults.h" 1



namespace UnitTest {

class TestReporter;
class TestDetails;

class TestResults
{
public:
    explicit TestResults(TestReporter* reporter = 0);

    void OnTestStart(TestDetails const& test);
    void OnTestFailure(TestDetails const& test, char const* failure);
    void OnTestFinish(TestDetails const& test, float secondsElapsed);

    int GetTotalTestCount() const;
    int GetFailedTestCount() const;
    int GetFailureCount() const;

private:
    TestReporter* m_testReporter;
    int m_totalTestCount;
    int m_failedTestCount;
    int m_failureCount;

    bool m_currentTestFailed;

    TestResults(TestResults const&);
    TestResults& operator =(TestResults const&);
};

}
# 11 "/usr/include/unittest++/UnitTest++.h" 2

# 1 "/usr/include/unittest++/TestMacros.h" 1




# 1 "/usr/include/unittest++/ExecuteTest.h" 1




# 1 "/usr/include/unittest++/MemoryOutStream.h" 1







# 1 "/usr/include/c++/4.8/sstream" 1 3
# 36 "/usr/include/c++/4.8/sstream" 3
       
# 37 "/usr/include/c++/4.8/sstream" 3

# 1 "/usr/include/c++/4.8/istream" 1 3
# 36 "/usr/include/c++/4.8/istream" 3
       
# 37 "/usr/include/c++/4.8/istream" 3

# 1 "/usr/include/c++/4.8/ios" 1 3
# 36 "/usr/include/c++/4.8/ios" 3
       
# 37 "/usr/include/c++/4.8/ios" 3

# 1 "/usr/include/c++/4.8/iosfwd" 1 3
# 36 "/usr/include/c++/4.8/iosfwd" 3
       
# 37 "/usr/include/c++/4.8/iosfwd" 3

# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++config.h" 1 3
# 178 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++config.h" 3
namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 420 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++config.h" 3
# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/os_defines.h" 1 3
# 39 "/usr/include/i386-linux-gnu/c++/4.8/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 324 "/usr/include/features.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/predefs.h" 1 3 4
# 325 "/usr/include/features.h" 2 3 4
# 357 "/usr/include/features.h" 3 4
# 1 "/usr/include/i386-linux-gnu/sys/cdefs.h" 1 3 4
# 378 "/usr/include/i386-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 379 "/usr/include/i386-linux-gnu/sys/cdefs.h" 2 3 4
# 358 "/usr/include/features.h" 2 3 4
# 389 "/usr/include/features.h" 3 4
# 1 "/usr/include/i386-linux-gnu/gnu/stubs.h" 1 3 4



# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/i386-linux-gnu/gnu/stubs.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/i386-linux-gnu/gnu/stubs.h" 2 3 4
# 390 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/i386-linux-gnu/c++/4.8/bits/os_defines.h" 2 3
# 421 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++config.h" 2 3


# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/cpu_defines.h" 1 3
# 424 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++config.h" 2 3
# 39 "/usr/include/c++/4.8/iosfwd" 2 3
# 1 "/usr/include/c++/4.8/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/4.8/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/4.8/bits/stringfwd.h" 3


# 1 "/usr/include/c++/4.8/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/4.8/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/4.8/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/4.8/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "/usr/include/c++/4.8/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;


  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;


  typedef basic_string<wchar_t> wstring;





  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 40 "/usr/include/c++/4.8/iosfwd" 2 3
# 1 "/usr/include/c++/4.8/bits/postypes.h" 1 3
# 38 "/usr/include/c++/4.8/bits/postypes.h" 3
       
# 39 "/usr/include/c++/4.8/bits/postypes.h" 3

# 1 "/usr/include/c++/4.8/cwchar" 1 3
# 39 "/usr/include/c++/4.8/cwchar" 3
       
# 40 "/usr/include/c++/4.8/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 37 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 38 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 41 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/i386-linux-gnu/bits/wchar.h" 1 3 4
# 43 "/usr/include/wchar.h" 2 3 4
# 52 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 3 4
typedef unsigned int size_t;
# 353 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



# 129 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();



# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 178 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
           __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 303 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
           size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();

# 402 "/usr/include/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 527 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;
# 677 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 733 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 798 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 824 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 834 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 888 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/include/c++/4.8/cwchar" 2 3
# 62 "/usr/include/c++/4.8/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/4.8/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 232 "/usr/include/c++/4.8/cwchar" 3

}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/usr/include/c++/4.8/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "/usr/include/c++/4.8/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/include/c++/4.8/bits/postypes.h" 2 3
# 68 "/usr/include/c++/4.8/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 90 "/usr/include/c++/4.8/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/4.8/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/4.8/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/include/c++/4.8/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/4.8/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/exception" 1 3
# 33 "/usr/include/c++/4.8/exception" 3
       
# 34 "/usr/include/c++/4.8/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/4.8/bits/atomic_lockfree_defines.h" 1 3
# 33 "/usr/include/c++/4.8/bits/atomic_lockfree_defines.h" 3
       
# 34 "/usr/include/c++/4.8/bits/atomic_lockfree_defines.h" 3
# 39 "/usr/include/c++/4.8/exception" 2 3

extern "C++" {

namespace std
{
# 60 "/usr/include/c++/4.8/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char* what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char* what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  void unexpected() __attribute__ ((__noreturn__));
# 117 "/usr/include/c++/4.8/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 142 "/usr/include/c++/4.8/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/4.8/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/4.8/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/4.8/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/4.8/bits/exception_ptr.h" 2 3





extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {




    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 111 "/usr/include/c++/4.8/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 138 "/usr/include/c++/4.8/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    {
      try
 {

   throw __ex;

 }
      catch(...)
 {
   return current_exception();
 }
    }




  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    { return std::copy_exception<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 153 "/usr/include/c++/4.8/exception" 2 3
# 1 "/usr/include/c++/4.8/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/4.8/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 45 "/usr/include/c++/4.8/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) = default;

    nested_exception& operator=(const nested_exception&) = default;

    virtual ~nested_exception() noexcept;

    void
    rethrow_nested() const __attribute__ ((__noreturn__))
    { rethrow_exception(_M_ptr); }

    exception_ptr
    nested_ptr() const
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Ex>
    struct __get_nested_helper
    {
      static const nested_exception*
      _S_get(const _Ex& __ex)
      { return dynamic_cast<const nested_exception*>(&__ex); }
    };

  template<typename _Ex>
    struct __get_nested_helper<_Ex*>
    {
      static const nested_exception*
      _S_get(const _Ex* __ex)
      { return dynamic_cast<const nested_exception*>(__ex); }
    };

  template<typename _Ex>
    inline const nested_exception*
    __get_nested_exception(const _Ex& __ex)
    { return __get_nested_helper<_Ex>::_S_get(__ex); }

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, const nested_exception* = 0)
    __attribute__ ((__noreturn__));

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, ...) __attribute__ ((__noreturn__));




  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, const nested_exception*)
    { throw __ex; }

  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, ...)
    { throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex)); }

  template<typename _Ex>
    void
    throw_with_nested(_Ex __ex) __attribute__ ((__noreturn__));



  template<typename _Ex>
    inline void
    throw_with_nested(_Ex __ex)
    {
      if (__get_nested_exception(__ex))
        throw __ex;
      __throw_with_nested(static_cast<_Ex&&>(__ex), &__ex);
    }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      if (const nested_exception* __nested = __get_nested_exception(__ex))
        __nested->rethrow_nested();
    }


  inline void
  rethrow_if_nested(const nested_exception& __ex)
  { __ex.rethrow_nested(); }


}

}



#pragma GCC visibility pop
# 154 "/usr/include/c++/4.8/exception" 2 3
# 40 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/4.8/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/4.8/bits/char_traits.h" 3

# 1 "/usr/include/c++/4.8/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.8/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/4.8/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
# 68 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<typename _Iterator>
    class move_iterator;

  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



}
# 62 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/4.8/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/4.8/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 63 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/4.8/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/4.8/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/4.8/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/4.8/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_pair.h" 1 3
# 59 "/usr/include/c++/4.8/bits/stl_pair.h" 3
# 1 "/usr/include/c++/4.8/bits/move.h" 1 3
# 34 "/usr/include/c++/4.8/bits/move.h" 3
# 1 "/usr/include/c++/4.8/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/4.8/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/4.8/bits/concept_check.h" 3
# 35 "/usr/include/c++/4.8/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}


# 1 "/usr/include/c++/4.8/type_traits" 1 3
# 32 "/usr/include/c++/4.8/type_traits" 3
       
# 33 "/usr/include/c++/4.8/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() { return value; }
    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;



  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };

  struct __sfinae_types
  {
    typedef char __one;
    typedef struct { char __arr[2]; } __two;
  };






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public integral_constant<bool, (__is_void_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 245 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public integral_constant<bool, (__is_integral_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 274 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public integral_constant<bool, (__is_floating_point_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public integral_constant<bool, (__is_member_object_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public integral_constant<bool, (__is_member_function_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename>
    struct __is_nullptr_t_helper
    : public false_type { };

  template<>
    struct __is_nullptr_t_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public integral_constant<bool, (__is_nullptr_t_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, __is_nullptr_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, __is_nullptr_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public integral_constant<bool, (__is_member_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };




  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_integral<_Tp>::value,
    bool = is_floating_point<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, false, true>
    : public true_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true, false>
    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>
    { };


  template<typename _Tp>
    struct is_signed
    : public integral_constant<bool, __is_signed_helper<_Tp>::value>
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public integral_constant<bool, (__is_destructible_safe<_Tp>::value)>
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public integral_constant<bool, (__is_nt_destructible_safe<_Tp>::value)>
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public integral_constant<bool, (__is_default_constructible_safe<
          _Tp>::value)>
    { };
# 765 "/usr/include/c++/4.8/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public integral_constant<bool, (__is_direct_constructible_new<
          _Tp, _Arg>::value)>
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public integral_constant<bool, (__is_constructible_impl<_Tp,
          _Args...>::value)>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>::type
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    : public __sfinae_types
    {
      template<typename _Tp1, typename _Up1>
        static decltype(declval<_Tp1>() = declval<_Up1>(), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static constexpr bool value = sizeof(__test<_Tp, _Up>(0)) == 1;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public integral_constant<bool,
                               __is_assignable_helper<_Tp, _Up>::value>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>::type
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };
# 1203 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>::type
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { static constexpr bool value = is_void<_To>::value; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    : public __sfinae_types
    {
      template<typename _To1>
        static void __test_aux(_To1);

      template<typename _From1, typename _To1>
        static decltype(__test_aux<_To1>(std::declval<_From1>()), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static constexpr bool value = sizeof(__test<_From, _To>(0)) == 1;
    };


  template<typename _From, typename _To>
    struct is_convertible
    : public integral_constant<bool,
          __is_convertible_helper<_From, _To>::value>
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp,
    bool = __and_<__not_<is_reference<_Tp>>,
                         __not_<is_void<_Tp>>>::value,
    bool = is_rvalue_reference<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true, false>
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, false, true>
    { typedef typename remove_reference<_Tp>::type& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp,
           bool = __and_<__not_<is_reference<_Tp>>,
                         __not_<is_void<_Tp>>>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1492 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1574 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {

      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp>
    struct add_pointer
    { typedef typename remove_reference<_Tp>::type* type; };


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1691 "/usr/include/c++/4.8/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };




  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;




  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __success_type<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };
# 2069 "/usr/include/c++/4.8/type_traits" 3

}
# 58 "/usr/include/c++/4.8/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    inline constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 133 "/usr/include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



}
# 149 "/usr/include/c++/4.8/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 164 "/usr/include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)

    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)

    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])

    noexcept(noexcept(swap(*__a, *__b)))

    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/usr/include/c++/4.8/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/usr/include/c++/4.8/bits/stl_pair.h" 3
  struct piecewise_construct_t { };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;
# 95 "/usr/include/c++/4.8/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      constexpr pair()
      : first(), second() { }


      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }







      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
 constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<class _U1, class = typename
        enable_if<is_convertible<_U1, _T1>::value>::type>
 constexpr pair(_U1&& __x, const _T2& __y)
 : first(std::forward<_U1>(__x)), second(__y) { }

      template<class _U2, class = typename
        enable_if<is_convertible<_U2, _T2>::value>::type>
 constexpr pair(const _T1& __x, _U2&& __y)
 : first(__x), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<class _U1, class _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<class _U1, class _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(noexcept(swap(first, __p.first))
        && noexcept(swap(second, __p.second)))
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<class _T1, class _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 273 "/usr/include/c++/4.8/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 292 "/usr/include/c++/4.8/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 142 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
template<typename _Tp> class __has_iterator_category_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::iterator_category>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_iterator_category : integral_constant<bool, __has_iterator_category_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Iterator,
    bool = __has_iterator_category<_Iterator>::value>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator, true>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 174 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/include/c++/4.8/debug/debug.h" 1 3
# 46 "/usr/include/c++/4.8/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 66 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 112 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 171 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {
      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_iterator.h" 1 3
# 67 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 95 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 159 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 289 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }
# 401 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 435 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 477 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 492 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 525 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 567 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 586 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 637 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 681 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 705 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 803 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 929 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;
      typedef value_type&& reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return std::move(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }




}
# 68 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 117 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 147 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 163 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 191 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 214 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 237 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 258 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 448 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 481 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 617 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 653 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 719 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 779 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 941 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1019 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1051 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1082 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1118 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1158 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1195 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
# 40 "/usr/include/c++/4.8/bits/char_traits.h" 2 3

# 1 "/usr/include/c++/4.8/cwchar" 1 3
# 39 "/usr/include/c++/4.8/cwchar" 3
       
# 40 "/usr/include/c++/4.8/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/include/c++/4.8/cwchar" 2 3
# 42 "/usr/include/c++/4.8/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/4.8/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "/usr/include/c++/4.8/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 226 "/usr/include/c++/4.8/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "/usr/include/c++/4.8/cstdint" 1 3
# 32 "/usr/include/c++/4.8/cstdint" 3
       
# 33 "/usr/include/c++/4.8/cstdint" 3
# 41 "/usr/include/c++/4.8/cstdint" 3
# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 28 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 37 "/usr/include/stdint.h" 3 4
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;



__extension__
typedef long long int int64_t;




typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 126 "/usr/include/stdint.h" 3 4
typedef int intptr_t;


typedef unsigned int uintptr_t;
# 138 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 10 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stdint.h" 2 3 4
# 42 "/usr/include/c++/4.8/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 377 "/usr/include/c++/4.8/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/4.8/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/4.8/bits/localefwd.h" 3


# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++locale.h" 1 3
# 39 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++locale.h" 3
       
# 40 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++locale.h" 3

# 1 "/usr/include/c++/4.8/clocale" 1 3
# 39 "/usr/include/c++/4.8/clocale" 3
       
# 40 "/usr/include/c++/4.8/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/i386-linux-gnu/bits/locale.h" 1 3 4
# 27 "/usr/include/i386-linux-gnu/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, __const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 43 "/usr/include/c++/4.8/clocale" 2 3
# 51 "/usr/include/c++/4.8/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/include/c++/4.8/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/4.8/cctype" 1 3
# 39 "/usr/include/c++/4.8/cctype" 3
       
# 40 "/usr/include/c++/4.8/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/types.h" 1 3 4
# 28 "/usr/include/i386-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/i386-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 131 "/usr/include/i386-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/typesizes.h" 1 3 4
# 132 "/usr/include/i386-linux-gnu/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 29 "/usr/include/ctype.h" 2 3 4

extern "C" {
# 41 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/byteswap.h" 1 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 42 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const));
# 106 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 273 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 349 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/include/c++/4.8/cctype" 2 3
# 62 "/usr/include/c++/4.8/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/include/c++/4.8/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/4.8/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
# 42 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/4.8/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/4.8/bits/ios_base.h" 3

# 1 "/usr/include/c++/4.8/ext/atomicity.h" 1 3
# 33 "/usr/include/c++/4.8/ext/atomicity.h" 3
# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr.h" 1 3
# 30 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr.h" 3
# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 1 3
# 35 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 25 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 30 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 31 "/usr/include/sched.h" 2 3 4



# 1 "/usr/include/time.h" 1 3 4
# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 35 "/usr/include/sched.h" 2 3 4


typedef __pid_t pid_t;





# 1 "/usr/include/i386-linux-gnu/bits/sched.h" 1 3 4
# 74 "/usr/include/i386-linux-gnu/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 120 "/usr/include/i386-linux-gnu/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 203 "/usr/include/i386-linux-gnu/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 44 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 118 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 26 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/i386-linux-gnu/bits/time.h" 1 3 4
# 31 "/usr/include/i386-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 86 "/usr/include/i386-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/timex.h" 1 3 4
# 24 "/usr/include/i386-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  long int offset;
  long int freq;
  long int maxerror;
  long int esterror;
  int status;
  long int constant;
  long int precision;
  long int tolerance;
  struct timeval time;
  long int tick;

  long int ppsfreq;
  long int jitter;
  int shift;
  long int stabil;
  long int jitcnt;
  long int calcnt;
  long int errcnt;
  long int stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/i386-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 43 "/usr/include/time.h" 2 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 180 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 313 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 328 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 390 "/usr/include/time.h" 3 4
extern int getdate_err;
# 399 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 413 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 27 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/i386-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 36 "/usr/include/i386-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;


typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 29 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/i386-linux-gnu/bits/setjmp.h" 1 3 4
# 29 "/usr/include/i386-linux-gnu/bits/setjmp.h" 3 4
typedef int __jmp_buf[6];
# 30 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 31 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 147 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 182 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 220 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, __const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 478 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 490 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 524 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 726 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        __const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 790 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 872 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 984 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1028 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1095 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1129 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1143 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 2 3
# 47 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/include/i386-linux-gnu/c++/4.8/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 34 "/usr/include/c++/4.8/ext/atomicity.h" 2 3
# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/atomic_word.h" 1 3
# 32 "/usr/include/i386-linux-gnu/c++/4.8/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 35 "/usr/include/c++/4.8/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 62 "/usr/include/c++/4.8/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/include/c++/4.8/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/4.8/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/4.8/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/4.8/bits/locale_classes.h" 3


# 1 "/usr/include/c++/4.8/string" 1 3
# 36 "/usr/include/c++/4.8/string" 3
       
# 37 "/usr/include/c++/4.8/string" 3




# 1 "/usr/include/c++/4.8/bits/allocator.h" 1 3
# 46 "/usr/include/c++/4.8/bits/allocator.h" 3
# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++allocator.h" 1 3
# 33 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.8/ext/new_allocator.h" 1 3
# 33 "/usr/include/c++/4.8/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.8/new" 1 3
# 37 "/usr/include/c++/4.8/new" 3
       
# 38 "/usr/include/c++/4.8/new" 3




#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 91 "/usr/include/c++/4.8/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
# 34 "/usr/include/c++/4.8/ext/new_allocator.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/include/c++/4.8/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
# 135 "/usr/include/c++/4.8/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/include/i386-linux-gnu/c++/4.8/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/include/c++/4.8/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

    };
# 91 "/usr/include/c++/4.8/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c)
      {
 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }
      }
    };



}
# 42 "/usr/include/c++/4.8/string" 2 3


# 1 "/usr/include/c++/4.8/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/4.8/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/4.8/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/4.8/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/4.8/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/4.8/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/4.8/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/include/c++/4.8/string" 2 3



# 1 "/usr/include/c++/4.8/bits/stl_function.h" 1 3
# 59 "/usr/include/c++/4.8/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 100 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 139 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 203 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 267 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 350 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 421 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 541 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/4.8/backward/binders.h" 1 3
# 59 "/usr/include/c++/4.8/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 103 "/usr/include/c++/4.8/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
# 732 "/usr/include/c++/4.8/bits/stl_function.h" 2 3
# 49 "/usr/include/c++/4.8/string" 2 3


# 1 "/usr/include/c++/4.8/bits/range_access.h" 1 3
# 33 "/usr/include/c++/4.8/bits/range_access.h" 3
       
# 34 "/usr/include/c++/4.8/bits/range_access.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<class _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<class _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<class _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<class _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }


}
# 52 "/usr/include/c++/4.8/string" 2 3
# 1 "/usr/include/c++/4.8/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/4.8/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/4.8/bits/basic_string.h" 3




# 1 "/usr/include/c++/4.8/initializer_list" 1 3
# 33 "/usr/include/c++/4.8/initializer_list" 3
       
# 34 "/usr/include/c++/4.8/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 43 "/usr/include/c++/4.8/bits/basic_string.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 111 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 148 "/usr/include/c++/4.8/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 173 "/usr/include/c++/4.8/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 483 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 507 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(__str._M_dataplus)
      {

 __str._M_data(_S_empty_rep()._M_refdata());



      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
# 531 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string() noexcept
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 564 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 579 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      {

 this->swap(__str);
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_rep()->_M_length; }



      size_type
      length() const noexcept
      { return _M_rep()->_M_length; }


      size_type
      max_size() const noexcept
      { return _Rep::_S_max_size; }
# 739 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 752 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit()
      {
 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }
      }






      size_type
      capacity() const noexcept
      { return _M_rep()->_M_capacity; }
# 796 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 825 "/usr/include/c++/4.8/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 842 "/usr/include/c++/4.8/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 863 "/usr/include/c++/4.8/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 882 "/usr/include/c++/4.8/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }






      reference
      front()
      { return operator[](0); }





      const_reference
      front() const
      { return operator[](0); }





      reference
      back()
      { return operator[](this->size() - 1); }





      const_reference
      back() const
      { return operator[](this->size() - 1); }
# 931 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str);
# 988 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 1020 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1042 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1078 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      {
 this->swap(__str);
 return *this;
      }
# 1099 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1115 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1127 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1143 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1155 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1184 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1200 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1212 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
      }
# 1232 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1254 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1277 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1295 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1318 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1336 "/usr/include/c++/4.8/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1361 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1377 "/usr/include/c++/4.8/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1397 "/usr/include/c++/4.8/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);







      void
      pop_back()
      { erase(size()-1, 1); }
# 1428 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1450 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1475 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1495 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1519 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1537 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1556 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1577 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1598 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1621 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1692 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string& replace(iterator __i1, iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1779 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1789 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1799 "/usr/include/c++/4.8/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_dataplus; }
# 1832 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1845 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 1860 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1877 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 1890 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1907 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1920 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1937 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 1951 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1968 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1981 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2000 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2015 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2032 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2045 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2064 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2078 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2095 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2109 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2126 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
# 2141 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2158 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2172 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2189 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
# 2205 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2224 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2256 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2282 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2300 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2324 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2351 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2363 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 2484 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2530 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2567 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2604 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2641 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2678 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2715 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2733 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2751 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2774 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2791 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}




# 1 "/usr/include/c++/4.8/ext/string_conversions.h" 1 3
# 32 "/usr/include/c++/4.8/ext/string_conversions.h" 3
       
# 33 "/usr/include/c++/4.8/ext/string_conversions.h" 3
# 41 "/usr/include/c++/4.8/ext/string_conversions.h" 3
# 1 "/usr/include/c++/4.8/cstdlib" 1 3
# 39 "/usr/include/c++/4.8/cstdlib" 3
       
# 40 "/usr/include/c++/4.8/cstdlib" 3
# 72 "/usr/include/c++/4.8/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/i386-linux-gnu/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/i386-linux-gnu/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/i386-linux-gnu/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

# 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;
# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/i386-linux-gnu/sys/types.h" 1 3 4
# 28 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 105 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 137 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 148 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 201 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/i386-linux-gnu/sys/select.h" 1 3 4
# 31 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/select.h" 1 3 4
# 32 "/usr/include/i386-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/bits/sigset.h" 1 3 4
# 24 "/usr/include/i386-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/i386-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;







# 1 "/usr/include/i386-linux-gnu/bits/time.h" 1 3 4
# 47 "/usr/include/i386-linux-gnu/sys/select.h" 2 3 4
# 55 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 65 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 97 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
extern "C" {
# 107 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 119 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 132 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
}
# 221 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/i386-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
# 64 "/usr/include/i386-linux-gnu/sys/sysmacros.h" 3 4
}
# 224 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 263 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 274 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
}
# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 498 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));






extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));







extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 808 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 896 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 964 "/usr/include/stdlib.h" 3 4
}
# 73 "/usr/include/c++/4.8/cstdlib" 2 3
# 114 "/usr/include/c++/4.8/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }








}
# 196 "/usr/include/c++/4.8/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 228 "/usr/include/c++/4.8/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 42 "/usr/include/c++/4.8/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.8/cwchar" 1 3
# 39 "/usr/include/c++/4.8/cwchar" 3
       
# 40 "/usr/include/c++/4.8/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/include/c++/4.8/cwchar" 2 3
# 43 "/usr/include/c++/4.8/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.8/cstdio" 1 3
# 39 "/usr/include/c++/4.8/cstdio" 3
       
# 40 "/usr/include/c++/4.8/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 54 "/usr/include/libio.h" 2 3 4
# 172 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 182 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 205 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 273 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 321 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 330 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 366 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 462 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 492 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 554 "/usr/include/libio.h" 3 4
}
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 109 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 165 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/stdio_lim.h" 1 3 4
# 166 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 206 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 228 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 253 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 263 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 296 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
# 418 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
# 469 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 528 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 556 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 567 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 600 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 646 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 662 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 723 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 734 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 770 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 789 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 812 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (__const char *__s);






# 1 "/usr/include/i386-linux-gnu/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/i386-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 851 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 870 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 940 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/include/c++/4.8/cstdio" 2 3
# 93 "/usr/include/c++/4.8/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 149 "/usr/include/c++/4.8/cstdio" 3
namespace __gnu_cxx
{
# 167 "/usr/include/c++/4.8/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/include/c++/4.8/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.8/cerrno" 1 3
# 39 "/usr/include/c++/4.8/cerrno" 3
       
# 40 "/usr/include/c++/4.8/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 32 "/usr/include/errno.h" 3 4
extern "C" {



# 1 "/usr/include/i386-linux-gnu/bits/errno.h" 1 3 4
# 25 "/usr/include/i386-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/i386-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/i386-linux-gnu/asm/errno.h" 2 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/i386-linux-gnu/bits/errno.h" 2 3 4
# 47 "/usr/include/i386-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 37 "/usr/include/errno.h" 2 3 4
# 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 69 "/usr/include/errno.h" 3 4
typedef int error_t;
# 42 "/usr/include/c++/4.8/cerrno" 2 3
# 45 "/usr/include/c++/4.8/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;
      (*__errno_location ()) = 0;
      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 2816 "/usr/include/c++/4.8/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }


  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }


  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}





# 1 "/usr/include/c++/4.8/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/4.8/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/4.8/bits/functional_hash.h" 3

# 1 "/usr/include/c++/4.8/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/4.8/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/4.8/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 36 "/usr/include/c++/4.8/bits/functional_hash.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/4.8/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 80 "/usr/include/c++/4.8/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };



  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 3034 "/usr/include/c++/4.8/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };



}
# 53 "/usr/include/c++/4.8/string" 2 3
# 1 "/usr/include/c++/4.8/bits/basic_string.tcc" 1 3
# 40 "/usr/include/c++/4.8/bits/basic_string.tcc" 3
       
# 41 "/usr/include/c++/4.8/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
      
                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 577 "/usr/include/c++/4.8/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/usr/include/c++/4.8/string" 2 3
# 41 "/usr/include/c++/4.8/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/4.8/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 164 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 177 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 191 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 206 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 225 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 253 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 269 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 304 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 338 "/usr/include/c++/4.8/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 369 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 436 "/usr/include/c++/4.8/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 583 "/usr/include/c++/4.8/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 610 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 624 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 641 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 660 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 674 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 703 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 717 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 730 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/4.8/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/include/c++/4.8/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/include/c++/4.8/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 788 "/usr/include/c++/4.8/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/4.8/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 199 "/usr/include/c++/4.8/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 255 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 330 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 361 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 393 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 419 "/usr/include/c++/4.8/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 436 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 448 "/usr/include/c++/4.8/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 561 "/usr/include/c++/4.8/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 577 "/usr/include/c++/4.8/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 594 "/usr/include/c++/4.8/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 620 "/usr/include/c++/4.8/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 671 "/usr/include/c++/4.8/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 683 "/usr/include/c++/4.8/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 694 "/usr/include/c++/4.8/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 705 "/usr/include/c++/4.8/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 724 "/usr/include/c++/4.8/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 740 "/usr/include/c++/4.8/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 761 "/usr/include/c++/4.8/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 778 "/usr/include/c++/4.8/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


}
# 43 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/streambuf" 1 3
# 36 "/usr/include/c++/4.8/streambuf" 3
       
# 37 "/usr/include/c++/4.8/streambuf" 3
# 45 "/usr/include/c++/4.8/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "/usr/include/c++/4.8/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/include/c++/4.8/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/include/c++/4.8/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/include/c++/4.8/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "/usr/include/c++/4.8/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "/usr/include/c++/4.8/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "/usr/include/c++/4.8/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "/usr/include/c++/4.8/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "/usr/include/c++/4.8/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "/usr/include/c++/4.8/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "/usr/include/c++/4.8/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "/usr/include/c++/4.8/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "/usr/include/c++/4.8/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "/usr/include/c++/4.8/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "/usr/include/c++/4.8/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "/usr/include/c++/4.8/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "/usr/include/c++/4.8/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "/usr/include/c++/4.8/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "/usr/include/c++/4.8/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "/usr/include/c++/4.8/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "/usr/include/c++/4.8/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "/usr/include/c++/4.8/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "/usr/include/c++/4.8/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "/usr/include/c++/4.8/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "/usr/include/c++/4.8/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "/usr/include/c++/4.8/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "/usr/include/c++/4.8/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "/usr/include/c++/4.8/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "/usr/include/c++/4.8/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "/usr/include/c++/4.8/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:


      basic_streambuf(const basic_streambuf& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      basic_streambuf&
      operator=(const basic_streambuf&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

# 1 "/usr/include/c++/4.8/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 829 "/usr/include/c++/4.8/streambuf" 2 3
# 44 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/4.8/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/4.8/bits/basic_ios.h" 3



# 1 "/usr/include/c++/4.8/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/4.8/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/4.8/bits/locale_facets.h" 3

# 1 "/usr/include/c++/4.8/cwctype" 1 3
# 39 "/usr/include/c++/4.8/cwctype" 3
       
# 40 "/usr/include/c++/4.8/cwctype" 3
# 50 "/usr/include/c++/4.8/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 34 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 35 "/usr/include/wctype.h" 2 3 4
# 50 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 72 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 172 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (__const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 214 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (__const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 51 "/usr/include/c++/4.8/cwctype" 2 3
# 80 "/usr/include/c++/4.8/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.8/cctype" 1 3
# 39 "/usr/include/c++/4.8/cctype" 3
       
# 40 "/usr/include/c++/4.8/cctype" 3
# 41 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3
# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/ctype_base.h" 1 3
# 36 "/usr/include/i386-linux-gnu/c++/4.8/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };


}
# 42 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/4.8/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/4.8/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/4.8/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/4.8/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 142 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 161 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 178 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 194 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 210 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 224 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 239 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 253 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 268 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 285 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 304 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 323 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 345 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 370 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 389 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 408 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 427 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 445 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 462 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 478 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 495 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 514 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 535 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 556 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 581 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 604 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 673 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 710 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 723 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 736 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 751 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 765 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 779 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 794 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 811 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 827 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 844 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 864 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 891 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 922 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 955 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1004 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1021 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1037 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1054 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1074 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1097 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1123 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }
# 1149 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1174 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1207 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1218 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1242 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1261 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1279 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1297 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1314 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1331 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1347 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1364 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1384 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1406 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1429 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1455 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/i386-linux-gnu/c++/4.8/bits/ctype_inline.h" 1 3
# 37 "/usr/include/i386-linux-gnu/c++/4.8/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1512 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1640 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1678 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1692 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1706 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1719 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1750 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1763 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1776 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1793 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1805 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1818 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1831 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1844 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


# 1914 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1935 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1961 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1998 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2058 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2101 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2172 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2235 "/usr/include/c++/4.8/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2253 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2274 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2292 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2334 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2397 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2422 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2470 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/4.8/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 136 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 730 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 966 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1027 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1152 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1189 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2609 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/4.8/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 65 "/usr/include/c++/4.8/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 130 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 141 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 194 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 215 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 250 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 288 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 300 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 340 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 354 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 383 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 403 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 423 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 442 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/4.8/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/4.8/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/4.8/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/4.8/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 476 "/usr/include/c++/4.8/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/4.8/ios" 2 3
# 39 "/usr/include/c++/4.8/istream" 2 3
# 1 "/usr/include/c++/4.8/ostream" 1 3
# 36 "/usr/include/c++/4.8/ostream" 3
       
# 37 "/usr/include/c++/4.8/ostream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/include/c++/4.8/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      flush();
# 357 "/usr/include/c++/4.8/ostream" 3
      pos_type
      tellp();
# 368 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/usr/include/c++/4.8/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 399 "/usr/include/c++/4.8/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 418 "/usr/include/c++/4.8/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 428 "/usr/include/c++/4.8/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 447 "/usr/include/c++/4.8/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 469 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 511 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 562 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 574 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 600 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    { return (__os << __x); }



}

# 1 "/usr/include/c++/4.8/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 610 "/usr/include/c++/4.8/ostream" 2 3
# 40 "/usr/include/c++/4.8/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/include/c++/4.8/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/include/c++/4.8/istream" 3
      int_type
      get();
# 315 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/include/c++/4.8/istream" 3
      int_type
      peek();
# 485 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/include/c++/4.8/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      unget();
# 555 "/usr/include/c++/4.8/istream" 3
      int
      sync();
# 570 "/usr/include/c++/4.8/istream" 3
      pos_type
      tellg();
# 585 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 656 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 692 "/usr/include/c++/4.8/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 703 "/usr/include/c++/4.8/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 721 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 763 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 794 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 854 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 870 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    { return (__is >> __x); }



}

# 1 "/usr/include/c++/4.8/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 513 "/usr/include/c++/4.8/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 880 "/usr/include/c++/4.8/istream" 2 3
# 39 "/usr/include/c++/4.8/sstream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/4.8/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 97 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 110 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 125 "/usr/include/c++/4.8/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 149 "/usr/include/c++/4.8/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 201 "/usr/include/c++/4.8/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);
    };
# 271 "/usr/include/c++/4.8/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 307 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 325 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 347 "/usr/include/c++/4.8/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 386 "/usr/include/c++/4.8/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 422 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 440 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 462 "/usr/include/c++/4.8/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 501 "/usr/include/c++/4.8/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 536 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 552 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 574 "/usr/include/c++/4.8/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };


}

# 1 "/usr/include/c++/4.8/bits/sstream.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/sstream.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 110 "/usr/include/c++/4.8/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 601 "/usr/include/c++/4.8/sstream" 2 3
# 9 "/usr/include/unittest++/MemoryOutStream.h" 2

namespace UnitTest
{

class MemoryOutStream : public std::ostringstream
{
public:
    MemoryOutStream() {}
    char const* GetText() const;

private:
    MemoryOutStream(MemoryOutStream const&);
    void operator =(MemoryOutStream const&);

    mutable std::string m_text;
};

}
# 6 "/usr/include/unittest++/ExecuteTest.h" 2
# 1 "/usr/include/unittest++/AssertException.h" 1






namespace UnitTest {

class AssertException : public std::exception
{
public:
    AssertException(char const* description, char const* filename, int lineNumber);
    virtual ~AssertException() throw();

    virtual char const* what() const throw();

    char const* Filename() const;
    int LineNumber() const;

private:
    char m_description[512];
    char m_filename[256];
    int m_lineNumber;
};

}
# 7 "/usr/include/unittest++/ExecuteTest.h" 2
# 1 "/usr/include/unittest++/CurrentTest.h" 1



namespace UnitTest {

class TestResults;
class TestDetails;

namespace CurrentTest
{
 TestResults*& Results();
 const TestDetails*& Details();
}

}
# 8 "/usr/include/unittest++/ExecuteTest.h" 2


# 1 "/usr/include/unittest++/Posix/SignalTranslator.h" 1



# 1 "/usr/include/setjmp.h" 1 3 4
# 28 "/usr/include/setjmp.h" 3 4
extern "C" {


# 1 "/usr/include/i386-linux-gnu/bits/sigset.h" 1 3 4
# 32 "/usr/include/setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) throw ();






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) throw ();




extern int _setjmp (struct __jmp_buf_tag __env[1]) throw ();
# 78 "/usr/include/setjmp.h" 3 4




extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     throw () __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     throw () __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 110 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     throw () __attribute__ ((__noreturn__));
# 120 "/usr/include/setjmp.h" 3 4
}
# 5 "/usr/include/unittest++/Posix/SignalTranslator.h" 2
# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4
extern "C" {

# 1 "/usr/include/i386-linux-gnu/bits/sigset.h" 1 3 4
# 104 "/usr/include/i386-linux-gnu/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 34 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

# 58 "/usr/include/signal.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/signum.h" 1 3 4
# 59 "/usr/include/signal.h" 2 3 4
# 79 "/usr/include/signal.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/siginfo.h" 1 3 4
# 25 "/usr/include/i386-linux-gnu/bits/siginfo.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 26 "/usr/include/i386-linux-gnu/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 51 "/usr/include/i386-linux-gnu/bits/siginfo.h" 3 4
typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 3)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;
      } _sifields;
  } siginfo_t;
# 129 "/usr/include/i386-linux-gnu/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 273 "/usr/include/i386-linux-gnu/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 3)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     void *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 80 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     throw ();

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     throw ();







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     throw ();
# 113 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     throw ();






extern int kill (__pid_t __pid, int __sig) throw ();






extern int killpg (__pid_t __pgrp, int __sig) throw ();




extern int raise (int __sig) throw ();




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     throw ();
extern int gsignal (int __sig) throw ();




extern void psignal (int __sig, __const char *__s);




extern void psiginfo (__const siginfo_t *__pinfo, __const char *__s);
# 168 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 177 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 196 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) throw () __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) throw () __attribute__ ((__deprecated__));


extern int siggetmask (void) throw () __attribute__ ((__deprecated__));
# 211 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigismember (__const sigset_t *__set, int __signo)
     throw () __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (__const sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, __const sigset_t *__left,
        __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, __const sigset_t *__left,
       __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/i386-linux-gnu/bits/sigaction.h" 1 3 4
# 25 "/usr/include/i386-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 253 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) throw ();






extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) throw ();


extern int sigpending (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));






extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (__const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (__const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     throw ();
# 310 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[65];
extern __const char *__const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 334 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, __const struct sigvec *__vec,
     struct sigvec *__ovec) throw ();



# 1 "/usr/include/i386-linux-gnu/bits/sigcontext.h" 1 3 4
# 28 "/usr/include/i386-linux-gnu/bits/sigcontext.h" 3 4
# 1 "/usr/include/i386-linux-gnu/asm/sigcontext.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4



# 1 "/usr/include/i386-linux-gnu/asm/types.h" 1 3 4



# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 11 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/i386-linux-gnu/asm/bitsperlong.h" 1 3 4
# 10 "/usr/include/i386-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 11 "/usr/include/i386-linux-gnu/asm/bitsperlong.h" 2 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4



typedef unsigned short umode_t;
# 5 "/usr/include/i386-linux-gnu/asm/types.h" 2 3 4
# 5 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4



# 1 "/usr/include/linux/stddef.h" 1 3 4
# 5 "/usr/include/linux/posix_types.h" 2 3 4
# 36 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/i386-linux-gnu/asm/posix_types.h" 1 3 4

# 1 "/usr/include/i386-linux-gnu/asm/posix_types_32.h" 1 3 4
# 10 "/usr/include/i386-linux-gnu/asm/posix_types_32.h" 3 4
typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned short __kernel_ipc_pid_t;
typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef int __kernel_daddr_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;

typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned short __kernel_old_dev_t;


typedef long long __kernel_loff_t;


typedef struct {
 int val[2];
} __kernel_fsid_t;
# 3 "/usr/include/i386-linux-gnu/asm/posix_types.h" 2 3 4
# 48 "/usr/include/linux/posix_types.h" 2 3 4
# 9 "/usr/include/linux/types.h" 2 3 4
# 27 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 6 "/usr/include/i386-linux-gnu/asm/sigcontext.h" 2 3 4
# 23 "/usr/include/i386-linux-gnu/asm/sigcontext.h" 3 4
struct _fpx_sw_bytes {
 __u32 magic1;
 __u32 extended_size;


 __u64 xstate_bv;




 __u32 xstate_size;




 __u32 padding[7];
};
# 56 "/usr/include/i386-linux-gnu/asm/sigcontext.h" 3 4
struct _fpreg {
 unsigned short significand[4];
 unsigned short exponent;
};

struct _fpxreg {
 unsigned short significand[4];
 unsigned short exponent;
 unsigned short padding[3];
};

struct _xmmreg {
 unsigned long element[4];
};

struct _fpstate {

 unsigned long cw;
 unsigned long sw;
 unsigned long tag;
 unsigned long ipoff;
 unsigned long cssel;
 unsigned long dataoff;
 unsigned long datasel;
 struct _fpreg _st[8];
 unsigned short status;
 unsigned short magic;


 unsigned long _fxsr_env[6];
 unsigned long mxcsr;
 unsigned long reserved;
 struct _fpxreg _fxsr_st[8];
 struct _xmmreg _xmm[8];
 unsigned long padding1[44];

 union {
  unsigned long padding2[12];
  struct _fpx_sw_bytes sw_reserved;

 };
};






struct sigcontext {
 unsigned short gs, __gsh;
 unsigned short fs, __fsh;
 unsigned short es, __esh;
 unsigned short ds, __dsh;
 unsigned long edi;
 unsigned long esi;
 unsigned long ebp;
 unsigned long esp;
 unsigned long ebx;
 unsigned long edx;
 unsigned long ecx;
 unsigned long eax;
 unsigned long trapno;
 unsigned long err;
 unsigned long eip;
 unsigned short cs, __csh;
 unsigned long eflags;
 unsigned long esp_at_signal;
 unsigned short ss, __ssh;
 struct _fpstate *fpstate;
 unsigned long oldmask;
 unsigned long cr2;
};
# 190 "/usr/include/i386-linux-gnu/asm/sigcontext.h" 3 4
struct _xsave_hdr {
 __u64 xstate_bv;
 __u64 reserved1[2];
 __u64 reserved2[5];
};

struct _ymmh_state {

 __u32 ymmh_space[64];
};







struct _xstate {
 struct _fpstate fpstate;
 struct _xsave_hdr xstate_hdr;
 struct _ymmh_state ymmh;

};
# 29 "/usr/include/i386-linux-gnu/bits/sigcontext.h" 2 3 4



# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 33 "/usr/include/i386-linux-gnu/bits/sigcontext.h" 2 3 4
# 340 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) throw ();






# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 350 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) throw ();

# 1 "/usr/include/i386-linux-gnu/bits/sigstack.h" 1 3 4
# 26 "/usr/include/i386-linux-gnu/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 50 "/usr/include/i386-linux-gnu/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 357 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/sys/ucontext.h" 1 3 4
# 23 "/usr/include/i386-linux-gnu/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 24 "/usr/include/i386-linux-gnu/sys/ucontext.h" 2 3 4



# 1 "/usr/include/i386-linux-gnu/bits/sigcontext.h" 1 3 4
# 28 "/usr/include/i386-linux-gnu/sys/ucontext.h" 2 3 4



typedef int greg_t;





typedef greg_t gregset_t[19];



enum
{
  REG_GS = 0,

  REG_FS,

  REG_ES,

  REG_DS,

  REG_EDI,

  REG_ESI,

  REG_EBP,

  REG_ESP,

  REG_EBX,

  REG_EDX,

  REG_ECX,

  REG_EAX,

  REG_TRAPNO,

  REG_ERR,

  REG_EIP,

  REG_CS,

  REG_EFL,

  REG_UESP,

  REG_SS

};



struct _libc_fpreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
};

struct _libc_fpstate
{
  unsigned long int cw;
  unsigned long int sw;
  unsigned long int tag;
  unsigned long int ipoff;
  unsigned long int cssel;
  unsigned long int dataoff;
  unsigned long int datasel;
  struct _libc_fpreg _st[8];
  unsigned long int status;
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;


    fpregset_t fpregs;
    unsigned long int oldmask;
    unsigned long int cr2;
  } mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 360 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     throw () __attribute__ ((__deprecated__));



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) throw ();







extern int sighold (int __sig) throw ();


extern int sigrelse (int __sig) throw ();


extern int sigignore (int __sig) throw ();


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();






# 1 "/usr/include/i386-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/i386-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       __const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __threadid, int __signo) throw ();



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) throw ();
# 396 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) throw ();

extern int __libc_current_sigrtmax (void) throw ();



}
# 6 "/usr/include/unittest++/Posix/SignalTranslator.h" 2

namespace UnitTest {

class SignalTranslator
{
public:
    SignalTranslator();
    ~SignalTranslator();

    static sigjmp_buf* s_jumpTarget;

private:
    sigjmp_buf m_currentJumpTarget;
    sigjmp_buf* m_oldJumpTarget;

    struct sigaction m_old_SIGFPE_action;
    struct sigaction m_old_SIGTRAP_action;
    struct sigaction m_old_SIGSEGV_action;
    struct sigaction m_old_SIGBUS_action;
    struct sigaction m_old_SIGABRT_action;
    struct sigaction m_old_SIGALRM_action;
};
# 40 "/usr/include/unittest++/Posix/SignalTranslator.h"
}
# 11 "/usr/include/unittest++/ExecuteTest.h" 2


namespace UnitTest {

template< typename T >
void ExecuteTest(T& testObject, TestDetails const& details)
{
 CurrentTest::Details() = &details;

 try
 {

  UnitTest::SignalTranslator sig; if (__extension__ __sigsetjmp (*UnitTest::SignalTranslator::s_jumpTarget, 1) != 0) throw ("Unhandled system exception");

  testObject.RunImpl();
 }
 catch (AssertException const& e)
 {
  CurrentTest::Results()->OnTestFailure(
   TestDetails(details.testName, details.suiteName, e.Filename(), e.LineNumber()), e.what());
 }
 catch (std::exception const& e)
 {
  MemoryOutStream stream;
  stream << "Unhandled exception: " << e.what();
  CurrentTest::Results()->OnTestFailure(details, stream.GetText());
 }
 catch (...)
 {
  CurrentTest::Results()->OnTestFailure(details, "Unhandled exception: Crash!");
 }
}

}
# 6 "/usr/include/unittest++/TestMacros.h" 2
# 13 "/usr/include/unittest++/UnitTest++.h" 2

# 1 "/usr/include/unittest++/CheckMacros.h" 1



# 1 "/usr/include/unittest++/Checks.h" 1







namespace UnitTest {


template< typename Value >
bool Check(Value const value)
{
    return !!value;
}


template< typename Expected, typename Actual >
void CheckEqual(TestResults& results, Expected const& expected, Actual const& actual, TestDetails const& details)
{
    if (!(expected == actual))
    {
        UnitTest::MemoryOutStream stream;
        stream << "Expected " << expected << " but was " << actual;

        results.OnTestFailure(details, stream.GetText());
    }
}

void CheckEqual(TestResults& results, char const* expected, char const* actual, TestDetails const& details);

void CheckEqual(TestResults& results, char* expected, char* actual, TestDetails const& details);

void CheckEqual(TestResults& results, char* expected, char const* actual, TestDetails const& details);

void CheckEqual(TestResults& results, char const* expected, char* actual, TestDetails const& details);

template< typename Expected, typename Actual, typename Tolerance >
bool AreClose(Expected const& expected, Actual const& actual, Tolerance const& tolerance)
{
    return (actual >= (expected - tolerance)) && (actual <= (expected + tolerance));
}

template< typename Expected, typename Actual, typename Tolerance >
void CheckClose(TestResults& results, Expected const& expected, Actual const& actual, Tolerance const& tolerance,
                TestDetails const& details)
{
    if (!AreClose(expected, actual, tolerance))
    {
        UnitTest::MemoryOutStream stream;
        stream << "Expected " << expected << " +/- " << tolerance << " but was " << actual;

        results.OnTestFailure(details, stream.GetText());
    }
}


template< typename Expected, typename Actual >
void CheckArrayEqual(TestResults& results, Expected const& expected, Actual const& actual,
                int const count, TestDetails const& details)
{
    bool equal = true;
    for (int i = 0; i < count; ++i)
        equal &= (expected[i] == actual[i]);

    if (!equal)
    {
        UnitTest::MemoryOutStream stream;

  stream << "Expected [ ";

  for (int expectedIndex = 0; expectedIndex < count; ++expectedIndex)
            stream << expected[expectedIndex] << " ";

  stream << "] but was [ ";

  for (int actualIndex = 0; actualIndex < count; ++actualIndex)
            stream << actual[actualIndex] << " ";

  stream << "]";

        results.OnTestFailure(details, stream.GetText());
    }
}

template< typename Expected, typename Actual, typename Tolerance >
bool ArrayAreClose(Expected const& expected, Actual const& actual, int const count, Tolerance const& tolerance)
{
    bool equal = true;
    for (int i = 0; i < count; ++i)
        equal &= AreClose(expected[i], actual[i], tolerance);
    return equal;
}

template< typename Expected, typename Actual, typename Tolerance >
void CheckArrayClose(TestResults& results, Expected const& expected, Actual const& actual,
                   int const count, Tolerance const& tolerance, TestDetails const& details)
{
    bool equal = ArrayAreClose(expected, actual, count, tolerance);

    if (!equal)
    {
        UnitTest::MemoryOutStream stream;

        stream << "Expected [ ";
        for (int expectedIndex = 0; expectedIndex < count; ++expectedIndex)
            stream << expected[expectedIndex] << " ";
        stream << "] +/- " << tolerance << " but was [ ";

  for (int actualIndex = 0; actualIndex < count; ++actualIndex)
            stream << actual[actualIndex] << " ";
        stream << "]";

        results.OnTestFailure(details, stream.GetText());
    }
}

template< typename Expected, typename Actual, typename Tolerance >
void CheckArray2DClose(TestResults& results, Expected const& expected, Actual const& actual,
                   int const rows, int const columns, Tolerance const& tolerance, TestDetails const& details)
{
    bool equal = true;
    for (int i = 0; i < rows; ++i)
        equal &= ArrayAreClose(expected[i], actual[i], columns, tolerance);

    if (!equal)
    {
        UnitTest::MemoryOutStream stream;

        stream << "Expected [ ";

  for (int expectedRow = 0; expectedRow < rows; ++expectedRow)
        {
            stream << "[ ";
            for (int expectedColumn = 0; expectedColumn < columns; ++expectedColumn)
                stream << expected[expectedRow][expectedColumn] << " ";
            stream << "] ";
        }

  stream << "] +/- " << tolerance << " but was [ ";

  for (int actualRow = 0; actualRow < rows; ++actualRow)
        {
            stream << "[ ";
            for (int actualColumn = 0; actualColumn < columns; ++actualColumn)
                stream << actual[actualRow][actualColumn] << " ";
            stream << "] ";
        }

  stream << "]";

        results.OnTestFailure(details, stream.GetText());
    }
}

}
# 5 "/usr/include/unittest++/CheckMacros.h" 2
# 15 "/usr/include/unittest++/UnitTest++.h" 2
# 1 "/usr/include/unittest++/TestRunner.h" 1







namespace UnitTest {

class TestReporter;
class TestResults;
class Timer;

int RunAllTests();

struct True
{
 bool operator()(const Test* const) const
 {
  return true;
 }
};

class TestRunner
{
public:
 explicit TestRunner(TestReporter& reporter);
 ~TestRunner();

 template <class Predicate>
 int RunTestsIf(TestList const& list, char const* suiteName,
       const Predicate& predicate, int maxTestTimeInMs) const
 {
     Test* curTest = list.GetHead();

     while (curTest != 0)
     {
      if (IsTestInSuite(curTest,suiteName) && predicate(curTest))
   {
    RunTest(m_result, curTest, maxTestTimeInMs);
   }

   curTest = curTest->next;
     }

     return Finish();
 }

private:
 TestReporter* m_reporter;
 TestResults* m_result;
 Timer* m_timer;

 int Finish() const;
 bool IsTestInSuite(const Test* const curTest, char const* suiteName) const;
 void RunTest(TestResults* const result, Test* const curTest, int const maxTestTimeInMs) const;
};

}
# 16 "/usr/include/unittest++/UnitTest++.h" 2
# 1 "/usr/include/unittest++/TimeConstraint.h" 1



# 1 "/usr/include/unittest++/TimeHelpers.h" 1



# 1 "/usr/include/unittest++/Posix/TimeHelpers.h" 1



# 1 "/usr/include/i386-linux-gnu/sys/time.h" 1 3 4
# 29 "/usr/include/i386-linux-gnu/sys/time.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/i386-linux-gnu/sys/time.h" 2 3 4
# 39 "/usr/include/i386-linux-gnu/sys/time.h" 3 4
extern "C" {
# 57 "/usr/include/i386-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 73 "/usr/include/i386-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (__const struct timeval *__tv,
    __const struct timezone *__tz)
     throw () __attribute__ ((__nonnull__ (1)));





extern int adjtime (__const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        __const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, __const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, __const char *__file,
        __const struct timeval __tvp[2]) throw ();
# 191 "/usr/include/i386-linux-gnu/sys/time.h" 3 4
}
# 5 "/usr/include/unittest++/Posix/TimeHelpers.h" 2

namespace UnitTest {

class Timer
{
public:
    Timer();
    void Start();
    int GetTimeInMs() const;

private:
    struct timeval m_startTime;
};


namespace TimeHelpers
{
void SleepMs (int ms);
}


}
# 5 "/usr/include/unittest++/TimeHelpers.h" 2
# 5 "/usr/include/unittest++/TimeConstraint.h" 2

namespace UnitTest {

class TestResults;
class TestDetails;

class TimeConstraint
{
public:
    TimeConstraint(int ms, TestDetails const& details);
    ~TimeConstraint();

private:
    void operator=(TimeConstraint const&);
 TimeConstraint(TimeConstraint const&);

 Timer m_timer;
    TestDetails const& m_details;
 int const m_maxMs;
};






}
# 17 "/usr/include/unittest++/UnitTest++.h" 2
# 2 "test_smartPtr.cpp" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/refPtr.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/refPtr.h"
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/smartPtr.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/smartPtr.h"
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cTemplateHelper.h" 1
# 17 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cTemplateHelper.h"
       



# 1 "/usr/include/c++/4.8/cstring" 1 3
# 39 "/usr/include/c++/4.8/cstring" 3
       
# 40 "/usr/include/c++/4.8/cstring" 3


# 1 "/usr/include/string.h" 1 3 4
# 29 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 35 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const void *memchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 93 "/usr/include/string.h" 3 4
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *rawmemchr (__const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 165 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 210 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strchr (__const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 233 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strrchr (__const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/string.h" 3 4
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *strchrnul (__const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strpbrk (__const char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 312 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strstr (__const char *__haystack,
        __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" __const char *strcasestr (__const char *__haystack,
           __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 382 "/usr/include/string.h" 3 4
extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *index (__const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *rindex (__const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 515 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *basename (__const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 646 "/usr/include/string.h" 3 4
}
# 43 "/usr/include/c++/4.8/cstring" 2 3
# 71 "/usr/include/c++/4.8/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 120 "/usr/include/c++/4.8/cstring" 3

}
# 22 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cTemplateHelper.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/engineTypes.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/engineTypes.h"
       

# 1 "/usr/include/c++/4.8/climits" 1 3
# 39 "/usr/include/c++/4.8/climits" 3
       
# 40 "/usr/include/c++/4.8/climits" 3

# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 168 "/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/posix1_lim.h" 1 3 4
# 157 "/usr/include/i386-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/local_lim.h" 1 3 4
# 39 "/usr/include/i386-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/i386-linux-gnu/bits/local_lim.h" 2 3 4
# 158 "/usr/include/i386-linux-gnu/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/i386-linux-gnu/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/i386-linux-gnu/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/i386-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/i386-linux-gnu/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 42 "/usr/include/c++/4.8/climits" 2 3
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/engineTypes.h" 2
# 1 "/usr/include/c++/4.8/cfloat" 1 3
# 39 "/usr/include/c++/4.8/cfloat" 3
       
# 40 "/usr/include/c++/4.8/cfloat" 3

# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/float.h" 1 3 4
# 42 "/usr/include/c++/4.8/cfloat" 2 3
# 19 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/engineTypes.h" 2
# 1 "/usr/include/c++/4.8/cstdio" 1 3
# 39 "/usr/include/c++/4.8/cstdio" 3
       
# 40 "/usr/include/c++/4.8/cstdio" 3
# 20 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/engineTypes.h" 2
# 1 "/usr/include/c++/4.8/cstddef" 1 3
# 39 "/usr/include/c++/4.8/cstddef" 3
       
# 40 "/usr/include/c++/4.8/cstddef" 3


# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 422 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 42 "/usr/include/c++/4.8/cstddef" 2 3
# 21 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/engineTypes.h" 2
# 47 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/engineTypes.h"
typedef unsigned char u8;
typedef signed char s8;
typedef char c8;

typedef unsigned short u16;
typedef short s16;

typedef unsigned int u32;
typedef int s32;

typedef float f32;
typedef double f64;

typedef unsigned long ul64;
typedef long l64;

template<typename def, typename inner = typename def::type>
class safe_enum : public def
{
        typedef inner type;
        inner val;

    public:

        safe_enum() {}
        safe_enum(type v) : val(v) {}
        type value() const { return val; }
        const char* name() { return def::name((typename def::type)val); }

        friend bool operator == (const safe_enum & lhs, const safe_enum & rhs) { return lhs.val == rhs.val; }
        friend bool operator != (const safe_enum & lhs, const safe_enum & rhs) { return lhs.val != rhs.val; }
        friend bool operator < (const safe_enum & lhs, const safe_enum & rhs) { return lhs.val < rhs.val; }
        friend bool operator <= (const safe_enum & lhs, const safe_enum & rhs) { return lhs.val <= rhs.val; }
        friend bool operator > (const safe_enum & lhs, const safe_enum & rhs) { return lhs.val > rhs.val; }
        friend bool operator >= (const safe_enum & lhs, const safe_enum & rhs) { return lhs.val >= rhs.val; }
};

namespace yame
{
    namespace mpl
    {
        class null_ptr_type;
        class none_t;
    };
}

extern yame::mpl::null_ptr_type null_ptr;
extern yame::mpl::none_t none;
# 23 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cTemplateHelper.h" 2
# 1 "/usr/include/c++/4.8/limits" 1 3
# 40 "/usr/include/c++/4.8/limits" 3
       
# 41 "/usr/include/c++/4.8/limits" 3
# 147 "/usr/include/c++/4.8/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "/usr/include/c++/4.8/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 277 "/usr/include/c++/4.8/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 303 "/usr/include/c++/4.8/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -2147483647L - 1; }

      static constexpr long
      max() noexcept { return 2147483647L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 2147483647L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1552 "/usr/include/c++/4.8/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750797e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859812e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859812e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570815e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570815e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308085e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544177e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 24 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cTemplateHelper.h" 2
# 43 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cTemplateHelper.h"
namespace yame
{
namespace mpl
{

struct none_t
{
};

struct null_ptr_type
{
};


template<typename T>
struct friend_maker
{
    typedef T type;
};

template<typename T>
struct wrapper
{
    typedef T type;
};

struct place_holder
{

};

static const place_holder place_arg;

template<typename T>
struct make_type_place_holder
{
    typedef place_holder type;
};

struct void_type
{

};

template<typename T>
struct drop_reference
{
    typedef T type;
};

template<typename T>
struct drop_reference<T&>
{
    typedef T type;
};

template<typename T>
struct drop_reference<T&&>
{
    typedef T type;
};

template<typename T>
struct drop_rreference
{
    typedef T type;
};

template<typename T>
struct drop_rreference<T&>
{
    typedef T& type;
};

template<typename T>
struct drop_rreference<T&&>
{
    typedef T type;
};

template<typename T>
struct add_reference
{
    typedef T& type;
};

template<typename T>
struct add_reference<T&>
{
    typedef T& type;
};

template<typename T>
struct add_reference<T&&>
{
    typedef T& type;
};

template<typename T>
struct add_rreference
{
    typedef T&& type;
};

template<typename T>
struct add_rreference<T&>
{
    typedef T& type;
};

template<typename T>
struct add_rreference<T&&>
{
    typedef T&& type;
};

template<typename T>
struct drop_constness
{
    typedef T type;
};

template<typename T>
struct drop_constness<const T>
{
    typedef T type;
};

template<typename T>
struct drop_constness<const T&>
{
    typedef T& type;
};

template<typename T>
struct drop_constness<const T&&>
{
    typedef T&& type;
};

template<typename T>
struct drop_constness<const T*>
{
    typedef T* type;
};

template<typename T>
struct add_constness
{
    typedef const T type;
};

template<typename T>
struct drop_pointer
{
    typedef T type;
};

template<typename T>
struct drop_pointer<T*>
{
    typedef T type;
};

template<typename T>
struct drop_pointer<const T*>
{
    typedef const T type;
};

template<typename T>
struct add_pointer
{
    typedef T* type;
};
# 233 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cTemplateHelper.h"
template<typename T>
constexpr T&& forward(typename drop_reference<T>::type& arg)
{
    return static_cast<T&&>(arg);
};

template<typename T>
constexpr T&& forward(typename drop_reference<T>::type&& arg)
{
    return static_cast<T&&>(arg);
};


template<typename T>
constexpr typename drop_reference<T>::type&& move(T&& arg)
{
    return reinterpret_cast<typename drop_reference<T>::type&&>(arg);
};

template<typename A, typename B>
struct is_same_type;

template<typename A, typename B>
struct is_same_type
{
    static const bool value = false;
};

template<typename A>
struct is_same_type<A,A>
{
    static const bool value = true;
};

template<typename T>
struct is_pointer;

template<typename T>
struct is_pointer<T *>
{
    static const bool value = true;
};

template<>
struct is_pointer<null_ptr_type>
{
    static const bool value = true;
};

template<typename T>
struct is_pointer
{
    static const bool value = false;
};

template<typename T>
struct is_const_pointer;

template<typename T>
struct is_const_pointer<const T *>
{
    static const bool value = true;
};

template<typename T>
struct is_const_pointer
{
    static const bool value = false;
};

template<typename T>
struct is_lreference;

template<typename T>
struct is_lreference<T&>
{
    static const bool value = true;
};

template<typename T>
struct is_lreference
{
    static const bool value = false;
};

template<typename T>
struct is_const;

template<typename T>
struct is_const<const T>
{
    static const bool value = true;
};

template<typename T>
struct is_const
{
    static const bool value = false;
};

template<typename T>
struct is_const_lreference
{
    static const bool value = is_lreference<T>::value && is_const<T>::value;
};

template<typename T>
struct is_rreference;

template<typename T>
struct is_rreference<T&&>
{
    static const bool value = true;
};

template<typename T>
struct is_rreference
{
    static const bool value = false;
};

template<typename T>
struct is_reference
{
    static const bool value = is_lreference<T>::value | is_rreference<T>::value;
};

template<typename>
struct is_integral
{
    static const bool value = false;
};

template<>
struct is_integral<bool>
{
    static const bool value = true;
};

template<>
struct is_integral<char>
{
    static const bool value = true;
};

template<>
struct is_integral<unsigned char>
{
    static const bool value = true;
};

template<>
struct is_integral<short>
{
    static const bool value = true;
};

template<>
struct is_integral<unsigned short>
{
    static const bool value = true;
};

template<>
struct is_integral<int>
{
    static const bool value = true;
};

template<>
struct is_integral<unsigned int>
{
    static const bool value = true;
};

template<>
struct is_integral<long>
{
    static const bool value = true;
};

template<>
struct is_integral<unsigned long>
{
    static const bool value = true;
};

template<>
struct is_integral<long long>
{
    static const bool value = true;
};

template<>
struct is_integral<unsigned long long>
{
    static const bool value = true;
};

template<typename>
struct is_numeric
{
    static const bool value = false;
};

template<>
struct is_numeric<bool>
{
    static const bool value = true;
};

template<>
struct is_numeric<char>
{
    static const bool value = true;
};

template<>
struct is_numeric<unsigned char>
{
    static const bool value = true;
};

template<>
struct is_numeric<short>
{
    static const bool value = true;
};

template<>
struct is_numeric<unsigned short>
{
    static const bool value = true;
};

template<>
struct is_numeric<int>
{
    static const bool value = true;
};

template<>
struct is_numeric<unsigned int>
{
    static const bool value = true;
};

template<>
struct is_numeric<long>
{
    static const bool value = true;
};

template<>
struct is_numeric<unsigned long>
{
    static const bool value = true;
};

template<>
struct is_numeric<long long>
{
    static const bool value = true;
};

template<>
struct is_numeric<unsigned long long>
{
    static const bool value = true;
};

template<>
struct is_numeric<float>
{
    static const bool value = true;
};

template<>
struct is_numeric<double>
{
    static const bool value = true;
};

template<>
struct is_numeric<long double>
{
    static const bool value = true;
};

template<bool cond, typename Type=void>
struct enable_if;

template<typename Type>
struct enable_if<true,Type>
{
    typedef Type type;
};

template<typename Type>
struct enable_if<false,Type>
{
};

template<bool,typename ...>
struct static_if;

template<typename T,typename ... TT>
struct static_if<true,T,TT...>
{
    typedef T type;
};

template<typename T,typename TT>
struct static_if<false,T,TT>
{
    typedef TT type;
};

template<typename T>
struct static_if<false,T>
{

};

template<typename ... Types>
struct get_num_types;

template<typename T, typename ... Types>
struct get_num_types<T,Types...>
{
    static const int value = 1+get_num_types<Types...>::value;
};
template<>
struct get_num_types<>
{
    static const int value = 0;
};

template<int, typename ...>
struct nth_type_of;

template<int Pos, typename Type, typename ... Types>
struct nth_type_of<Pos,Type,Types...>
{
    typedef typename nth_type_of<Pos-1,Types...>::type type;
};

template<typename Type, typename ... Types>
struct nth_type_of<0,Type,Types...>
{
    typedef Type type;
};

template<int Pos>
struct nth_type_of<Pos>
{
    typedef void_type type;
};

template<typename T>
struct transform_type
{
template<typename TT>
struct to
{
    typedef TT type;
};
};

template<int Index>
struct transform_index_type
{
template<typename TT>
struct to
{
    typedef TT type;
};
};

template<typename ... Bases>
class composed_class : public Bases ...
{};

template<int pos, typename ... Args>
struct _nth_val_of;

template<int pos, typename Arg, typename ... Args>
struct _nth_val_of<pos,Arg,Args...>
{
    static constexpr typename nth_type_of<pos,Arg,Args...>::type is(Arg arg, Args...args)
    {
        return _nth_val_of<pos-1,Args...>::is(mpl::forward<Args>(args)...);
    }
};

template<typename Arg, typename ... Args>
struct _nth_val_of<0,Arg,Args...>
{
    static constexpr Arg is(Arg arg, Args...args)
    {
        return mpl::forward<Arg>(arg);
    }
};

template<>
struct _nth_val_of<0>
{
    static void is()
    {
        return;
    }
};

template<int pos, typename ... Args>
constexpr typename nth_type_of<pos,Args&&...>::type nth_val_of(Args&& ... args)
{
    static_assert(pos >= 0 && pos < get_num_types<Args...>::value, "Index out of bounds");


    return mpl::forward<typename nth_type_of<pos,Args&&...>::type>(_nth_val_of<pos,Args&&...>::is(mpl::forward<Args>(args)...));
}

template<typename base, typename derived>
struct is_base_of;

template<typename base>
struct is_base_of<base,base>
{
    static const bool value = true;
};

template<typename base, typename derived>
struct is_base_of
{
    typedef char (&yes)[2];
    typedef char (&no)[1];
    typedef typename mpl::drop_reference<derived>::type rawDerived;
    typedef typename mpl::drop_reference<base>::type rawBase;

    struct Tester
    {
        operator rawBase* () const;
        operator rawDerived* ();
    };

    template<typename T>
    static yes Test(rawDerived*,T);
    static no Test(rawBase*,int);

    static const bool value = sizeof(Test(Tester(),0)) == sizeof(yes);
};

template<typename>
struct instantiateType;

template<typename T>
struct instantiateType<T&>
{
    static T& get()
    {
        return reinterpret_cast<T&>(0);
    }
};

template<typename T>
struct instantiateType<T&&>
{
    static T&& get()
    {
        return reinterpret_cast<T&&>(0);
    }
};

template<typename T>
struct instantiateType
{
    static T get()
    {
        return *reinterpret_cast<T*>(0);
    }
};

template<typename T>
struct is_trivially_copiable
{

    static const bool value = true;
};

template<typename ... Args>
struct is_constructible;

template<typename Type>
struct is_constructible<Type*>
{
    static const bool value = true;
};

template<typename Type, typename ... Args>
struct is_constructible<Type*,Args...>
{
    static_assert(get_num_types<Args...>::value == 1, "Cannot construct pointer from more than one type!");

    typedef typename nth_type_of<0,Args...>::type firstArg;
    typedef typename drop_pointer<firstArg>::type ArgType;

    static const bool value = mpl::is_pointer<firstArg>::value && is_base_of<ArgType,Type>::value;
};


template<typename Type, typename ... Args>
struct is_constructible<Type&,Args...>
{
    static_assert(get_num_types<Args...>::value == 1, "Cannot construct reference from more than one type!");

    typedef typename nth_type_of<0,Args...>::type firstArg;
    typedef typename drop_reference<firstArg>::type ArgType;
    typedef typename drop_reference<ArgType>::type ArgRawType;
    typedef typename drop_constness<Type>::type RawType;

    static const bool type_constrains = is_reference<firstArg>::value;
    static const bool inheritance_constrain = is_same_type<ArgRawType, RawType>::value || is_base_of<ArgRawType,RawType>::value;
    static const bool constness_constrain = is_const<Type>::value || is_const<ArgType>::value == false;

    static const bool value = type_constrains && inheritance_constrain && constness_constrain;
};

template<typename Type, typename ... Args>
struct is_constructible<Type&&,Args...>
{
    static_assert(get_num_types<Args...>::value == 1, "Cannot construct reference from more than one type!");

    typedef typename nth_type_of<0,Args...>::type firstArg;
    typedef typename drop_reference<firstArg>::type ArgType;
    typedef typename drop_constness<ArgType>::type RawArg;
    typedef typename drop_constness<Type>::type RawType;

    static const bool type_constrains = is_rreference<firstArg>::value || is_const_lreference<firstArg>::value;
    static const bool inheritance_constrain = is_same_type<RawArg, RawType>::value || is_base_of<RawArg,RawType>::value;
    static const bool constness_constrain = is_const<Type>::value == false || is_const<ArgType>::value;

    static const bool value = type_constrains && inheritance_constrain && constness_constrain;
};

template<typename Type, typename ... Args>
struct is_constructible<Type,Args...>
{
    template<typename T>
    static constexpr bool Test(decltype(T(instantiateType<Args>::get()...))* foo) { return true; }
    template<typename>
    static constexpr bool Test(...) { return false; }

    static const bool value = Test<Type>(0);
};

template<typename T>
struct is_default_constructible : is_constructible<T>
{
    using is_constructible<T>::value;
};
template<typename T>
struct is_copy_constructible;

template<typename T>
struct is_copy_constructible : is_constructible<T,T&>
{
    using is_constructible<T,T&>::value;
};
template<typename T>
struct is_copy_constructible<T*>
{
    static const bool value = true;
};

template<typename T>
struct is_move_constructible;

template<typename T>
struct is_move_constructible : is_constructible<T,T&&>
{
    using is_constructible<T,T&&>::value;
};
template<typename T>
struct is_move_constructible<T*>
{
    static const bool value = true;
};

template<typename typeA, typename typeB>
struct is_type_constructible : is_constructible<typeA, typeB>
{
    using is_constructible<typeA, typeB>::value;
};

template<bool isDefaultConstructible>
struct initialize_memory;

template<>
struct initialize_memory<true>
{
    template<typename T>
    static constexpr void init(void* address)
    {
        if(address)
        {
            new (address) T();
        }

        return;
    }
};

template<>
struct initialize_memory<false>
{
    template<typename T>
    static constexpr void init(void* address)
    {
        if(address)
        {

            memset(address,0,sizeof(T));
        }

        return;
    }
};

template<typename T, typename ... Args>
void construct(T* address)
{
    initialize_memory<is_default_constructible<T>::value>::template init<T>((void*)address);
};

template<typename T>
struct total_dim
{
    static const size_t value = 0;
};

template<typename T>
struct total_rank
{
    static const size_t value = 1;
};

template<typename T>
struct type_size
{
    static const size_t value = sizeof(T);
};

template<typename T>
struct thisType
{
    template<typename dummy, typename ... TT>
    struct _is_of_type;

    template<typename dummy>
    struct _is_of_type<dummy>
    {
        static const bool value = false;
    };

    template<typename dummy, typename TT, typename ... TTT>
    struct _is_of_type<dummy,TT,TTT...>
    {
        static const bool value = thisType<T>::template _is_of_type<dummy,TTT...>::value;
    };

    template<typename dummy,typename ... TT>
    struct _is_of_type<dummy,T,TT...>
    {
        static const bool value = true;
    };

    template<typename ... TT>
    struct is_of_types
    {
        static const bool value = _is_of_type<void,TT...>::value;
    };
};

template<int pos, int ... ranks>
struct nth_rank_of;

template<int pos, int rank, int ... ranks>
struct nth_rank_of<pos,rank,ranks...>
{
    static const int value = nth_rank_of<pos-1,ranks...>::_rank;
    static const int _rank = rank;
};

template<int rank, int ... ranks>
struct nth_rank_of<0,rank,ranks...>
{
    static const int _rank = rank;
    static const int value = _rank;
};

template<int pos>
struct nth_rank_of<pos>
{
    static const int value = -1;
};

template<int ... ranks>
struct get_num_ranks;

template<int rank, int ... ranks>
struct get_num_ranks<rank,ranks...>
{
    static const int value = 1+get_num_ranks<ranks...>::value;
};
template<>
struct get_num_ranks<>
{
    static const int value = 0;
};

template<int ...ranks>
struct check_monotonic_range;

template<int rank, int ...ranks>
struct check_monotonic_range<rank,ranks...>
{
    static const bool cond = rank < check_monotonic_range<ranks...>::_rank && check_monotonic_range<ranks...>::cond;
    static const int _rank = rank;
};

template<>
struct check_monotonic_range<>
{
    static const bool cond = true;
    static const int _rank = std::numeric_limits<int>::max();
};

template<int rankA, int rankB>
struct is_same_rank
{
    static const bool value = rankA == rankB;
};

template<int rankToAdd, int ... ranks>
struct addSortedRank;

template<int ... ranks>
struct sequence
{
    template<template<int ...> class M>
    struct derived_type
    {
        typedef M<ranks...> derivedType;
    };

    template<typename dummy,int ... otherRanks>
    struct _merge;

    template<typename dummy,int otherRank, int ... otherRanks>
    struct _merge<dummy,otherRank,otherRanks...>
    {
        typedef typename addSortedRank<otherRank,ranks...>::type::template _merge<void,otherRanks...>::type type;
    };

    template<typename dummy>
    struct _merge<dummy>
    {
        typedef sequence<ranks...> type;
    };

    template<int ... otherRanks>
    struct merge
    {
        typedef typename _merge<void,otherRanks...>::type type;
    };

    template<int currIndex, int currNum, int ... sub_ranks>
    struct _get_relative_num;

    template<int currIndex, int currNum, int sub_rank, int ... sub_ranks>
    struct _get_relative_num<currIndex, currNum, sub_rank, sub_ranks...>
    {
        static const int value = _get_relative_num<currIndex+1, currNum, sub_ranks...>::value;
    };

    template<int currIndex, int currNum, int ... sub_ranks>
    struct _get_relative_num<currIndex, currNum, currNum, sub_ranks...>
    {
        static const int value = currIndex;
    };

    template<int num>
    struct get_relative_num
    {
        static const int value = _get_relative_num<0,num,ranks...>::value;
    };

    template<int ... nums>
    struct get_relative_rank
    {
        typedef sequence<get_relative_num<nums>::value ...> type;
    };

    template<int ... nums>
    struct merge_relative
    {
        typedef typename merge<get_relative_num<nums>::value ...>::type type;
    };

    template<typename dummy, int ... otherRanks>
    struct _add;

    template<typename dummy, int otherRank, int ... otherRanks>
    struct _add<dummy,otherRank,otherRanks...>
    {
        template<int ... mergedRanks>
        struct is
        {
            typedef typename _add<dummy,otherRanks...>::template is<mergedRanks..., otherRank>::type type;
        };
    };

    template<typename dummy>
    struct _add<dummy>
    {
        template<int ... mergedRanks>
        struct is
        {
            typedef sequence<mergedRanks...> type;
        };
    };

    template<typename>
    struct add;

    template<int ... otherRanks>
    struct add<sequence<otherRanks...>>
    {
        typedef typename _add<void,otherRanks...>::template is<ranks...>::type type;
    };
};

template<int N>
static constexpr bool are_ranks_equal_to()
{
    return false;
}

template<int N, typename rank, typename ... ranks>
static constexpr bool are_ranks_equal_to(rank i_value, ranks ... i_values)
{
    return i_value == N && (get_num_types<ranks...>::value == 0 || are_ranks_equal_to<N,ranks...>(i_values...));
}

template<int ... ranks>
struct sort_ranks
{
    typedef typename sequence<>::template merge<ranks...>::type type;
};

template<int val1, int val2, bool cond>
struct _get_max;

template<int val1, int val2>
struct _get_max<val1,val2,true>
{
    static const int value = val1;
};

template<int val1, int val2>
struct _get_max<val1,val2,false>
{
    static const int value = val2;
};

template<int val1, int val2>
struct get_max
{
    static const int value = _get_max<val1,val2,(val1 > val2)>::value;
};

template<int ... vals>
struct _max_of;

template<>
struct _max_of<>
{
    template<int currMax, int _indCurrMax, bool bigger>
    struct is;

    template<int currMax, int _indCurrMax>
    struct is<currMax, _indCurrMax, false>
    {
        static const int indCurrMax = _indCurrMax;
    };

    template<int currMax, int _indCurrMax>
    struct is<currMax, _indCurrMax, true>
    {
        static const int indCurrMax = 0;
    };
};

template<int val, int ... vals>
struct _max_of<val, vals...>
{
    template<int currMax, int _indCurrMax, bool bigger>
    struct is;

    template<int currMax, int _indCurrMax>
    struct is<currMax,_indCurrMax,false>
    {
        static const int indCurrMax = _max_of<vals...>::template is<get_max<currMax, val>::value, _indCurrMax, (val > currMax)>::indCurrMax;
    };

    template<int currMax, int _indCurrMax>
    struct is<currMax, _indCurrMax, true>
    {
        static const int indCurrMax = _max_of<vals...>::template is<get_max<currMax, val>::value, 1+sizeof...(vals), (val > currMax)>::indCurrMax;
    };
};

template<int val, int ... vals>
struct max_of
{
    static const int index = sizeof...(vals) - _max_of<vals...>::template is<val, sizeof...(vals), false>::indCurrMax;
};



template<typename ... Types>
struct max_size_of;

template<typename Type, typename ... Types>
struct max_size_of<Type, Types...>
{
    typedef typename nth_type_of<max_of<sizeof(Type), sizeof(Types)...>::index, Type, Types...>::type type;
    static const size_t value = sizeof(type);
};

template<typename Type>
struct max_size_of<Type>
{
    static const int value = sizeof(Type);
    typedef Type type;
};



template<template <class, class> class predicate, bool cond, int _pos, typename ... Types>
struct _nth_pos_of_predicate;

template<template <class, class> class predicate, int _pos, typename TType, typename Type, typename ... Types>
struct _nth_pos_of_predicate<predicate, false, _pos, TType, Type, Types...>
{
    static const size_t value = _nth_pos_of_predicate<predicate, predicate<Type,TType>::value, _pos + 1, TType, Types...>::value;
};

template<template <class, class> class predicate, int _pos, typename Type, typename ... Types>
struct _nth_pos_of_predicate < predicate, true, _pos, Type, Types... >
{
    static const size_t value = _pos;
};

template<template <class, class> class predicate, int _pos, typename Type>
struct _nth_pos_of_predicate < predicate, false, _pos, Type>
{
    static const size_t value = (2147483647 * 2U + 1U);
};

template<template <class,class> class predicate, typename Type, typename ... Types>
struct nth_pos_of_predicate;

template<template <class, class> class predicate, typename TType, typename Type, typename ... Types>
struct nth_pos_of_predicate<predicate, TType, Type, Types...>
{
    static const size_t value = _nth_pos_of_predicate<predicate, predicate<Type, TType>::value, 0, TType, Types...>::value;
};

template<template <class, class> class predicate, typename Type>
struct nth_pos_of_predicate < predicate, Type>
{
    static const size_t value = (2147483647 * 2U + 1U);
};



template<typename Type, typename ... Types>
struct nth_pos_of_type
{
    static const size_t value = nth_pos_of_predicate<is_same_type,Type,Types...>::value;
};




template<typename Type, typename ... Types>
struct nth_pos_of_constructible_type
{
    static const size_t value = nth_pos_of_predicate<is_type_constructible, Type, Types...>::value;
};



template<typename Type, typename ... Types>
struct is_among_types
{
    static const bool value = (nth_pos_of_predicate<is_same_type, Type, Types...>::value != (2147483647 * 2U + 1U));
};




template<typename Type, typename ... Types>
struct is_among_constructible_types
{
    static const bool value = (nth_pos_of_predicate<is_type_constructible, Type, Types...>::value != (2147483647 * 2U + 1U));
};



template<typename ... Types>
struct has_duplicate_types;

template<typename Type, typename ... Types>
struct has_duplicate_types < Type, Types... >
{
    static const bool value = is_among_types<Type,Types...>::value || has_duplicate_types<Types...>::value;
};

template<>
struct has_duplicate_types < >
{
    static const bool value = false;
};

template<int, int, int ...>
struct _create_range_rank;

template<int endRank, int currRank, int ... ranks>
struct _create_range_rank
{
    typedef typename _create_range_rank<endRank,currRank+1,ranks...,currRank>::type type;
};

template<int endRank, int ... ranks>
struct _create_range_rank<endRank,endRank,ranks...>
{
    typedef sequence<ranks...> type;
};

template<int initRank, int endRank>
struct create_range_rank
{
    typedef typename _create_range_rank<endRank,initRank>::type type;
};

template<int rankToAdd, int currPos, int pos, int ... ranks>
struct _addRank;

template<int rankToAdd, int currPos, int pos, int rank, int ... ranks>
struct _addRank<rankToAdd,currPos,pos,rank,ranks...>
{
    template<int ... leftRanks>
    struct left_ranks
    {
        typedef typename _addRank<rankToAdd,currPos+1,pos,ranks...>::template left_ranks<leftRanks...,rank>::type type;
    };
};

template<int rankToAdd, int pos, int ... ranks>
struct _addRank<rankToAdd,pos,pos,ranks...>
{
    template<int ... leftRanks>
    struct left_ranks
    {
        typedef sequence<leftRanks...,rankToAdd,ranks...> type;
    };
};

template<int rankToAdd, int pos, int ... ranks>
struct addRank
{
    typedef typename _addRank<rankToAdd,0,pos,ranks...>::type type;
};

template<int rankToAdd, int ... ranks>
struct _addSortedRank;

template<int rankToAdd, int rank, int ... ranks>
struct _addSortedRank<rankToAdd,rank,ranks...>
{
    static const int _rank = rank;

    template<bool cond,int ... leftRanks>
    struct _left_ranks;

    template<int ... leftRanks>
    struct _left_ranks<true,leftRanks...>
    {
        typedef sequence<leftRanks...,rankToAdd,rank,ranks...> type;
    };

    template<int ... leftRanks>
    struct _left_ranks<false,leftRanks...>
    {
        typedef typename _addSortedRank<rankToAdd,ranks...>::template _left_ranks<(rankToAdd<_addSortedRank<rankToAdd,ranks...>::_rank),leftRanks...,rank>::type type;
    };

    struct left_ranks
    {
        typedef typename _left_ranks<(rankToAdd<rank)>::type type;
    };
};

template<int rankToAdd>
struct _addSortedRank<rankToAdd>
{
    static const int _rank = -1;

    template<bool cond, int ... leftRanks>
    struct _left_ranks
    {
        typedef sequence<leftRanks...,rankToAdd> type;
    };

    struct left_ranks
    {
        typedef typename _left_ranks<true>::type type;
    };
};

template<int rankToAdd, int ... ranks>
struct addSortedRank
{
    typedef typename _addSortedRank<rankToAdd,ranks...>::left_ranks::type type;
};

template<int num, int ... ranks>
struct is_num_in_ranks;

template<int num>
struct is_num_in_ranks<num>
{
    static const bool value = false;
};

template<int num, int rank, int ... ranks>
struct is_num_in_ranks<num,rank,ranks...>
{
    static const bool value = num==rank || is_num_in_ranks<num,ranks...>::value;
};

template<int endRank, int currRank, int ... ranks>
struct _create_range_rank_compl;

template<int endRank, int currRank, int ... ranks>
struct _create_range_rank_compl
{
    template<bool isInRank, int ... addedRanks>
    struct addRank;

    template<int ... addedRanks>
    struct addRank<true,addedRanks...>
    {
        typedef typename _create_range_rank_compl<endRank,currRank+1,ranks...>:: template addRank<!is_num_in_ranks<currRank+1,ranks...>::value,addedRanks...,currRank>::type type;
    };

    template<int ... addedRanks>
    struct addRank<false,addedRanks...>
    {
        typedef typename _create_range_rank_compl<endRank,currRank+1,ranks...>:: template addRank<!is_num_in_ranks<currRank+1,ranks...>::value,addedRanks...>::type type;
    };
};

template<int endRank, int ... ranks>
struct _create_range_rank_compl<endRank,endRank,ranks...>
{
    template<bool isInRank, int ... addedRanks>
    struct addRank
    {
        typedef sequence<addedRanks...> type;
    };
};


template<int initRank, int endRank, int ... ranks>
struct create_range_rank_compl
{
    typedef typename _create_range_rank_compl<endRank,initRank,ranks...>::template addRank<!is_num_in_ranks<initRank,ranks...>::value>::type type;
};

template<typename T>
void swapItems(T& a, T& b)
{
    T c(a);
    a=move(b);
    b=move(c);

    return;
}

template<typename T, template<typename,int...> class, int ... ranks>
struct get_sub_tuple;

template<typename T, template<typename,int...> class M, int rank, int ... ranks>
struct get_sub_tuple<T,M,rank,ranks...>
{
    typedef M<T,rank,ranks...> type;
};

template<typename T, template<typename,int...> class M, int ... ranks>
struct get_sub_tuple<M<T,ranks...>,M>
{
    typedef M<T,ranks...> type;
};
template<typename T, template<typename,int...> class M>
struct get_sub_tuple<T,M>
{
    typedef T type;
};


template<typename T>
constexpr u8 getDepthTupleType(T)
{
    return 0;
}

template<typename T>
constexpr u8 getDepthTupleType(typename T::primitive_type)
{
    return 1 + getDepthTupleType<typename T::base_type>(typename T::primitive_type());
}


template<typename,bool>
struct get_primitive_type;

template<typename T>
struct get_primitive_type<T,true>
{
    typedef typename T::primitive_type type;
};

template<typename T>
struct get_primitive_type<T,false>
{
    typedef T type;
};

template<typename T>
struct has_base_type
{
    typedef char yes[1];
    typedef char no[2];

    template <typename C>
    static yes& test(typename C::base_type*);

    template <typename>
    static no& test(...);

    static const bool value = sizeof(test<T>(__null)) == sizeof(yes);
};


template <typename, int, int>
struct get_base_type;

template <typename T, int val, int n=0>
struct get_base_type
{
    typedef typename get_base_type<typename T::base_type,val,n+1>::type type;
};

template <typename T, int val>
struct get_base_type<T,val,val>
{
    typedef T type;
};


template <typename, int, int, template<typename,int...> class>
struct append_dim;

template <typename T, int n, int val, template<typename,int...> class M>
struct append_dim
{
    template<int ... summRanks>
    struct is;

    template<int ... summRanks>
    struct is
    {
        typedef typename append_dim<T,n-1,val,M>::template is<summRanks...,val>::type type;
    };
};

template <typename T, int val, template<typename,int...> class M>
struct append_dim<T,0,val,M>
{
    template<int ... summRanks>
    struct is;

    template<int summRank, int ... summRanks>
    struct is<summRank,summRanks...>
    {
        typedef M<T,summRank,summRanks...> type;
    };
};

template <typename, template<typename,int...> class, int ... ranks>
struct sum_rank;

template <typename T, template<typename,int...> class M, int rank, int ... ranks>
struct sum_rank<T,M,rank,ranks...>
{
    template<class dummy=void, int ... ranksOther>
    struct with;

    template<class dummy, int rankOther, int ... ranksOther>
    struct with<dummy,rankOther,ranksOther...>
    {
        template<class dummyIs=void,int ... summRanks>
        struct is;

        template<class dummyIs,int ... summRanks>
        struct is
        {
            typedef typename sum_rank<T,M,ranks...>::template with<dummy,ranksOther...>::template is<dummyIs,summRanks...,rank+rankOther>::type type;
        };
    };

    template<class dummy>
    struct with<dummy>
    {
        template<class dummyIs=void, int ... summRanks>
        struct is;

        template<class dummyIs, int ... summRanks>
        struct is
        {
            typedef typename sum_rank<T,M,ranks...>::template with<dummy>::template is<dummyIs,summRanks...,rank>::type type;
        };
    };
};

template <typename T, template<typename,int...> class M>
struct sum_rank<T,M>
{
    template<class dummy=void,int ... ranksOther>
    struct with;

    template<class dummy,int rankOther, int ... ranksOther>
    struct with<dummy,rankOther,ranksOther...>
    {
        template<class dummyIs, int ... summRanks>
        struct is;

        template<class dummyIs, int ... summRanks>
        struct is
        {
            typedef typename sum_rank<T,M>::template with<dummy,ranksOther...>::template is<dummyIs,summRanks...,rankOther>::type type;
        };
    };

    template<class dummy>
    struct with<dummy>
    {
        template<class dummyIs=void, int ... summRanks>
        struct is;

        template<class dummyIs, int summRank, int ... summRanks>
        struct is<dummyIs,summRank,summRanks...>
        {
            typedef M<T,summRank,summRanks...> type;
        };

        template<class dummyIs>
        struct is<dummyIs>
        {
            typedef M<T,1> type;
        };
    };
};

template <typename, template<typename,int...> class, int ... ranks>
struct subs_rank;

template <typename T, template<typename,int...> class M, int rank, int ... ranks>
struct subs_rank<T,M,rank,ranks...>
{
    template<class dummy=void, int ... ranksOther>
    struct with;

    template<class dummy, int rankOther, int ... ranksOther>
    struct with<dummy,rankOther,ranksOther...>
    {
        template<class dummyIs=void,int ... subsRanks>
        struct is;

        template<class dummyIs,int ... subsRanks>
        struct is
        {
            typedef typename subs_rank<T,M,ranks...>::template with<dummy,ranksOther...>::template is<dummyIs,subsRanks...,rank-rankOther>::type type;
        };
    };

    template<class dummy>
    struct with<dummy>
    {
        template<class dummyIs=void, int ... subsRanks>
        struct is;

        template<class dummyIs, int ... subsRanks>
        struct is
        {
            typedef typename subs_rank<T,M,ranks...>::template with<dummy>::template is<dummyIs,subsRanks...,rank>::type type;
        };
    };
};

template <typename T, template<typename,int...> class M>
struct subs_rank<T,M>
{
    template<class dummy=void,int ... ranksOther>
    struct with;

    template<class dummy,int rankOther, int ... ranksOther>
    struct with<dummy,rankOther,ranksOther...>
    {
        template<class dummyIs, int ... subsRanks>
        struct is;

        template<class dummyIs, int ... subsRanks>
        struct is
        {
            typedef typename subs_rank<T,M>::template with<dummy,ranksOther...>::template is<dummyIs,subsRanks...>::type type;
        };
    };

    template<class dummy>
    struct with<dummy>
    {
        template<class dummyIs=void, int ... subsRanks>
        struct is;

        template<class dummyIs, int subsRank, int ... subsRanks>
        struct is<dummyIs,subsRank,subsRanks...>
        {
            typedef M<T,subsRank,subsRanks...> type;
        };

        template<class dummyIs>
        struct is<dummyIs>
        {
            typedef M<T,1> type;
        };
    };
};

template <typename, template<typename,int...> class, int pos, int iter, int ... ranks>
struct remove_dim;

template <typename T, template<typename,int...> class M, int pos, int iter, int rank, int ... ranks>
struct remove_dim<T,M,pos,iter,rank,ranks...>
{
    template<int ... summRanks>
    struct is;

    template<int ... summRanks>
    struct is
    {
        typedef typename sum_rank<T,M,pos,iter+1,ranks...>::template is<summRanks...,rank>::type type;
    };
};

template <typename T, template<typename,int...> class M, int pos, int rank, int ... ranks>
struct remove_dim<T,M,pos,pos,rank,ranks...>
{
    template<int ... summRanks>
    struct is;

    template<int ... summRanks>
    struct is
    {
        typedef typename sum_rank<T,M,pos,pos+1,ranks...>::template is<summRanks...>::type type;
    };
};

template <typename T, template<typename,int...> class M, int pos, int iter>
struct remove_dim<T,M,pos,iter>
{
    template<int ... summRanks>
    struct is;

    template<int summRank, int ... summRanks>
    struct is<summRank,summRanks...>
    {
        typedef M<T,summRank,summRanks...> type;
    };
};

template<int A, int B, bool>
struct is_max;

template<int A, int B>
struct is_max<A,B,true>
{
    static const int value = A;
};

template<int A, int B>
struct is_max<A,B,false>
{
    static const int value = B;
};

template <typename, template<typename,int...> class, int ... ranks>
struct get_max_of;

template <typename T, template<typename,int...> class M, int rank, int ... ranks>
struct get_max_of<T,M,rank,ranks...>
{
    template<class dummy=void, int ... ranksOther>
    struct and_of;

    template<class dummy, int rankOther, int ... ranksOther>
    struct and_of<dummy,rankOther,ranksOther...>
    {
        template<int ... summRanks>
        struct is;

        template<int ... summRanks>
        struct is
        {
            typedef typename get_max_of<T,M,ranks...>::template and_of<dummy,ranksOther...>::template is<summRanks...,is_max< rank,rankOther,(rank>rankOther) >::value >::type type;
        };
    };

    template<class dummy>
    struct and_of<dummy>
    {
        template<int ... summRanks>
        struct is;

        template<int ... summRanks>
        struct is
        {
            typedef typename get_max_of<T,M,ranks...>::template and_of<dummy>::template is<summRanks...,rank>::type type;
        };
    };
};

template <typename T, template<typename,int...> class M>
struct get_max_of<T,M>
{
    template<class dummy=void,int ... ranksOther>
    struct and_of;

    template<class dummy,int rankOther, int ... ranksOther>
    struct and_of<dummy,rankOther,ranksOther...>
    {
        template<int ... summRanks>
        struct is;

        template<int ... summRanks>
        struct is
        {
            typedef typename get_max_of<T,M>::template and_of<dummy,ranksOther...>::template is<summRanks...,rankOther>::type type;
        };
    };

    template<class dummy>
    struct and_of<dummy>
    {
        template<int ... summRanks>
        struct is;

        template<int summRank, int ... summRanks>
        struct is<summRank,summRanks...>
        {
            typedef M<T,summRank,summRanks...> type;
        };
    };
};

template<int A, int B, bool>
struct is_min;

template<int A, int B>
struct is_min<A,B,true>
{
    static const int value = A;
};

template<int A, int B>
struct is_min<A,B,false>
{
    static const int value = B;
};

template <typename, template<typename,int...> class, int ... ranks>
struct get_min_of;

template <typename T, template<typename,int...> class M, int rank, int ... ranks>
struct get_min_of<T,M,rank,ranks...>
{
    template<class dummy=void, int ... ranksOther>
    struct and_of;

    template<class dummy, int rankOther, int ... ranksOther>
    struct and_of<dummy,rankOther,ranksOther...>
    {
        template<int ... summRanks>
        struct is;

        template<int ... summRanks>
        struct is
        {
            typedef typename get_min_of<T,M,ranks...>::template and_of<dummy,ranksOther...>::template is<summRanks...,is_min< rank,rankOther,(rank>rankOther) >::value >::type type;
        };
    };

    template<class dummy>
    struct and_of<dummy>
    {
        template<int ... summRanks>
        struct is;

        template<int ... summRanks>
        struct is
        {
            typedef typename get_min_of<T,M,ranks...>::template and_of<dummy>::template is<summRanks...,rank>::type type;
        };
    };
};

template <typename T, template<typename,int...> class M>
struct get_min_of<T,M>
{
    template<class dummy=void,int ... ranksOther>
    struct and_of;

    template<class dummy,int rankOther, int ... ranksOther>
    struct and_of<dummy,rankOther,ranksOther...>
    {
        template<int ... summRanks>
        struct is;

        template<int ... summRanks>
        struct is
        {
            typedef typename get_min_of<T,M>::template and_of<dummy,ranksOther...>::template is<summRanks...,rankOther>::type type;
        };
    };

    template<class dummy>
    struct and_of<dummy>
    {
        template<int ... summRanks>
        struct is;

        template<int summRank, int ... summRanks>
        struct is<summRank,summRanks...>
        {
            typedef M<T,summRank,summRanks...> type;
        };
    };
};


template<int ... nums>
struct Prod;
template<int num, int ... nums>
struct Prod<num,nums...>
{
    static const u16 value = num*Prod<nums...>::value;
};

template<>
struct Prod<>
{
    static const u16 value = 1;
};

template<int ... nums>
struct Prod_Max;

template<int num, int ... nums>
struct Prod_Max<num,nums...>
{
    template<class dummy=void,int ... otherNums>
    struct with;

    template<class dummy, int otherNum, int ... otherNums>
    struct with<dummy,otherNum,otherNums...>
    {
        static const u16 value = is_min< num,otherNum,(num>otherNum) >::value * Prod_Max<nums...>::template with<dummy,otherNums...>::value;
    };

    template<class dummy>
    struct with<dummy>
    {
        static const u16 value = num*Prod_Max<nums...>::template with<dummy>::value;
    };
};

template<>
struct Prod_Max<>
{
    template<class dummy=void,int ... otherNums>
    struct with;

    template<class dummy, int otherNum, int ... otherNums>
    struct with<dummy,otherNum,otherNums...>
    {
        static const u16 value = otherNum*Prod_Max<>::template with<dummy,otherNums...>::value;
    };

    template<class dummy>
    struct with<dummy>
    {
        static const u16 value = 1;
    };
};

template <int N>
struct Factorial
{
    static const u16 value = N*Factorial<N-1>::value;
};

template <>
struct Factorial<1>
{
    static const u16 value = 1;
};

template <>
struct Factorial<0>
{
    static const u16 value = 1;
};

template<int N, int M>
struct NoverM
{
    static const u16 value = Factorial<N>::value/Factorial<M>::value;
};

template<typename TT>
struct promoted_type
{

    typedef TT type;
};

template<>
struct promoted_type<f32>
{
    typedef double type;
};

template<>
struct promoted_type<u32>
{
    typedef int type;
};

template<>
struct promoted_type<u16>
{
    typedef int type;
};

template<>
struct promoted_type<u8>
{
    typedef int type;
};

template<typename T, template<typename,int...> class M, int ... ranks>
struct inherit_tupla;

template<typename T, template<typename,int...> class M, int rank, int ... ranks>
struct inherit_tupla<T,M,rank,ranks...>
{
    template<int ... isRanks>
    struct is;

    template<int ... isRanks>
    struct is
    {
        typedef typename inherit_tupla<T,M,ranks...>::template is<isRanks...,rank>::type type;
    };
};


template<typename T, template<typename,int...> class M, int ... ranks>
struct inherit_tupla<T,M,0,ranks...>
{
    template<int ... isRanks>
    struct is;

    template<int ... isRanks>
    struct is
    {
        typedef M<T> type;
    };
};


template<typename T, template<typename,int...> class M>
struct inherit_tupla<T,M>
{
    template<int ... isRanks>
    struct is;

    template<int isRank, int ... isRanks>
    struct is<isRank,isRanks...>
    {
        typedef M<T,isRank,isRanks...> type;
    };
};

template<template<typename,int...> class TT, typename T, int ... ranks>
struct make_nested_type;

template<template<typename,int...> class TT, typename T, int rank, int ... ranks>
struct make_nested_type<TT,T,rank,ranks...>
{
    typedef typename make_nested_type<TT,TT<T,rank>,ranks...>::type type;
};

template<template<typename,int...> class TT, typename T>
struct make_nested_type<TT,T>
{
    typedef T type;
};


template<typename T, int count, typename resT=void>
struct create_function_signature;

template<typename T, int count, typename resT>
struct create_function_signature
{
    template<typename ... TT>
    struct is
    {
        typedef typename create_function_signature<T,count-1,resT>::template is<T,TT...>::type type;
    };
};

template<typename T, typename resT>
struct create_function_signature<T,0,resT>
{
    template<typename ... TT>
    struct is
    {
        typedef resT type(TT...);
    };
};



template <typename, template<typename,int...> class, int ... ranks>
struct prod_type;

template <typename T, template<typename,int...> class M, int rank, int ... ranks>
struct prod_type<T,M,rank,ranks...>
{
    template<class dummy=void, int ... ranksOther>
    struct with;

    template<class dummy, int rankOther, int ... ranksOther>
    struct with<dummy,rankOther,ranksOther...>
    {
        template<class dummyIs=void,int ... summRanks>
        struct is;

        template<class dummyIs,int ... summRanks>
        struct is
        {
            typedef typename prod_type<T,M,ranks...>::template with<dummy,ranksOther...>::template is<dummyIs,summRanks...,rank+rankOther>::type type;
        };
    };

    template<class dummy>
    struct with<dummy>
    {
        template<class dummyIs=void, int ... summRanks>
        struct is;

        template<class dummyIs, int ... summRanks>
        struct is
        {
            typedef typename prod_type<T,M,ranks...>::template with<dummy>::template is<dummyIs,summRanks...,rank>::type type;
        };
    };
};

template <typename T, template<typename,int...> class M>
struct prod_type<T,M>
{
    template<class dummy=void,int ... ranksOther>
    struct with;

    template<class dummy,int rankOther, int ... ranksOther>
    struct with<dummy,rankOther,ranksOther...>
    {
        template<class dummyIs, int ... summRanks>
        struct is;

        template<class dummyIs, int ... summRanks>
        struct is
        {
            typedef typename prod_type<T,M>::template with<dummy,ranksOther...>::template is<dummyIs,summRanks...,rankOther>::type type;
        };
    };

    template<class dummy>
    struct with<dummy>
    {
        template<class dummyIs=void, int ... summRanks>
        struct is;

        template<class dummyIs, int summRank, int ... summRanks>
        struct is<dummyIs,summRank,summRanks...>
        {
            typedef M<T,summRank,summRanks...> type;
        };

        template<class dummyIs>
        struct is<dummyIs>
        {
            typedef M<T,1> type;
        };
    };
};

}
}

extern yame::mpl::place_holder _arg;
extern yame::mpl::null_ptr_type null_ptr;
extern yame::mpl::none_t none;
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/smartPtr.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/IsmartPtrDeleter.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/IsmartPtrDeleter.h"
       

namespace yame
{
namespace ytl
{
class Deleter
{
public:
    virtual void releaseMemory(void* ptr) = 0;
};
}
}
# 19 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/smartPtr.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/referenceCounter.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/referenceCounter.h"
       

namespace yame
{
namespace ytl
{
struct smartPolicyDef
{
    enum type
    {
        SHARED,
        UNIQUE
    };
};

typedef safe_enum<smartPolicyDef> smartPolicyId;

template<int id>
class refCounter;

template<>
class refCounter<smartPolicyId::SHARED>
{
private:
    u32 m_numStrongReferences;
    u32 m_numWeakReferences;

public:
    refCounter() : m_numStrongReferences(0), m_numWeakReferences(0) {};

    u32 addStrongReference() { m_numStrongReferences++; return m_numStrongReferences; }
    u32 removeStrongReference()
    {
        m_numStrongReferences = (m_numStrongReferences > 0) ? m_numStrongReferences-1 : 0;
        return m_numStrongReferences;
    }
    u32 getNumStrongReferences() { return m_numStrongReferences; }

    u32 addWeakReference() { m_numWeakReferences++; return m_numWeakReferences; }
    u32 removeWeakReference()
    {
        m_numWeakReferences = (m_numWeakReferences > 0) ? m_numWeakReferences-1 : 0;
        return m_numWeakReferences;
    }
    u32 getNumWeakReferences() { return m_numWeakReferences; }
};

template<>
class refCounter<smartPolicyId::UNIQUE>
{
private:
    u32 m_numWeakReferences;

public:
    refCounter() : m_numWeakReferences(0) {};

    u32 addWeakReference() { m_numWeakReferences++; return m_numWeakReferences; }
    u32 removeWeakReference()
    {

        m_numWeakReferences = (m_numWeakReferences > 0) ? m_numWeakReferences-1 : 0;

        return m_numWeakReferences;
    }
    u32 getNumWeakReferences() { return m_numWeakReferences; }
};
}
}
# 20 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/smartPtr.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cString.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cString.h"
       




# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 21 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cString.h" 2

# 1 "/usr/include/math.h" 1 3 4
# 30 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/i386-linux-gnu/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/i386-linux-gnu/bits/huge_valf.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/i386-linux-gnu/bits/huge_vall.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/bits/inf.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/bits/nan.h" 1 3 4
# 44 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/i386-linux-gnu/bits/mathdef.h" 1 3 4
# 36 "/usr/include/i386-linux-gnu/bits/mathdef.h" 3 4
typedef long double float_t;

typedef long double double_t;
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/i386-linux-gnu/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                           ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/i386-linux-gnu/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                           ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 95 "/usr/include/math.h" 2 3 4
# 146 "/usr/include/math.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/i386-linux-gnu/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                           ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 147 "/usr/include/math.h" 2 3 4
# 162 "/usr/include/math.h" 3 4
extern int signgam;
# 203 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 296 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 319 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 483 "/usr/include/math.h" 3 4
}
# 23 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cString.h" 2

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cArray.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cArray.h"
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cSystemAllocator.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cSystemAllocator.h"
       

# 1 "/usr/include/c++/4.8/cstddef" 1 3
# 39 "/usr/include/c++/4.8/cstddef" 3
       
# 40 "/usr/include/c++/4.8/cstddef" 3


# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8/cstddef" 2 3
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cSystemAllocator.h" 2


# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cMemoryTracker.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cMemoryTracker.h"
       

# 1 "/usr/include/c++/4.8/vector" 1 3
# 58 "/usr/include/c++/4.8/vector" 3
       
# 59 "/usr/include/c++/4.8/vector" 3



# 1 "/usr/include/c++/4.8/bits/stl_construct.h" 1 3
# 61 "/usr/include/c++/4.8/bits/stl_construct.h" 3
# 1 "/usr/include/c++/4.8/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/4.8/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/4.8/ext/alloc_traits.h" 3



# 1 "/usr/include/c++/4.8/bits/alloc_traits.h" 1 3
# 36 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
# 1 "/usr/include/c++/4.8/bits/ptr_traits.h" 1 3
# 37 "/usr/include/c++/4.8/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


template<typename _Tp> class __has_element_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::element_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_element_type : integral_constant<bool, __has_element_type_helper <typename remove_cv<_Tp>::type>::value> { };
template<typename _Tp> class __has_difference_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::difference_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_difference_type : integral_constant<bool, __has_difference_type_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Tp, bool = __has_element_type<_Tp>::value>
    struct __ptrtr_elt_type;

  template<typename _Tp>
    struct __ptrtr_elt_type<_Tp, true>
    {
      typedef typename _Tp::element_type __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Tp,
            typename... _Args>
    struct __ptrtr_elt_type<_SomePtr<_Tp, _Args...>, false>
    {
      typedef _Tp __type;
    };

  template<typename _Tp, bool = __has_difference_type<_Tp>::value>
    struct __ptrtr_diff_type
    {
      typedef typename _Tp::difference_type __type;
    };

  template<typename _Tp>
    struct __ptrtr_diff_type<_Tp, false>
    {
      typedef ptrdiff_t __type;
    };

  template<typename _Ptr, typename _Up>
    class __ptrtr_rebind_helper
    {
      template<typename _Ptr2, typename _Up2>
 static constexpr bool
        _S_chk(typename _Ptr2::template rebind<_Up2>*)
        { return true; }

      template<typename, typename>
        static constexpr bool
        _S_chk(...)
        { return false; }

    public:
      static const bool __value = _S_chk<_Ptr, _Up>(nullptr);
    };

  template<typename _Ptr, typename _Up>
    const bool __ptrtr_rebind_helper<_Ptr, _Up>::__value;

  template<typename _Tp, typename _Up,
           bool = __ptrtr_rebind_helper<_Tp, _Up>::__value>
    struct __ptrtr_rebind;

  template<typename _Tp, typename _Up>
    struct __ptrtr_rebind<_Tp, _Up, true>
    {
      typedef typename _Tp::template rebind<_Up> __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Up,
            typename _Tp, typename... _Args>
    struct __ptrtr_rebind<_SomePtr<_Tp, _Args...>, _Up, false>
    {
      typedef _SomePtr<_Up, _Args...> __type;
    };

  template<typename _Tp, typename = typename remove_cv<_Tp>::type>
    struct __ptrtr_not_void
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __ptrtr_not_void<_Tp, void>
    {
      struct __type { };
    };

  template<typename _Ptr>
    class __ptrtr_pointer_to
    {
      typedef typename __ptrtr_elt_type<_Ptr>::__type __orig_type;
      typedef typename __ptrtr_not_void<__orig_type>::__type __element_type;

    public:
      static _Ptr pointer_to(__element_type& __e)
      { return _Ptr::pointer_to(__e); }
    };





  template<typename _Ptr>
    struct pointer_traits : __ptrtr_pointer_to<_Ptr>
    {

      typedef _Ptr pointer;

      typedef typename __ptrtr_elt_type<_Ptr>::__type element_type;

      typedef typename __ptrtr_diff_type<_Ptr>::__type difference_type;

      template<typename _Up>
        using rebind = typename __ptrtr_rebind<_Ptr, _Up>::__type;
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(typename __ptrtr_not_void<element_type>::__type& __r) noexcept
      { return std::addressof(__r); }
    };


}
# 37 "/usr/include/c++/4.8/bits/alloc_traits.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc, typename _Tp>
    class __alloctr_rebind_helper
    {
      template<typename _Alloc2, typename _Tp2>
 static constexpr bool
        _S_chk(typename _Alloc2::template rebind<_Tp2>::other*)
 { return true; }

      template<typename, typename>
        static constexpr bool
        _S_chk(...)
        { return false; }

    public:
      static const bool __value = _S_chk<_Alloc, _Tp>(nullptr);
    };

  template<typename _Alloc, typename _Tp>
    const bool __alloctr_rebind_helper<_Alloc, _Tp>::__value;

  template<typename _Alloc, typename _Tp,
           bool = __alloctr_rebind_helper<_Alloc, _Tp>::__value>
    struct __alloctr_rebind;

  template<typename _Alloc, typename _Tp>
    struct __alloctr_rebind<_Alloc, _Tp, true>
    {
      typedef typename _Alloc::template rebind<_Tp>::other __type;
    };

  template<template<typename, typename...> class _Alloc, typename _Tp,
            typename _Up, typename... _Args>
    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>
    {
      typedef _Alloc<_Tp, _Args...> __type;
    };





  template<typename _Alloc>
    struct allocator_traits
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;
# 100 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
private: template<typename _Tp> static typename _Tp::pointer _S_pointer_helper(_Tp*); static value_type* _S_pointer_helper(...); typedef decltype(_S_pointer_helper((_Alloc*)0)) __pointer; public:






      typedef __pointer pointer;

private: template<typename _Tp> static typename _Tp::const_pointer _S_const_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<const value_type> _S_const_pointer_helper(...); typedef decltype(_S_const_pointer_helper((_Alloc*)0)) __const_pointer; public:
# 118 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      typedef __const_pointer const_pointer;

private: template<typename _Tp> static typename _Tp::void_pointer _S_void_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<void> _S_void_pointer_helper(...); typedef decltype(_S_void_pointer_helper((_Alloc*)0)) __void_pointer; public:
# 129 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      typedef __void_pointer void_pointer;

private: template<typename _Tp> static typename _Tp::const_void_pointer _S_const_void_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<const void> _S_const_void_pointer_helper(...); typedef decltype(_S_const_void_pointer_helper((_Alloc*)0)) __const_void_pointer; public:
# 140 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      typedef __const_void_pointer const_void_pointer;

private: template<typename _Tp> static typename _Tp::difference_type _S_difference_type_helper(_Tp*); static typename pointer_traits<pointer>::difference_type _S_difference_type_helper(...); typedef decltype(_S_difference_type_helper((_Alloc*)0)) __difference_type; public:
# 151 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      typedef __difference_type difference_type;

private: template<typename _Tp> static typename _Tp::size_type _S_size_type_helper(_Tp*); static typename make_unsigned<difference_type>::type _S_size_type_helper(...); typedef decltype(_S_size_type_helper((_Alloc*)0)) __size_type; public:
# 162 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      typedef __size_type size_type;

private: template<typename _Tp> static typename _Tp::propagate_on_container_copy_assignment _S_propagate_on_container_copy_assignment_helper(_Tp*); static false_type _S_propagate_on_container_copy_assignment_helper(...); typedef decltype(_S_propagate_on_container_copy_assignment_helper((_Alloc*)0)) __propagate_on_container_copy_assignment; public:
# 173 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      typedef __propagate_on_container_copy_assignment
        propagate_on_container_copy_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_move_assignment _S_propagate_on_container_move_assignment_helper(_Tp*); static false_type _S_propagate_on_container_move_assignment_helper(...); typedef decltype(_S_propagate_on_container_move_assignment_helper((_Alloc*)0)) __propagate_on_container_move_assignment; public:
# 185 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      typedef __propagate_on_container_move_assignment
        propagate_on_container_move_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_swap _S_propagate_on_container_swap_helper(_Tp*); static false_type _S_propagate_on_container_swap_helper(...); typedef decltype(_S_propagate_on_container_swap_helper((_Alloc*)0)) __propagate_on_container_swap; public:
# 197 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      typedef __propagate_on_container_swap propagate_on_container_swap;



      template<typename _Tp>
        using rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;
      template<typename _Tp>
        using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 struct __allocate_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->allocate(
    std::declval<size_type>(),
    std::declval<const_void_pointer>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Alloc2>
 static typename
        enable_if<__allocate_helper<_Alloc2>::value, pointer>::type
        _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static typename
        enable_if<!__allocate_helper<_Alloc2>::value, pointer>::type
        _S_allocate(_Alloc2& __a, size_type __n, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Tp, typename... _Args>
 static typename
        enable_if<__construct_helper<_Tp, _Args...>::value, void>::type
        _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static typename
 enable_if<__and_<__not_<__construct_helper<_Tp, _Args...>>,
    is_constructible<_Tp, _Args...>>::value, void>::type
        _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Tp>
 struct __destroy_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->destroy(
    std::declval<_Tp*>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Tp>
 static typename enable_if<__destroy_helper<_Tp>::value, void>::type
        _S_destroy(_Alloc& __a, _Tp* __p)
 { __a.destroy(__p); }

      template<typename _Tp>
 static typename enable_if<!__destroy_helper<_Tp>::value, void>::type
        _S_destroy(_Alloc&, _Tp* __p)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 struct __maxsize_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->max_size())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc2>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Alloc2>
 static typename
        enable_if<__maxsize_helper<_Alloc2>::value, size_type>::type
        _S_max_size(_Alloc2& __a)
 { return __a.max_size(); }

      template<typename _Alloc2>
 static typename
        enable_if<!__maxsize_helper<_Alloc2>::value, size_type>::type
 _S_max_size(_Alloc2&)
 { return __gnu_cxx::__numeric_traits<size_type>::__max; }

      template<typename _Alloc2>
 struct __select_helper
 {
   template<typename _Alloc3, typename
     = decltype(std::declval<_Alloc3*>()
  ->select_on_container_copy_construction())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc2>(0)) type;
   static const bool value = type::value;
 };
      template<typename _Alloc2>
 static typename
        enable_if<__select_helper<_Alloc2>::value, _Alloc2>::type
        _S_select(_Alloc2& __a)
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static typename
        enable_if<!__select_helper<_Alloc2>::value, _Alloc2>::type
        _S_select(_Alloc2& __a)
 { return __a; }

    public:
# 349 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 364 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint); }
# 376 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      static void deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 390 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 403 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      template <class _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p); }
# 415 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a)
      { return _S_max_size(__a); }
# 426 "/usr/include/c++/4.8/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs); }
    };

  template<typename _Alloc>
  template<typename _Alloc2>
    const bool allocator_traits<_Alloc>::__allocate_helper<_Alloc2>::value;

  template<typename _Alloc>
  template<typename _Tp, typename... _Args>
    const bool
    allocator_traits<_Alloc>::__construct_helper<_Tp, _Args...>::value;

  template<typename _Alloc>
  template<typename _Tp>
    const bool allocator_traits<_Alloc>::__destroy_helper<_Tp>::value;

  template<typename _Alloc>
  template<typename _Alloc2>
    const bool allocator_traits<_Alloc>::__maxsize_helper<_Alloc2>::value;

  template<typename _Alloc>
  template<typename _Alloc2>
    const bool allocator_traits<_Alloc>::__select_helper<_Alloc2>::value;

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


  template<bool> struct __allow_copy_cons { };


  template<>
    struct __allow_copy_cons<false>
    {
      __allow_copy_cons() = default;
      __allow_copy_cons(const __allow_copy_cons&) = delete;
      __allow_copy_cons(__allow_copy_cons&&) = default;
      __allow_copy_cons& operator=(const __allow_copy_cons&) = default;
      __allow_copy_cons& operator=(__allow_copy_cons&&) = default;
    };

  template<typename _Alloc>
    using __check_copy_constructible
      = __allow_copy_cons<__is_copy_insertable<_Alloc>::value>;


}
# 37 "/usr/include/c++/4.8/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocator_always_compares_equal
    { static const bool value = false; };

  template<typename _Alloc>
    const bool __allocator_always_compares_equal<_Alloc>::value;

  template<typename _Tp>
    struct __allocator_always_compares_equal<std::allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<std::allocator<_Tp>>::value;

  template<typename, typename> struct array_allocator;

  template<typename _Tp, typename _Array>
    struct __allocator_always_compares_equal<array_allocator<_Tp, _Array>>
    { static const bool value = true; };

  template<typename _Tp, typename _Array>
    const bool
    __allocator_always_compares_equal<array_allocator<_Tp, _Array>>::value;

  template<typename> struct bitmap_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<bitmap_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<bitmap_allocator<_Tp>>::value;

  template<typename> struct malloc_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<malloc_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<malloc_allocator<_Tp>>::value;

  template<typename> struct mt_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<mt_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<mt_allocator<_Tp>>::value;

  template<typename> struct new_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<new_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<new_allocator<_Tp>>::value;

  template<typename> struct pool_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<pool_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<pool_allocator<_Tp>>::value;






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      struct __is_custom_pointer
      : std::integral_constant<bool, std::is_same<pointer, _Ptr>::value
                                     && !std::is_pointer<_Ptr>::value>
      { };

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return __allocator_always_compares_equal<_Alloc>::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    static constexpr bool _S_nothrow_swap()
    {
      using std::swap;
      return !_S_propagate_on_swap()
        || noexcept(swap(std::declval<_Alloc&>(), std::declval<_Alloc&>()));
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 237 "/usr/include/c++/4.8/ext/alloc_traits.h" 3
  };


}
# 62 "/usr/include/c++/4.8/bits/stl_construct.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 90 "/usr/include/c++/4.8/bits/stl_construct.h" 3
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 63 "/usr/include/c++/4.8/vector" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_uninitialized.h" 1 3
# 59 "/usr/include/c++/4.8/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "/usr/include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
     && __is_trivial(_ValueType2))>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 162 "/usr/include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_trivial(_ValueType)>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 216 "/usr/include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 346 "/usr/include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static void
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static void
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_1<__is_trivial(_ValueType)>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline void
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_n_1<__is_trivial(_ValueType)>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    void
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { std::__uninitialized_default_n(__first, __n); }


  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
# 645 "/usr/include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }



}
# 64 "/usr/include/c++/4.8/vector" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_vector.h" 1 3
# 66 "/usr/include/c++/4.8/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }


 _Vector_impl(_Tp_alloc_type&& __a)
 : _Tp_alloc_type(std::move(__a)),
   _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }


 void _M_swap_data(_Vector_impl& __x)
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a)
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 209 "/usr/include/c++/4.8/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 268 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 281 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 310 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 327 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 364 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 390 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 414 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 426 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 438 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          _Alloc_traits::_S_propagate_on_move_assign()
          || _Alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__x),
                       integral_constant<bool, __move_storage>());
 return *this;
      }
# 460 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 478 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 495 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 523 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 663 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 683 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 715 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 754 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 769 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 784 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 809 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 827 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 874 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      _Tp*



      data() noexcept
      { return std::__addressof(front()); }


      const _Tp*



      data() const noexcept
      { return std::__addressof(front()); }
# 900 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else

   _M_emplace_back_aux(__x);



      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 936 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 956 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
# 972 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 987 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1004 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      insert(iterator __position, initializer_list<value_type> __l)
      { this->insert(__position, __l.begin(), __l.end()); }
# 1022 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1041 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        { _M_insert_dispatch(__position, __first, __last, __false_type()); }
# 1074 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 1095 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1107 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      void
      swap(vector& __x)

   noexcept(_Alloc_traits::_S_nothrow_swap())

      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1159 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }



      void
      _M_default_initialize(size_type __n)
      {
 std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
      _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1237 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1277 "/usr/include/c++/4.8/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();







      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);

      template<typename... _Args>
        void
        _M_emplace_back_aux(_Args&&... __args);



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 const vector __tmp(std::move(*this));
 this->_M_impl._M_swap_data(__x._M_impl);
 if (_Alloc_traits::_S_propagate_on_move_assign())
   std::__alloc_on_move(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }

    };
# 1401 "/usr/include/c++/4.8/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1418 "/usr/include/c++/4.8/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 65 "/usr/include/c++/4.8/vector" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_bvector.h" 1 3
# 63 "/usr/include/c++/4.8/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage(0)
 { }

      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = 0;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(_S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 517 "/usr/include/c++/4.8/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;


    template<typename> friend class hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }


    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }
# 583 "/usr/include/c++/4.8/bits/stl_bvector.h" 3
    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }



    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
# 621 "/usr/include/c++/4.8/bits/stl_bvector.h" 3
    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x)
    {


      this->clear();
      this->swap(__x);
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
# 682 "/usr/include/c++/4.8/bits/stl_bvector.h" 3
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      { _M_insert_dispatch(__position, __first, __last, __false_type()); }
# 887 "/usr/include/c++/4.8/bits/stl_bvector.h" 3
    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }


    void insert(iterator __p, initializer_list<bool> __l)
    { this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };


}





namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "/usr/include/c++/4.8/vector" 2 3



# 1 "/usr/include/c++/4.8/bits/vector.tcc" 1 3
# 59 "/usr/include/c++/4.8/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_emplace_back_aux(std::forward<_Args>(__args)...);
      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {

   if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
     {
       _Tp __x_copy = __x;
       _M_insert_aux(__position, std::move(__x_copy));
     }
   else

     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 const size_type __n = __position - begin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
     && __position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(__position, std::forward<_Args>(__args)...);
 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)






    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              std::move(*(this->_M_impl._M_finish - 1))
                            );
   ++this->_M_impl._M_finish;



   std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;



   *__position = _Tp(std::forward<_Args>(__args)...);

 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,

           std::forward<_Args>(__args)...);



       __new_finish = 0;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_emplace_back_aux(_Args&&... __args)
      {
 const size_type __len =
   _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
 pointer __new_start(this->_M_allocate(__len));
 pointer __new_finish(__new_start);
 try
   {
     _Alloc_traits::construct(this->_M_impl, __new_start + size(),
         std::forward<_Args>(__args)...);
     __new_finish = 0;

     __new_finish
       = std::__uninitialized_move_if_noexcept_a
       (this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());

     ++__new_finish;
   }
 catch(...)
   {
     if (!__new_finish)
       _Alloc_traits::destroy(this->_M_impl, __new_start + size());
     else
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
     _M_deallocate(__new_start, __len);
     throw;
   }
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start);
 this->_M_impl._M_start = __new_start;
 this->_M_impl._M_finish = __new_finish;
 this->_M_impl._M_end_of_storage = __new_start + __len;
      }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       std::__uninitialized_default_n_a(this->_M_impl._M_finish,
            __n, _M_get_Tp_allocator());
       this->_M_impl._M_finish += __n;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __old_size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, this->_M_impl._M_finish,
       __new_start, _M_get_Tp_allocator());
    std::__uninitialized_default_n_a(__new_finish, __n,
         _M_get_Tp_allocator());
    __new_finish += __n;
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
      iterator(__q, 0));
      this->_M_deallocate();
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }



}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "/usr/include/c++/4.8/vector" 2 3
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cMemoryTracker.h" 2




namespace yame
{
namespace memory
{

class cMemoryTracker
{
public:
    cMemoryTracker();
    ~cMemoryTracker();
    void registerAllocation(void *newAlloc, size_t numUnits) const;
    void deRegisterAllocation(void *alloc) const;

private:
    struct StackTraceData
    {
        StackTraceData(void** i_stackTrace, size_t i_stackTraceSize, const std::vector<std::string>& i_extraInfo);

        void** stackTrace;
        size_t stackTraceSize;
        std::vector<std::string> extraInfo;
    };

    s32 findAllocation(void *alloc) const;

    mutable std::vector<std::pair<void *, StackTraceData>> m_registeredAllocations;
    mutable pthread_mutex_t m_registerMutex;
};

}
}
# 21 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cSystemAllocator.h" 2


namespace yame
{
namespace memory
{

template<typename>
struct cMemoryProvider;

class cSystemAllocator

: private cMemoryTracker

{
    friend struct cMemoryProvider<cSystemAllocator>;

public:
    typedef cSystemAllocator allocator;
    typedef void type;
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef ptrdiff_t difference_type;

    void* allocate(size_t numUnits, size_t unitSize) const;
    void deallocate(void *ptr) const;
    void* reallocate(void *ptr, size_t numUnits, size_t unitSize) const;

protected:
    cSystemAllocator() = default;
    cSystemAllocator(const cSystemAllocator& other) = delete;
    cSystemAllocator(cSystemAllocator&& other) = delete;
};

template<typename T>
class cTypedSystemAllocator : public cSystemAllocator
{
    friend struct cMemoryProvider<cTypedSystemAllocator<T>>;

public:
    typedef cSystemAllocator allocator;
    typedef T type;
    typedef T* pointer;
    typedef T& reference;
    typedef const T *const_pointer;
    typedef const T& const_reference;
    typedef ptrdiff_t difference_type;

    using cSystemAllocator::allocate;
    using cSystemAllocator::deallocate;
    using cSystemAllocator::reallocate;

protected:
    cTypedSystemAllocator() = default;
    cTypedSystemAllocator(const cTypedSystemAllocator<T>& other) = delete;
    cTypedSystemAllocator(cTypedSystemAllocator<T>&& other) = delete;
};

template<typename T>
struct cMemoryProvider<cTypedSystemAllocator<T>>
{
    static const cTypedSystemAllocator<T>& acquire()
    {

        static cTypedSystemAllocator<T> cSystemAllocatorSingleton{};

        return cSystemAllocatorSingleton;
    }
};

template<>
struct cMemoryProvider<cSystemAllocator>
{
    static const cSystemAllocator& acquire()
    {

        static cSystemAllocator cSystemAllocatorSingleton{};

        return cSystemAllocatorSingleton;
    }
};

}
}
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cArray.h" 2






# 1 "/usr/include/c++/4.8/cstring" 1 3
# 39 "/usr/include/c++/4.8/cstring" 3
       
# 40 "/usr/include/c++/4.8/cstring" 3
# 25 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cArray.h" 2

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterableBase.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterableBase.h"
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cFunction.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cFunction.h"
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cFunctionStorage.h" 1
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.h"
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cParameterPack.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cParameterPack.h"
       



namespace yame
{
namespace container
{
namespace detail
{

template<typename>
struct getValueType;

template<typename T>
struct getValueType<T&>
{
    typedef typename mpl::add_constness<T&>::type type;
};

template<typename T>
struct getValueType<T&&>
{
    typedef T&& type;
};

template<typename T>
struct getValueType
{
    typedef const T& type;
};

}

template<typename ... Types>
struct parameter_pack;


template<>
struct parameter_pack<>
{
    parameter_pack() = default;
    virtual ~parameter_pack() = default;
};

template<typename Type, typename ... Types>
struct parameter_pack<Type&,Types...> : parameter_pack<Types...>
{
    typedef Type& packType;

    packType m_packValue;

    parameter_pack<Type&,Types...>(Type& val, Types ...vals);
    template<typename TType, typename ... TTypes>
    parameter_pack<Type&,Types...>(const parameter_pack<TType, TTypes...>& other, typename mpl::enable_if<mpl::is_type_constructible<Type&, TType>::value>::type* = __null);
    parameter_pack<Type&,Types...>(const parameter_pack<Type&,Types...>& other);
    virtual ~parameter_pack<Type&,Types...>();
    parameter_pack<Type&,Types...>& operator=(const parameter_pack<Type&,Types...>& other) = delete;
    template<int _pos>
    typename detail::getValueType<typename mpl::nth_type_of<_pos,Type&,Types...>::type>::type getValue() const;
    template<int ... _pos>
    void setValues(typename mpl::nth_type_of<_pos,Type&,Types...>::type ... args);
    template<int _pos>
    bool setValue(typename mpl::nth_type_of<_pos,Type&,Types...>::type val);

    protected:
    typename detail::getValueType<Type&>::type _getValue() const;
};

template<typename Type, typename ... Types>
struct parameter_pack<Type&&,Types...> : parameter_pack<Types...>
{
    typedef Type&& packType;

    packType m_packValue;

    parameter_pack<Type&&,Types...>(Type&& val, Types ...vals);
    template<typename TType, typename ... TTypes>
    parameter_pack<Type&&,Types...>(const parameter_pack<TType, TTypes...>& other, typename mpl::enable_if<mpl::is_type_constructible<Type&&, TType>::value>::type* = __null);
    parameter_pack<Type&&,Types...>(const parameter_pack<Type&&,Types...>& other);
    virtual ~parameter_pack<Type&&,Types...>();
    parameter_pack<Type&&,Types...>& operator=(const parameter_pack<Type&&,Types...>& other) = delete;
    template<int _pos>
    typename detail::getValueType<typename mpl::nth_type_of<_pos,Type&&,Types...>::type>::type getValue() const;
    template<int ... _pos>
    void setValues(typename mpl::nth_type_of<_pos,Type&&,Types...>::type ... args);
    template<int _pos>
    bool setValue(typename mpl::nth_type_of<_pos,Type&&,Types...>::type val);

    protected:
    typename detail::getValueType<Type&&>::type _getValue() const;
};

template<typename Type, typename ... Types>
struct parameter_pack<Type,Types...> : parameter_pack<Types...>
{
    typedef Type packType;

    packType m_packValue;

    parameter_pack<Type,Types...>();
    parameter_pack<Type,Types...>(Type val, Types ...vals);
    template<typename TType, typename ... TTypes>
    parameter_pack<Type,Types...>(const parameter_pack<TType, TTypes...>& other, typename mpl::enable_if<mpl::is_type_constructible<Type, TType>::value>::type* = __null);
    template<typename TType, typename ... TTypes>
    parameter_pack<Type,Types...>(parameter_pack<TType, TTypes...>&& other, typename mpl::enable_if<mpl::is_type_constructible<Type, TType>::value>::type* = __null);
    parameter_pack<Type,Types...>(const parameter_pack<Type,Types...>& other);
    parameter_pack<Type,Types...>(parameter_pack<Type,Types...>&& other);
    virtual ~parameter_pack<Type,Types...>();
    parameter_pack<Type,Types...>& operator=(const parameter_pack<Type,Types...>& other);
    template<int _pos>
    typename detail::getValueType<typename mpl::nth_type_of<_pos,Type,Types...>::type>::type getValue() const;
    template<int ... _pos>
    void setValues(typename mpl::nth_type_of<_pos,Type,Types...>::type ... args);
    template<int ... _pos>
    void setValues(mpl::sequence<_pos...>, typename mpl::nth_type_of<_pos,Type,Types...>::type ... args);
    template<int _pos>
    bool setValue(typename mpl::nth_type_of<_pos,Type,Types...>::type val);

    protected:
    typename detail::getValueType<Type>::type _getValue() const;
    void _setValue(Type val);
};

template<typename ... Types>
parameter_pack<Types&&...> make_parameter_pack(Types&& ... vals)
{
    return parameter_pack<Types&&...>(mpl::forward<Types>(vals)...);
}

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cParameterPack.tpp" 1

namespace yame
{
namespace container
{


template<int, template<typename...> class, int, typename ...>
struct _get_sub_pack;

template<int targetPos, template<typename ...> class pack, int currPos, typename Type, typename ... Types>
struct _get_sub_pack<targetPos,pack,currPos,Type,Types...>
{
    typedef typename _get_sub_pack<targetPos,pack,currPos+1,Types...>::type type;
};

template<int targetPos, template<typename ...> class pack, typename Type, typename ... Types>
struct _get_sub_pack<targetPos,pack,targetPos,Type,Types...>
{
    typedef pack<Type,Types...> type;
};

template<int targetPos, template<typename ...> class pack, typename ... Types>
struct get_sub_pack
{
    static const int numTypes = mpl::get_num_types<Types...>::value;

    typedef typename _get_sub_pack<targetPos,pack,0,Types...>::type type;
};

template<typename Type, typename ... Types>
parameter_pack<Type&,Types...>::parameter_pack(Type& val, Types ...vals)
: parameter_pack<Types...>(vals...)
, m_packValue(val)
{
}
template<typename Type, typename ... Types>
template<typename TType, typename ... TTypes>
parameter_pack<Type&,Types...>::parameter_pack(const parameter_pack<TType, TTypes...>& other, typename mpl::enable_if<mpl::is_type_constructible<Type&, TType>::value>::type*)
: parameter_pack<Types...>(static_cast<const parameter_pack<TTypes...>&>(other))
, m_packValue(packType(other.m_packValue))
{
}
template<typename Type, typename ... Types>
parameter_pack<Type&,Types...>::parameter_pack(const parameter_pack<Type&,Types...>& other)
: parameter_pack<Types...>(static_cast<const parameter_pack<Types...>&>(other))
, m_packValue(packType(other.m_packValue))
{
}
template<typename Type, typename ... Types>
parameter_pack<Type&,Types...>::~parameter_pack()
{
}
template<typename Type, typename ... Types>
template<int _pos>
typename detail::getValueType<typename mpl::nth_type_of<_pos,Type&,Types...>::type>::type parameter_pack<Type&,Types...>::getValue() const
{
    typedef typename get_sub_pack<_pos,parameter_pack,Type&,Types...>::type baseType;

    return baseType::_getValue();
}
template<typename Type, typename ... Types>
template<int ... _pos>
void parameter_pack<Type&,Types...>::setValues(typename mpl::nth_type_of<_pos,Type&,Types...>::type ... args)
{
    bool temp[] = {setValue<_pos>(mpl::forward<typename mpl::nth_type_of<_pos,Type&,Types...>::type>(args))...};

    return;
}
template<typename Type, typename ... Types>
template<int _pos>
bool parameter_pack<Type&,Types...>::setValue(typename mpl::nth_type_of<_pos,Type&,Types...>::type val)
{
    typedef typename get_sub_pack<_pos,parameter_pack,Type&,Types...>::type baseType;

    baseType::_setValue(mpl::forward<typename mpl::nth_type_of<_pos,Type&,Types...>::type>(val));


    return true;
}
template<typename Type, typename ... Types>
typename detail::getValueType<Type&>::type
parameter_pack<Type&,Types...>::_getValue() const
{
    return m_packValue;
}


template<typename Type, typename ... Types>
parameter_pack<Type&&,Types...>::parameter_pack(Type&& val, Types ...vals)
: parameter_pack<Types...>(mpl::forward<Types>(vals)...)
, m_packValue(mpl::forward<Type&&>(val))
{
}
template<typename Type, typename ... Types>
template<typename TType, typename ... TTypes>
parameter_pack<Type&&,Types...>::parameter_pack(const parameter_pack<TType, TTypes...>& other, typename mpl::enable_if<mpl::is_type_constructible<Type&&, TType>::value>::type*)
: parameter_pack<Types...>(static_cast<const parameter_pack<TTypes...>&>(other))
, m_packValue(packType(mpl::forward<TType>(other.m_packValue)))
{
}
template<typename Type, typename ... Types>
parameter_pack<Type&&,Types...>::parameter_pack(const parameter_pack<Type&&,Types...>& other)
: parameter_pack<Types...>(static_cast<const parameter_pack<Types...>&>(other))
, m_packValue(packType(other.m_packValue))
{
}
template<typename Type, typename ... Types>
parameter_pack<Type&&,Types...>::~parameter_pack()
{
}
template<typename Type, typename ... Types>
template<int _pos>
typename detail::getValueType<typename mpl::nth_type_of<_pos,Type&&,Types...>::type>::type parameter_pack<Type&&,Types...>::getValue() const
{
    typedef typename get_sub_pack<_pos,parameter_pack,Type&&,Types...>::type baseType;

    return baseType::_getValue();
}
template<typename Type, typename ... Types>
template<int ... _pos>
void parameter_pack<Type&&,Types...>::setValues(typename mpl::nth_type_of<_pos,Type&&,Types...>::type ... args)
{
    bool temp[] = {setValue<_pos>(mpl::forward<typename mpl::nth_type_of<_pos,Type&&,Types...>::type>(args))...};

    return;
}
template<typename Type, typename ... Types>
template<int _pos>
bool parameter_pack<Type&&,Types...>::setValue(typename mpl::nth_type_of<_pos,Type&&,Types...>::type val)
{
    typedef typename get_sub_pack<_pos,parameter_pack,Type&&,Types...>::type baseType;

    baseType::_setValue(mpl::forward<typename mpl::nth_type_of<_pos,Type&,Types...>::type>(val));


    return true;
}
template<typename Type, typename ... Types>
typename detail::getValueType<Type&&>::type
parameter_pack<Type&&,Types...>::_getValue() const
{
    return mpl::move(m_packValue);
}



template<typename Type, typename ... Types>
parameter_pack<Type,Types...>::parameter_pack()
: parameter_pack<Types...>()
, m_packValue()
{
}
template<typename Type, typename ... Types>
parameter_pack<Type,Types...>::parameter_pack(Type val, Types ...vals)
: parameter_pack<Types...>(vals...)
, m_packValue(mpl::move(val))
{
}
template<typename Type, typename ... Types>
template<typename TType, typename ... TTypes>
parameter_pack<Type,Types...>::parameter_pack(const parameter_pack<TType, TTypes...>& other, typename mpl::enable_if<mpl::is_type_constructible<Type, TType>::value>::type*)
: parameter_pack<Types...>(static_cast<const parameter_pack<TTypes...>&>(other))
, m_packValue(Type(other.m_packValue))
{
}
template<typename Type, typename ... Types>
template<typename TType, typename ... TTypes>
parameter_pack<Type,Types...>::parameter_pack(parameter_pack<TType, TTypes...>&& other, typename mpl::enable_if<mpl::is_type_constructible<Type, TType>::value>::type*)
: parameter_pack<Types...>(static_cast<const parameter_pack<TTypes...>&>(other))
, m_packValue(mpl::move(Type(other.m_packValue)))
{
}
template<typename Type, typename ... Types>
parameter_pack<Type,Types...>::parameter_pack(const parameter_pack<Type,Types...>& other)
: parameter_pack<Types...>(static_cast<const parameter_pack<Types...>&>(other))
, m_packValue(other.m_packValue)
{
}
template<typename Type, typename ... Types>
parameter_pack<Type,Types...>::parameter_pack(parameter_pack<Type,Types...>&& other)
: parameter_pack<Types...>(static_cast<const parameter_pack<Types...>&>(other))
, m_packValue(mpl::move(other.m_packValue))
{
}
template<typename Type, typename ... Types>
parameter_pack<Type,Types...>::~parameter_pack()
{
}
template<typename Type, typename ... Types>
parameter_pack<Type,Types...>& parameter_pack<Type,Types...>::operator=(const parameter_pack<Type,Types...>& other)
{
    m_packValue = other.m_packValue;

    parameter_pack<Types...>::operator=(other);

    return *this;
}
template<typename Type, typename ... Types>
template<int _pos>
typename detail::getValueType<typename mpl::nth_type_of<_pos,Type,Types...>::type>::type parameter_pack<Type,Types...>::getValue() const
{
    typedef typename get_sub_pack<_pos,parameter_pack,Type,Types...>::type baseType;

    return baseType::_getValue();
}
template<typename Type, typename ... Types>
template<int ... _pos>
void parameter_pack<Type,Types...>::setValues(typename mpl::nth_type_of<_pos,Type,Types...>::type ... args)
{
    bool temp[] = {setValue<_pos>(mpl::forward<typename mpl::nth_type_of<_pos,Type,Types...>::type>(args))...};

    return;
}
template<typename Type, typename ... Types>
template<int ... _pos>
void parameter_pack<Type,Types...>::setValues(mpl::sequence<_pos...>, typename mpl::nth_type_of<_pos,Type,Types...>::type ... args)
{
    bool temp[] = {setValue<_pos>(mpl::forward<typename mpl::nth_type_of<_pos,Type,Types...>::type>(args)) ...};

    return;
}
template<typename Type, typename ... Types>
template<int _pos>
bool parameter_pack<Type,Types...>::setValue(typename mpl::nth_type_of<_pos,Type,Types...>::type val)
{
    typedef typename get_sub_pack<_pos,parameter_pack,Type,Types...>::type baseType;

    baseType::_setValue(mpl::forward<typename mpl::nth_type_of<_pos,Type,Types...>::type>(val));


    return true;
}
template<typename Type, typename ... Types>
typename detail::getValueType<Type>::type
parameter_pack<Type,Types...>::_getValue() const
{
    return m_packValue;
}
template<typename Type, typename ... Types>
void parameter_pack<Type,Types...>::_setValue(Type val)
{
    m_packValue = mpl::forward<Type>(val);

    return;
}

}
}
# 148 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cParameterPack.h" 2
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cParameterPackHelper.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cParameterPackHelper.h"
       




namespace yame
{
namespace mpl
{

template<int pos, typename ... Types>
struct nth_type_of<pos,container::parameter_pack<Types...>>
{
    typedef typename nth_type_of<pos,Types...>::type type;
};

template<typename>
struct get_parameter_pack_num_types;

template<typename ... Types>
struct get_parameter_pack_num_types<container::parameter_pack<Types...>>
{
    static const int value = get_num_types<Types...>::value;
};

template<typename ... Types>
struct get_sub_parameter_pack
{
static const int numTypes = get_num_types<Types...>::value;

template<typename dummy, int ... Indexs>
struct _at;

template<typename dummy>
struct _at<dummy>
{
    template<typename ... FoundTypes>
    struct is
    {
        typedef container::parameter_pack<FoundTypes...> type;
    };
};

template<typename dummy, int Index, int ... Indexs>
struct _at<dummy, Index, Indexs...>
{
    template<typename ... FoundTypes>
    struct is
    {
        typedef typename _at<dummy, Indexs...>::template is<FoundTypes..., typename nth_type_of<Index, Types...>::type>::type type;
    };
};

template<int ... Indexs>
struct at
{
    typedef typename _at<void, Indexs...>::template is<>::type type;
};

template<typename Seq>
struct at_seq;

template<int ... Indexs>
struct at_seq<sequence<Indexs...>>
{
    typedef typename _at<void, Indexs...>::template is<>::type type;
};

template<int ... Indexs>
struct not_at
{
    typedef typename create_range_rank_compl<0,numTypes,Indexs...>::type ComplIndexs;

    typedef typename at_seq<ComplIndexs>::type type;
};

template<typename Seq>
struct not_at_seq;

template<int ... Indexs>
struct not_at_seq<sequence<Indexs...>>
{
    typedef typename create_range_rank_compl<0,numTypes,Indexs...>::type ComplIndexs;

    typedef typename at_seq<ComplIndexs>::type type;
};
};

template<typename Type, template<typename,typename> class Cond>
struct remove_type_if
{
    template<bool, typename ...>
    struct _from;

    template<typename TType, typename ... TTypes>
    struct _from<true, TType, TTypes...>
    {
        typedef typename nth_type_of<0, TTypes...>::type nextType;

        template<typename ... FoundTypes>
        struct is
        {
            typedef typename _from<Cond<Type, nextType>::value, TTypes...>::template is<FoundTypes...>::type type;

            static constexpr type construct(FoundTypes ... prevArgs, TType arg, TTypes ... args)
            {
                return _from<Cond<Type, nextType>::value, TTypes...>::template is<FoundTypes...>::construct(forward<FoundTypes>(prevArgs)..., forward<TTypes>(args)...);
            }
        };
    };

    template<typename TType, typename ... TTypes>
    struct _from<false, TType, TTypes...>
    {
        typedef typename nth_type_of<0, TTypes...>::type nextType;

        template<typename ... FoundTypes>
        struct is
        {
            typedef typename _from<Cond<Type, nextType>::value, TTypes...>::template is<FoundTypes...,TType>::type type;

            static constexpr type construct(FoundTypes ... prevArgs, TType arg, TTypes ... args)
            {
                return _from<Cond<Type, nextType>::value, TTypes...>::template is<FoundTypes..., TType>::construct(forward<FoundTypes>(prevArgs)..., forward<TType>(arg), forward<TTypes>(args)...);
            }
        };
    };

    template<typename TType>
    struct _from<true, TType>
    {
        template<typename ... FoundTypes>
        struct is
        {
            typedef container::parameter_pack<FoundTypes...> type;

            static constexpr type construct(FoundTypes ... args, TType arg)
            {
                return type(forward<FoundTypes>(args)...);
            }
        };
    };

    template<typename TType>
    struct _from<false, TType>
    {
        template<typename ... FoundTypes>
        struct is
        {
            typedef container::parameter_pack<FoundTypes..., TType> type;

            static constexpr type construct(FoundTypes ... args, TType arg)
            {
                return type(forward<FoundTypes>(args)..., forward<TType>(arg));
            }
        };
    };

    template<typename TType, typename ... TTypes>
    struct from
    {
        typedef typename _from<Cond<Type, TType>::value, TType, TTypes...>::template is<>::type type;

        static constexpr type construct(TType arg, TTypes ... args)
        {
            return _from<Cond<Type, TType>::value, TType, TTypes...>::template is<>::construct(forward<TType>(arg), forward<TTypes>(args)...);
        }
    };
};

template<typename Type, template<typename,typename> class Cond>
struct get_pos_of_type
{
    template<int,bool,typename ...>
    struct _at;

    template<int currPos, typename TType, typename ... TTypes>
    struct _at<currPos, false, TType, TTypes...>
    {
        typedef typename nth_type_of<0, TTypes...>::type nextType;

        template<int ... FoundPos>
        struct is
        {
            typedef typename _at<currPos+1, Cond<Type, nextType>::value, TTypes...>::template is<FoundPos...>::type type;
        };
    };

    template<int currPos, typename TType, typename ... TTypes>
    struct _at<currPos, true, TType, TTypes...>
    {
        typedef typename nth_type_of<0, TTypes...>::type nextType;

        template<int ... FoundPos>
        struct is
        {
            typedef typename _at<currPos+1, Cond<Type, nextType>::value, TTypes...>::template is<FoundPos..., currPos>::type type;
        };
    };

    template<int currPos, typename TType>
    struct _at<currPos, false, TType>
    {
        template<int ... FoundPos>
        struct is
        {
            typedef mpl::sequence<FoundPos...> type;
        };
    };

    template<int currPos, typename TType>
    struct _at<currPos, true, TType>
    {
        template<int ... FoundPos>
        struct is
        {
            typedef mpl::sequence<FoundPos...,currPos> type;
        };
    };

    template<typename TType, typename ... TTypes>
    struct at
    {
        typedef typename _at<0, Cond<Type, TType>::value, TType, TTypes...>::template is<>::type type;
    };
};

template<typename Type, template<typename,typename> class Cond>
struct get_pos_of_not_type
{
    template<int,bool,typename ...>
    struct _at;

    template<int currPos, typename TType, typename ... TTypes>
    struct _at<currPos, false, TType, TTypes...>
    {
        typedef typename nth_type_of<0, TTypes...>::type nextType;

        template<int ... FoundPos>
        struct is
        {
            typedef typename _at<currPos+1, Cond<Type, nextType>::value, TTypes...>::template is<FoundPos..., currPos>::type type;
        };
    };

    template<int currPos, typename TType, typename ... TTypes>
    struct _at<currPos, true, TType, TTypes...>
    {
        typedef typename nth_type_of<0, TTypes...>::type nextType;

        template<int ... FoundPos>
        struct is
        {
            typedef typename _at<currPos+1, Cond<Type, nextType>::value, TTypes...>::template is<FoundPos...>::type type;
        };
    };

    template<int currPos, typename TType>
    struct _at<currPos, false, TType>
    {
        template<int ... FoundPos>
        struct is
        {
            typedef mpl::sequence<FoundPos...,currPos> type;
        };
    };

    template<int currPos, typename TType>
    struct _at<currPos, true, TType>
    {
        template<int ... FoundPos>
        struct is
        {
            typedef mpl::sequence<FoundPos...> type;
        };
    };

    template<typename TType, typename ... TTypes>
    struct at
    {
        typedef typename _at<0, Cond<Type, TType>::value, TType, TTypes...>::template is<>::type type;
    };
};

template<typename>
struct arg_sequence;

template<int ... typeIndexs>
struct arg_sequence<sequence<typeIndexs...>>
{
    template<typename ... Types>
    static constexpr container::parameter_pack<typename nth_type_of<typeIndexs, Types...>::type ...> construct_parameter_pack(Types&& ... i_args)
    {
        return container::parameter_pack<typename nth_type_of<typeIndexs, Types...>::type ...>(forward<typename nth_type_of<typeIndexs, Types...>::type>(nth_val_of<typeIndexs>(i_args...))...);
    }
};

}
}
# 19 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cFunctionTemplateHelper.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/mpl/cFunctionTemplateHelper.h"
       



namespace yame
{

namespace ytl
{

template<typename ...>
struct function;

}

namespace mpl
{

template<typename ...>
struct is_local_invariant;

template<>
struct is_local_invariant<>
{
    static const bool value = true;
};

template<typename T>
struct is_local_invariant<T>
{
    static const bool value = is_trivially_copiable<T>::value;
};

template<typename T, typename ... TT>
struct is_local_invariant<T,TT...>
{
    static const bool value = is_trivially_copiable<T>::value && is_local_invariant<TT...>::value;
};

template<typename>
struct is_function;

template<typename>
struct is_function
{
    static const bool value = false;
};

template<typename Return,typename ... Types>
struct is_function<ytl::function<Return(Types...)>>
{
    static const bool value = true;
};

template<template <typename...> class M, typename Type, int Dimension>
struct _homogeneous_callable;

template<template <typename...> class M, typename Type>
struct _homogeneous_callable<M,Type,0>
{
typedef M<Type()> type;
};

template<template <typename...> class M, typename Type, int Dimension>
struct _homogeneous_callable
{

template<typename TType, typename ... TTypes>
static M<TType(TTypes...,typename add_reference<typename add_constness<Type>::type>::type)> addType(const M<TType(TTypes...)>&);

typedef decltype(addType(*reinterpret_cast<const typename _homogeneous_callable<M,Type,Dimension-1>::type*>(0))) type;
};

template<template <typename...> class M, typename Type, int Dimension>
struct homogeneous_callable
{
    typedef typename _homogeneous_callable<M,Type,Dimension>::type type;
};


template<typename T>
struct curry_function;

template<template<typename...> class M, typename Return, typename ... Types>
struct curry_function<M<Return(Types...)>>
{
private:
    template<typename ...>
    struct is;

    template<typename ... TTypes>
    struct is
    {
        typedef M<Return(TTypes...)> type;
    };

    template<typename TType, typename ... TTypes>
    struct is<TType,TTypes...>
    {
        typedef M<typename is<TTypes...>::type(TType)> type;
    };

public:
    typedef typename is<Types...>::type type;
};

template<typename>
struct function_signature;

template<typename Return,typename ... Types>
struct function_signature<ytl::function<Return(Types...)>>
{
public:
    typedef Return (ytl::function<Return(Types...)>::*callable)(Types...) const;
    typedef Return callable_return_type;
    typedef ytl::function<Return(Types...)>callable_class;
    typedef container::parameter_pack<Types...> callable_args_pack;
};

template<typename T>
struct function_signature
{
private:
    typedef function_signature<decltype(&T::operator())> nested_traits;
public:
    typedef typename nested_traits::callable callable;
    typedef typename nested_traits::callable_return_type callable_return_type;
    typedef typename nested_traits::callable_class callable_class;
    typedef typename nested_traits::callable_args_pack callable_args_pack;
};

template<typename CallableReturn, typename CallableClass, typename ... CallableTypes>
struct function_signature<CallableReturn (CallableClass::*)(CallableTypes...) const>
{
    typedef CallableReturn (CallableClass::*callable)(CallableTypes...) const;
    typedef CallableReturn callable_return_type;
    typedef CallableClass callable_class;
    typedef container::parameter_pack<CallableTypes...> callable_args_pack;
};

template<typename Return,typename ... Types>
struct function_types_resolver
{
template<int,typename ...>
struct _is_specialization;

template<typename ... TTypes>
struct _is_specialization<mpl::get_num_types<Types...>::value,TTypes...>
{
    static const bool value = true;
};

template<int Pos,typename ... TTypes>
struct _is_specialization
{
    static const bool value = (mpl::is_type_constructible<typename mpl::nth_type_of<Pos,Types...>::type,typename mpl::nth_type_of<Pos,TTypes...>::type>::value || mpl::is_type_constructible<mpl::place_holder,typename mpl::nth_type_of<Pos,TTypes...>::type>::value) && _is_specialization<Pos+1,TTypes...>::value;
};

template<typename ... TTypes>
struct is_specialization
{
    static_assert(mpl::get_num_types<TTypes...>::value == mpl::get_num_types<Types...>::value, "Mismatch between construct args and types");

    static const bool value = _is_specialization<0,TTypes...>::value;
};

};

}
}
# 20 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.h" 2

namespace yame
{
namespace ytl
{
namespace detail
{

template<typename Return, typename ... Types>
struct function_impl_base;

template<typename Return, typename ... Types>
struct function_impl_base<Return, container::parameter_pack<Types...>>
{
    typedef function_impl_base<Return, container::parameter_pack<Types...>>* FuncPtr;
    static const size_t bitMask = (1 << (sizeof(FuncPtr) << 3)) - 2;

 template<typename,typename,typename>
 struct specialized_impl;

 template<int ... specIndexs, int ... notSpecIndexs, int ... totalIndexs>
 struct specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>> : function_impl_base<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<specIndexs...>::type>
 {
        typedef typename function_impl_base<Return,container::parameter_pack<Types...>>::FuncPtr FuncPtr;
        static const size_t bitMask = function_impl_base<Return,container::parameter_pack<Types...>>::bitMask;

        specialized_impl() = default;
        template<typename ... Args>
  specialized_impl(FuncPtr i_object, Args&& ... i_args);
  specialized_impl(FuncPtr i_object, const typename mpl::get_sub_parameter_pack<Types...>::template at<specIndexs...>::type& i_specArgs);
  specialized_impl(FuncPtr i_object, typename mpl::get_sub_parameter_pack<Types...>::template at<specIndexs...>::type&& i_specArgs);
        ~specialized_impl();

  Return operator()(typename mpl::nth_type_of<notSpecIndexs, Types...>::type ... args) override;
        function_impl_base<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<specIndexs...>::type>* clone(void* i_arena, size_t i_arenaSize) const override;
        function_impl_base<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<specIndexs...>::type>* _clone(void* i_arena, size_t i_arenaSize) const override;

    private:
  typename mpl::get_sub_parameter_pack<Types...>::template at<specIndexs...>::type m_specArgs;
  FuncPtr m_object;
 };

 function_impl_base() = default;
 virtual ~function_impl_base() = default;

 template<typename ... Args>
 function_impl_base<Return, typename mpl::get_sub_parameter_pack<Types...>::template at_seq<typename mpl::get_pos_of_type<mpl::place_holder, mpl::is_type_constructible>::template at<Args...>::type>::type>* specialize(void* i_arena, size_t i_arenaSize, Args&& ... args);
 template<int ... ArgIndexs, typename ... Args>
 function_impl_base<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<ArgIndexs...>::type>* specializeAt(void* i_arena, size_t i_arenaSize, Args&& ... args);

 virtual Return operator()(Types ... args) = 0;
 virtual function_impl_base<Return, container::parameter_pack<Types...>>* clone(void* i_arena, size_t i_arenaSize) const = 0;
 virtual function_impl_base<Return, container::parameter_pack<Types...>>* _clone(void* i_arena, size_t i_arenaSize) const = 0;
};


template<typename ObjectType, typename Return, typename ... Types>
class relative_function_impl : public function_impl_base<Return, container::parameter_pack<Types...>>
{
    typedef Return(ObjectType::*FuncPointerType)(Types...);
    using function_impl_base<Return, container::parameter_pack<Types...>>::bitMask;

public:
 relative_function_impl(ObjectType* i_object, FuncPointerType i_funcPointer);

 Return operator()(Types ... args) override;
 function_impl_base<Return, container::parameter_pack<Types...>>* clone(void* i_arena, size_t i_arenaSize) const override;
 function_impl_base<Return, container::parameter_pack<Types...>>* _clone(void* i_arena, size_t i_arenaSize) const override;

protected:
 ObjectType* m_object;
    FuncPointerType m_funcPointer;
};


template<typename Return, typename ... Types>
class free_function_impl : public function_impl_base<Return, container::parameter_pack<Types...>>
{
    typedef Return(*FuncPointerType)(Types...);

public:
 free_function_impl(FuncPointerType i_funcPointer);

 Return operator()(Types ... args) override;
 function_impl_base<Return, container::parameter_pack<Types...>>* clone(void* i_arena, size_t i_arenaSize) const override;
 function_impl_base<Return, container::parameter_pack<Types...>>* _clone(void* i_arena, size_t i_arenaSize) const override;
    FuncPointerType getFuncAddr() const;

protected:
    FuncPointerType m_funcPointer;
};


template<typename T, typename Return, typename ... Types>
class functor_impl : public function_impl_base<Return, container::parameter_pack<Types...>>
{
public:
 functor_impl(const T& i_functor);

 Return operator()(Types ... args) override;
 function_impl_base<Return, container::parameter_pack<Types...>>* clone(void* i_arena, size_t i_arenaSize) const override;
 function_impl_base<Return, container::parameter_pack<Types...>>* _clone(void* i_arena, size_t i_arenaSize) const override;
    const T& getCallable() const;

protected:
    T m_functor;
};

}
}

namespace mpl
{

template<typename Return,typename ... Types, int ... specIndexs, int ... notSpecIndexs, int ... totalIndexs>
struct is_local_invariant<ytl::detail::function_impl_base<Return, container::parameter_pack<Types...>>::specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>>>
{
    static const bool value = is_local_invariant<typename mpl::nth_type_of<specIndexs,Types...>::type ...>::value;
};

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp" 1

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/cException.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/cException.h"
       

# 1 "/usr/include/errno.h" 1 3 4
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/cException.h" 2

# 1 "/usr/include/execinfo.h" 1 3 4
# 24 "/usr/include/execinfo.h" 3 4
extern "C" {



extern int backtrace (void **__array, int __size) __attribute__ ((__nonnull__ (1)));




extern char **backtrace_symbols (void *__const *__array, int __size)
     throw () __attribute__ ((__nonnull__ (1)));




extern void backtrace_symbols_fd (void *__const *__array, int __size, int __fd)
     throw () __attribute__ ((__nonnull__ (1)));

}
# 20 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/cException.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 68 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 21 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/cException.h" 2







enum E_ERROR_CODE
{
    EEC_NONE,
    EEC_DIVZERO,
    EEC_NULLPOINTER,
    EEC_FILENOEXISTS,
    EEC_COLLISION,
    EEC_NO_MEM_AVAIL,
    EEC_INVALID_INPUT,
    EEC_COUNT
};

static const c8 *errStr[EEC_COUNT]
=
{"None error",
"Division by zero",
"Null pointer",
"File does not exist",
"Error in collision detection",
"The block requested does not fit the current pool"
"The input is not allowed for this operation"
};

namespace yame
{
namespace info
{
class cException : public std::exception
{
private:
    E_ERROR_CODE m_error;
public:
    cException(E_ERROR_CODE code)
    {
        m_error = code;
    }
    E_ERROR_CODE getErrorcCode() const throw()
    {
        return m_error;
    }
    const c8 *getErrorStr() const throw()
    {
        return errStr[m_error];
    }
    c8 **getStackTrace(int fileDesc)
    {
        void *array[10];
        size_t size;
        c8 **str;

        size = backtrace(array, 10);

        str = backtrace_symbols(array,size);

        return str;
    }
};
}
}
# 3 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp" 2




namespace yame
{
namespace ytl
{
namespace detail
{

template<typename Return, typename ... Types>
template<int ... specIndexs, int ... notSpecIndexs, int ... totalIndexs>
template<typename ... Args>
function_impl_base<Return, container::parameter_pack<Types...>>::specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>>::specialized_impl(function_impl_base<Return, container::parameter_pack<Types...>>* i_object, Args&& ... i_args)
: m_object(i_object)
, m_specArgs(mpl::forward<typename mpl::nth_type_of<specIndexs,Args...>::type>(mpl::nth_val_of<specIndexs>(i_args...)) ...)
{}
template<typename Return, typename ... Types>
template<int ... specIndexs, int ... notSpecIndexs, int ... totalIndexs>
function_impl_base<Return, container::parameter_pack<Types...>>::specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>>::specialized_impl(function_impl_base<Return, container::parameter_pack<Types...>>* i_object, const typename mpl::get_sub_parameter_pack<Types...>::template at<specIndexs...>::type& i_specArgs)
: m_object(i_object)
, m_specArgs(i_specArgs)
{}
template<typename Return, typename ... Types>
template<int ... specIndexs, int ... notSpecIndexs, int ... totalIndexs>
function_impl_base<Return, container::parameter_pack<Types...>>::specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>>::specialized_impl(function_impl_base<Return, container::parameter_pack<Types...>>* i_object, typename mpl::get_sub_parameter_pack<Types...>::template at<specIndexs...>::type&& i_specArgs)
: m_object(i_object)
, m_specArgs(mpl::move(i_specArgs))
{}
template<typename Return, typename ... Types>
template<int ... specIndexs, int ... notSpecIndexs, int ... totalIndexs>
function_impl_base<Return, container::parameter_pack<Types...>>::specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>>::~specialized_impl()
{
    if(m_object)
    {
        if((reinterpret_cast<size_t>(m_object) & 0x01))
        {
            delete reinterpret_cast<decltype(m_object)>(reinterpret_cast<size_t>(m_object) & bitMask);
        }
        else
        {
            typedef typename mpl::drop_pointer<FuncPtr>::type FuncType;

            m_object->~FuncType();
        }
    }
}
template<typename Return, typename ... Types>
template<int ... specIndexs, int ... notSpecIndexs, int ... totalIndexs>
Return function_impl_base<Return, container::parameter_pack<Types...>>::specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>>::operator()(typename mpl::nth_type_of<notSpecIndexs, Types...>::type ... args)
{
    typedef typename mpl::sequence<notSpecIndexs...> compl_ranks;
    typedef typename mpl::sequence<specIndexs...>::template add<compl_ranks>::type merged_rank;

    return reinterpret_cast<decltype(m_object)>(reinterpret_cast<size_t>(m_object) & bitMask)->operator()(mpl::nth_val_of<merged_rank::template get_relative_num<totalIndexs>::value>(m_specArgs.template getValue<mpl::sequence<specIndexs...>::template get_relative_num<specIndexs>::value>() ..., mpl::forward<typename mpl::nth_type_of<notSpecIndexs, Types...>::type>(args) ...)...);
}
template<typename Return, typename ... Types>
template<int ... specIndexs, int ... notSpecIndexs, int ... totalIndexs>
function_impl_base<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<specIndexs...>::type>* function_impl_base<Return, container::parameter_pack<Types...>>::specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>>::_clone(void* i_arena, size_t i_arenaSize) const
{
    typedef specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>> retType;
    static const size_t classSize = sizeof(retType);
    static const bool localInvariance = mpl::is_local_invariant<typename mpl::nth_type_of<specIndexs,Types...>::type ...>::value;

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 68, __PRETTY_FUNCTION__));

    if(localInvariance && classSize <= i_arenaSize)
    {
        return new (i_arena) retType(reinterpret_cast<decltype(m_object)>(reinterpret_cast<size_t>(m_object) & bitMask)->_clone((u8*) i_arena + classSize, i_arenaSize - classSize), m_specArgs);
    }
    else
    {
        return reinterpret_cast<retType*>(reinterpret_cast<size_t>(new retType(reinterpret_cast<decltype(m_object)>(reinterpret_cast<size_t>(m_object) & bitMask)->_clone(i_arena, 0), m_specArgs)) | 0x01);
    }
}
template<typename Return, typename ... Types>
template<int ... specIndexs, int ... notSpecIndexs, int ... totalIndexs>
function_impl_base<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<specIndexs...>::type>* function_impl_base<Return, container::parameter_pack<Types...>>::specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>>::clone(void* i_arena, size_t i_arenaSize) const
{
    typedef specialized_impl<mpl::sequence<specIndexs...>,mpl::sequence<notSpecIndexs...>,mpl::sequence<totalIndexs...>> retType;
    static const size_t classSize = sizeof(retType);
    static const bool localInvariance = mpl::is_local_invariant<typename mpl::nth_type_of<specIndexs,Types...>::type ...>::value;

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 87, __PRETTY_FUNCTION__));

    if(localInvariance && classSize <= i_arenaSize)
    {
        new (i_arena) retType(reinterpret_cast<decltype(m_object)>(reinterpret_cast<size_t>(m_object) & bitMask)->_clone((u8*) i_arena + classSize, i_arenaSize - classSize), m_specArgs);

        return __null;
    }
    else
    {
        return new retType(reinterpret_cast<decltype(m_object)>(reinterpret_cast<size_t>(m_object) & bitMask)->_clone(i_arena, 0), m_specArgs);
    }
}


template<typename Return, typename ... Types>
template<typename ... Args>
function_impl_base<Return, typename mpl::get_sub_parameter_pack<Types...>::template at_seq<typename mpl::get_pos_of_type<mpl::place_holder, mpl::is_type_constructible>::template at<Args...>::type>::type>* function_impl_base<Return, container::parameter_pack<Types...>>::specialize(void* i_arena, size_t i_arenaSize, Args&& ... args)
{
    static const int numRanks = mpl::get_num_types<Types...>::value;
    typedef specialized_impl<typename mpl::get_pos_of_not_type<mpl::place_holder, mpl::is_type_constructible>::template at<Args&&...>::type,typename mpl::get_pos_of_type<mpl::place_holder, mpl::is_type_constructible>::template at<Args&&...>::type, typename mpl::create_range_rank<0,numRanks>::type> retType;
    static const size_t classSize = sizeof(retType);
    static const bool localInvariance = mpl::is_local_invariant<retType>::value;

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 111, __PRETTY_FUNCTION__));

    if(localInvariance && classSize <= i_arenaSize)
    {
        new (i_arena) retType(_clone((u8*) i_arena + classSize, i_arenaSize - classSize), mpl::forward<Args>(args)...);

        return __null;
    }
    else
    {
        return new retType(_clone(i_arena, 0), mpl::forward<Args>(args)...);
    }
}
template<typename Return, typename ... Types>
template<int ... ArgIndexs, typename ... Args>
function_impl_base<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<ArgIndexs...>::type>* function_impl_base<Return, container::parameter_pack<Types...>>::specializeAt(void* i_arena, size_t i_arenaSize, Args&& ... args)
{
    static const int numRanks = mpl::get_num_types<Types...>::value;
    typedef specialized_impl<mpl::sequence<ArgIndexs...>,typename mpl::create_range_rank_compl<0,numRanks,ArgIndexs...>::type,typename mpl::create_range_rank<0,numRanks>::type> retType;
    static const size_t classSize = sizeof(retType);
    static const bool localInvariance = mpl::is_local_invariant<retType>::value;

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 133, __PRETTY_FUNCTION__));

    if(localInvariance && classSize <= i_arenaSize)
    {
        new (i_arena) retType(_clone((u8*) i_arena + classSize, i_arenaSize - classSize), mpl::forward<Args>(args)...);

        return __null;
    }
    else
    {
        return new retType(_clone(i_arena, 0), mpl::forward<Args>(args)...);
    }
}


template<typename ObjectType, typename Return, typename ... Types>
relative_function_impl<ObjectType,Return,Types...>::relative_function_impl(ObjectType* i_object, FuncPointerType i_funcPointer)
: m_object(i_object)
, m_funcPointer(i_funcPointer)
{}
template<typename ObjectType, typename Return, typename ... Types>
Return relative_function_impl<ObjectType,Return,Types...>::operator()(Types ... args)
{
    return (m_object->*m_funcPointer)(mpl::forward<Types>(args)...);
}
template<typename ObjectType, typename Return, typename ... Types>
function_impl_base<Return, container::parameter_pack<Types...>>* relative_function_impl<ObjectType,Return,Types...>::clone(void* i_arena, size_t i_arenaSize) const
{
    static const size_t classSize = sizeof(relative_function_impl<ObjectType,Return,Types...>);

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 163, __PRETTY_FUNCTION__));

    if(classSize <= i_arenaSize)
    {
        new (i_arena) relative_function_impl<ObjectType,Return,Types...>(m_object, m_funcPointer);

        return __null;
    }
    else
    {
        return new relative_function_impl<ObjectType,Return,Types...>(m_object, m_funcPointer);
    }
}
template<typename ObjectType, typename Return, typename ... Types>
function_impl_base<Return, container::parameter_pack<Types...>>* relative_function_impl<ObjectType,Return,Types...>::_clone(void* i_arena, size_t i_arenaSize) const
{
    static const size_t classSize = sizeof(relative_function_impl<ObjectType,Return,Types...>);

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 181, __PRETTY_FUNCTION__));

    if(classSize <= i_arenaSize)
    {
        return new (i_arena) relative_function_impl<ObjectType,Return,Types...>(m_object, m_funcPointer);
    }
    else
    {
        typedef relative_function_impl<ObjectType,Return,Types...> retType;

        return reinterpret_cast<retType*>(reinterpret_cast<size_t>(new retType(m_object, m_funcPointer)) | 0x01);
    }
}


template<typename Return, typename ... Types>
free_function_impl<Return,Types...>::free_function_impl(FuncPointerType i_funcPointer)
: m_funcPointer(i_funcPointer)
{}
template<typename Return, typename ... Types>
Return free_function_impl<Return,Types...>::operator()(Types ... args)
{
    return (*m_funcPointer)(mpl::forward<Types>(args)...);
}
template<typename Return, typename ... Types>
function_impl_base<Return, container::parameter_pack<Types...>>* free_function_impl<Return,Types...>::clone(void* i_arena, size_t i_arenaSize) const
{
    static const size_t classSize = sizeof(free_function_impl<Return,Types...>);

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 210, __PRETTY_FUNCTION__));

    if(classSize <= i_arenaSize)
    {
        new (i_arena) free_function_impl<Return,Types...>(m_funcPointer);

        return __null;
    }
    else
    {
        return new free_function_impl<Return,Types...>(m_funcPointer);
    }
}
template<typename Return, typename ... Types>
function_impl_base<Return, container::parameter_pack<Types...>>* free_function_impl<Return,Types...>::_clone(void* i_arena, size_t i_arenaSize) const
{
    static const size_t classSize = sizeof(free_function_impl<Return,Types...>);

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 228, __PRETTY_FUNCTION__));

    if(classSize <= i_arenaSize)
    {
        return new (i_arena) free_function_impl<Return,Types...>(m_funcPointer);
    }
    else
    {
        typedef free_function_impl<Return,Types...> retType;

        return reinterpret_cast<retType*>(reinterpret_cast<size_t>(new retType(m_funcPointer)) | 0x01);
    }
}
template<typename Return, typename ... Types>
typename free_function_impl<Return,Types...>::FuncPointerType free_function_impl<Return,Types...>::getFuncAddr() const
{
    return m_funcPointer;
}


template<typename T, typename Return, typename ... Types>
functor_impl<T,Return,Types...>::functor_impl(const T& i_functor)
: m_functor(i_functor)
{
}
template<typename T, typename Return, typename ... Types>
Return functor_impl<T,Return,Types...>::operator()(Types ... args)
{
    return (m_functor)(mpl::forward<Types>(args)...);
}
template<typename T, typename Return, typename ... Types>
function_impl_base<Return, container::parameter_pack<Types...>>* functor_impl<T,Return,Types...>::clone(void* i_arena, size_t i_arenaSize) const
{
    static const size_t classSize = sizeof(functor_impl<T,Return,Types...>);
    static const bool localInvariance = mpl::is_local_invariant<T>::value;

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 264, __PRETTY_FUNCTION__));

    if(localInvariance && classSize <= i_arenaSize)
    {
        new (i_arena) functor_impl<T,Return,Types...>(m_functor);

        return __null;
    }
    else
    {
        return new functor_impl<T,Return,Types...>(m_functor);
    }
}
template<typename T, typename Return, typename ... Types>
function_impl_base<Return, container::parameter_pack<Types...>>* functor_impl<T,Return,Types...>::_clone(void* i_arena, size_t i_arenaSize) const
{
    static const size_t classSize = sizeof(functor_impl<T,Return,Types...>);
    static const bool localInvariance = mpl::is_local_invariant<T>::value;

    ((i_arena != __null || i_arenaSize == 0 && "Unconsitent arena provided") ? static_cast<void> (0) : __assert_fail ("i_arena != __null || i_arenaSize == 0 && \"Unconsitent arena provided\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.tpp", 283, __PRETTY_FUNCTION__));

    if(localInvariance && classSize <= i_arenaSize)
    {
        return new (i_arena) functor_impl<T,Return,Types...>(m_functor);
    }
    else
    {
        typedef functor_impl<T,Return,Types...> retType;

        return reinterpret_cast<retType*>(reinterpret_cast<size_t>(new retType(m_functor)) | 0x01);
    }
}
template<typename T, typename Return, typename ... Types>
const T& functor_impl<T,Return, Types...>::getCallable() const
{
    return m_functor;
}

}
}
}
# 143 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionImpl.h" 2
# 4 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cFunctionStorage.h" 2

namespace yame
{
namespace ytl
{
namespace detail
{

template<int, typename ...>
struct function_storage;

template<int Size, typename Return, typename ... Types>
struct function_storage<Size,Return(Types...)>
{
    static_assert((Size%4)==0, "You shall provide a multiple of 4 for storage size");

public:
    typedef function_impl_base<Return,container::parameter_pack<Types...>>* FuncPtr;
    typedef const function_impl_base<Return,container::parameter_pack<Types...>>& constFuncRef;

    function_storage();
    function_storage(const function_storage&);
    function_storage(function_storage&&);
    function_storage(const FuncPtr& i_ptr);
    function_storage<Size,Return(Types...)>& operator=(const function_storage<Size,Return(Types...)>& other);
    function_storage<Size,Return(Types...)>& operator=(function_storage<Size,Return(Types...)>&& other);
    function_storage<Size,Return(Types...)>& operator=(const FuncPtr& i_ptr);
    template<typename Functor, typename ... Args>
    inline FuncPtr construct(Args&& ... i_args);
    inline void destroy();
    inline FuncPtr clone(constFuncRef i_func);
    inline FuncPtr getFuncPtr() const;
    inline bool empty() const;
    inline void* getArena();
    inline const void* getArena() const;
    static inline size_t getArenaSize();

private:
    static const unsigned char zeroBlock[sizeof(FuncPtr)];
    static const size_t bitMask = (1 << (sizeof(FuncPtr) << 3)) - 2;
    typedef typename std::aligned_storage<Size>::type arena_type;
    arena_type m_embeddedStorage;
};


}
}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionStorage.tpp" 1



namespace yame
{
namespace ytl
{
namespace detail
{

template<int Size, typename Return, typename ... Types>
const unsigned char function_storage<Size,Return(Types...)>::zeroBlock[sizeof(FuncPtr)] = {0};

template<int Size, typename Return, typename ... Types>
function_storage<Size,Return(Types...)>::function_storage()
{
    memset(&m_embeddedStorage, 0, Size);
}
template<int Size, typename Return, typename ... Types>
function_storage<Size,Return(Types...)>::function_storage(const function_storage& other)
{
    memset(&m_embeddedStorage, 0, Size);

    if(other.empty() == false)
    {
        clone(*other.getFuncPtr());
    }
}
template<int Size, typename Return, typename ... Types>
function_storage<Size,Return(Types...)>::function_storage(function_storage&& other)
{
    memset(&m_embeddedStorage, 0, Size);

    if(other.empty() == false)
    {
        memcpy(&m_embeddedStorage, &other.m_embeddedStorage, Size);

        memset(&other.m_embeddedStorage, 0, Size);
    }
}
template<int Size, typename Return, typename ... Types>
function_storage<Size,Return(Types...)>::function_storage(const FuncPtr& i_ptr)
{
    static size_t _funcPtr = 0;

    _funcPtr = size_t(i_ptr) | 0x01;

    memcpy(&m_embeddedStorage, &_funcPtr, sizeof(FuncPtr));
}
template<int Size, typename Return, typename ... Types>
function_storage<Size,Return(Types...)>& function_storage<Size,Return(Types...)>::operator=(const function_storage<Size,Return(Types...)>& other)
{
    destroy();

    if(other.empty() == false)
    {
        clone(*other.getFuncPtr());
    }

    return *this;
}
template<int Size, typename Return, typename ... Types>
function_storage<Size,Return(Types...)>& function_storage<Size,Return(Types...)>::operator=(function_storage<Size,Return(Types...)>&& other)
{
    destroy();

    if(other.empty() == false)
    {
        memcpy(&m_embeddedStorage, &other.m_embeddedStorage, Size);

        memset(&other.m_embeddedStorage, 0, Size);
    }

    return *this;
}
template<int Size, typename Return, typename ... Types>
function_storage<Size,Return(Types...)>& function_storage<Size,Return(Types...)>::operator=(const FuncPtr& i_ptr)
{
    static size_t _funcPtr = 0;

    destroy();

    _funcPtr = size_t(i_ptr) | 0x01;

    memcpy(&m_embeddedStorage, &_funcPtr, sizeof(FuncPtr));

    return *this;
}
template<int Size, typename Return, typename ... Types>
template<typename Functor, typename ... Args>
typename function_storage<Size,Return(Types...)>::FuncPtr function_storage<Size,Return(Types...)>::construct(Args&& ... i_args)
{
    static const size_t classSize = sizeof(Functor);
    static const bool localInvariance = mpl::is_local_invariant<Functor>::value;

    if(localInvariance && classSize <= Size)
    {
        return new (&m_embeddedStorage) Functor(mpl::forward<Args>(i_args)...);
    }
    else
    {
        FuncPtr functionCall = new Functor(mpl::forward<Args>(i_args)...);

        memcpy(&m_embeddedStorage, &functionCall, sizeof(FuncPtr));

        *reinterpret_cast<unsigned char*>(&m_embeddedStorage) |= 0x01;

        return functionCall;
    }
}
template<int Size, typename Return, typename ... Types>
void function_storage<Size,Return(Types...)>::destroy()
{
    if(memcmp(&m_embeddedStorage, zeroBlock, sizeof(FuncPtr)) != 0)
    {
        if(*reinterpret_cast<const u8*>(&m_embeddedStorage) & 0x01)
        {
            static size_t _funcPtr = 0;

            memcpy(&_funcPtr, &m_embeddedStorage, sizeof(FuncPtr));

            delete FuncPtr(_funcPtr & bitMask);
        }
        else
        {
            typedef typename mpl::drop_pointer<FuncPtr>::type FuncType;
            FuncPtr _funcPtr = reinterpret_cast<FuncPtr>(&m_embeddedStorage);

            _funcPtr->~FuncType();
        }

        memset(&m_embeddedStorage, 0, Size);
    }
}
template<int Size, typename Return, typename ... Types>
typename function_storage<Size,Return(Types...)>::FuncPtr function_storage<Size,Return(Types...)>::clone(constFuncRef i_func)
{
    FuncPtr _funcPtr = i_func.clone(&m_embeddedStorage, Size);

    if(_funcPtr != __null)
    {
        static size_t flaggedPtr = 0;

        flaggedPtr = size_t(_funcPtr) | 0x01;

        memcpy(&m_embeddedStorage, &flaggedPtr, sizeof(FuncPtr));
    }

    return _funcPtr;
}
template<int Size, typename Return, typename ... Types>
typename function_storage<Size,Return(Types...)>::FuncPtr function_storage<Size,Return(Types...)>::getFuncPtr() const
{
    ((empty() == false && "Derreferencing null function") ? static_cast<void> (0) : __assert_fail ("empty() == false && \"Derreferencing null function\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunctionStorage.tpp", 154, __PRETTY_FUNCTION__));

    return (*reinterpret_cast<const int*>(&m_embeddedStorage) & 0x01) ? FuncPtr(*reinterpret_cast<const int*>(&m_embeddedStorage) & bitMask) : FuncPtr(reinterpret_cast<const int*>(&m_embeddedStorage));
}
template<int Size, typename Return, typename ... Types>
bool function_storage<Size,Return(Types...)>::empty() const
{
    return memcmp(&m_embeddedStorage, zeroBlock, sizeof(FuncPtr)) == 0;
}
template<int Size, typename Return, typename ... Types>
void* function_storage<Size,Return(Types...)>::getArena()
{
    return static_cast<void*>(&m_embeddedStorage);
}
template<int Size, typename Return, typename ... Types>
const void* function_storage<Size,Return(Types...)>::getArena() const
{
    return static_cast<const void*>(&m_embeddedStorage);
}
template<int Size, typename Return, typename ... Types>
size_t function_storage<Size,Return(Types...)>::getArenaSize()
{
    return Size;
}

}
}
}
# 53 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cFunctionStorage.h" 2
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cFunction.h" 2


namespace yame
{
namespace ytl
{

const size_t k_embeddedStorageSize = 16;

template<typename Return, typename ... TTypes>
struct create_function;


template<typename ...>
class function;

template<typename Return>
class function<Return()> : public detail::function_storage<k_embeddedStorageSize, Return()>
{
    template<typename T>
    struct is_valid_functor
    {
        static const bool value = mpl::is_pointer<typename mpl::drop_constness<typename mpl::drop_reference<T>::type>::type>::value==false &&
                                    mpl::is_function<typename mpl::drop_constness<typename mpl::drop_reference<T>::type>::type>::value==false;
    };
public:
    typedef detail::function_impl_base<Return,container::parameter_pack<>> func_ptr_base;

    function() = default;
    function(mpl::null_ptr_type);
    function(const function& other);
    function(function&& other);
    template<typename T>
    function(T&& functor, typename mpl::enable_if<is_valid_functor<T>::value>::type* foo = __null);
    template<typename T>
    function(T *pRef, Return(T::*call)());
    function(Return(*call)());
    ~function();
    function& operator=(const function& other);
    function& operator=(function&& other);
    function& operator=(detail::function_impl_base<Return,container::parameter_pack<>>* funcBase);
    function& operator=(mpl::null_ptr_type);
    inline Return eval() const;
    operator Return() const;
    Return operator()() const;


    bool operator==(mpl::null_ptr_type) const;
    bool operator!=(mpl::null_ptr_type) const;
    detail::function_impl_base<Return,container::parameter_pack<>>* getFuncPtr() const;
    static function<Return()> clone(const detail::function_impl_base<Return,container::parameter_pack<>>* i_funcPtr);
private:
    function(detail::function_impl_base<Return,container::parameter_pack<>>* funcBase);
};


template<typename Return, typename ... Types>
class function<Return(Types...)>: public detail::function_storage<k_embeddedStorageSize, Return(Types...)>
{
    template<typename T>
    struct is_valid_functor
    {
        static const bool value = mpl::is_pointer<typename mpl::drop_constness<typename mpl::drop_reference<T>::type>::type>::value==false &&
                                    mpl::is_function<typename mpl::drop_constness<typename mpl::drop_reference<T>::type>::type>::value==false;
    };
    typedef mpl::function_types_resolver<Return,Types...> types_resolver;
    template<typename ... TTypes>
    using specType = create_function<Return, typename mpl::get_sub_parameter_pack<Types...>::template at_seq<typename mpl::get_pos_of_type<mpl::place_holder, mpl::is_type_constructible>::template at<TTypes...>::type>::type>;
    template<typename ... Args>
    struct compositeType
    {
    private:
        template<typename ... TTypes>
        static function<Return(TTypes...)> get_function_type(const function<typename mpl::drop_constness<typename mpl::drop_reference<Types>::type>::type(TTypes...)>& ...);
        static void get_function_type(...);
    public:
        typedef decltype(get_function_type(mpl::instantiateType<Args>::get() ...)) type;
    };
    struct specializer
    {
        template<typename ... Args>
        inline typename specType<Args&&...>::type operator()(const function<Return(Types...)>& i_func, Args&& ... i_args) const;
    };
    struct composer
    {
        template<typename ... TTypes>
        inline function<Return(TTypes...)> operator()(const function<Return(Types...)>& i_func, const function<typename mpl::drop_constness<typename mpl::drop_reference<Types>::type>::type(TTypes ...)>& ... i_functions) const;
    };

public:
    using detail::function_storage<k_embeddedStorageSize, Return(Types...)>::clone;
    typedef detail::function_impl_base<Return,container::parameter_pack<Types...>> func_ptr_base;

    function() = default;
    function(mpl::null_ptr_type);
    function(const function& other);
    function(function&& other);
    template<typename T>
    function(T&& functor, typename mpl::enable_if<is_valid_functor<T>::value>::type* foo = __null);
    template<typename T>
    function(T *pRef, Return(T::*call)(Types...));
    function(Return(*call)(Types...));
    ~function();
    function& operator=(const function& other);
    function& operator=(function&& other);
    function& operator=(mpl::null_ptr_type);
    function& operator=(detail::function_impl_base<Return,container::parameter_pack<Types...>>* other);
    template<typename ... Args>
    inline Return eval(Args&& ... args) const;
    template<typename ... Args>
    typename mpl::static_if<types_resolver::template is_specialization<Args&&...>::value,typename specType<Args&&...>::type,typename compositeType<Args...>::type>::type operator()(Args&& ... args) const;
    bool operator==(mpl::null_ptr_type) const;
    bool operator!=(mpl::null_ptr_type) const;
    template<int ... ArgIndexs, typename ... Args>
    typename create_function<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<ArgIndexs...>::type>::type specializeAt(Args&& ... args) const;
    detail::function_impl_base<Return,container::parameter_pack<Types...>>* getFuncPtr() const;
    static function<Return(Types...)> clone(const detail::function_impl_base<Return,container::parameter_pack<Types...>>* i_funcPtr);

private:
    function(detail::function_impl_base<Return,container::parameter_pack<Types...>>* funcBase);
};

template<typename Return, typename ... Types>
struct create_function<Return, container::parameter_pack<Types...>>
{
    typedef function<Return(Types...)> type;
};

template<typename Object, typename Return, typename ... Types>
function<Return(Types...)> make_function(Object* i_object, Return(Object::*i_funcPtr)(Types...));
template<typename Return, typename ... Types>
function<Return(Types...)> make_function(Return(*i_funcPtr)(Types...));


template<typename Return, typename ... Types>
using curried_function = typename yame::mpl::curry_function<yame::ytl::function<Return(Types...)>>::type;

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunction.tpp" 1


# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cAgnosticCallable.h" 1
       



namespace yame
{
namespace ytl
{

template<typename Return,typename ... Types>
class agnostic_composed_callable;

template<typename Return,typename ... Types>
class agnostic_composed_callable<Return(Types...)>
{
public:
    template<typename Callable,typename ... IntermediateTypes>
    agnostic_composed_callable(const Callable& i_transformReturn, const function<IntermediateTypes(Types...)>& ... i_baseFunctions);
    Return operator()(Types ... i_args) const;
    size_t getNumIntermediateTypes() const;
    template<typename ... IntermediateTypes>
    const detail::function_impl_base<Return,container::parameter_pack<IntermediateTypes...>>* getTransform() const;
    template<int Index,typename ... IntermediateTypes>
    const detail::function_impl_base<Return,container::parameter_pack<Types...>>* getNestedCallable() const;

private:
    ytl::function<Return(Types...)> m_composedCallable;
    size_t m_intermediateDimension;
};

}

namespace mpl
{

template<typename Return,typename ... Types>
struct is_local_invariant<ytl::agnostic_composed_callable<Return(Types...)>>
{
    static const bool value = false;
};

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cAgnosticCallable.tpp" 1

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cComposedCallable.h" 1
       



namespace yame
{
namespace ytl
{
namespace detail
{

template<typename Return, typename ... Types>
struct function_impl_base;

template<int,typename, typename ...>
class composed_callable_func;
class composed_callable_func_tag
{};

template<int Pos,typename ... CallableTypes,typename ... NestedCallableTypes>
class composed_callable_func<Pos,container::parameter_pack<CallableTypes...>,NestedCallableTypes...> : protected mpl::static_if<Pos+1<mpl::get_num_types<CallableTypes...>::value,composed_callable_func<Pos+1,container::parameter_pack<CallableTypes...>,NestedCallableTypes...>,composed_callable_func_tag>::type
{
    static const size_t num_callables = mpl::get_num_types<CallableTypes...>::value;
    typedef typename mpl::static_if<Pos+1<num_callables,composed_callable_func<Pos+1,container::parameter_pack<CallableTypes...>,NestedCallableTypes...>,composed_callable_func_tag>::type base_type;

    template<int Size>
    struct proper_function_storage_size
    {
        template<int _Size>
        struct retrieve_size
        {
            static const int value = _Size;
        };

        static const int value = mpl::static_if<(Size / num_callables)>= 4, retrieve_size<Size>, proper_function_storage_size<Size + 4>>::type::value;
    };

public:
    typedef typename mpl::nth_type_of<Pos,CallableTypes...>::type callable_type;
    typedef detail::function_storage<proper_function_storage_size<k_embeddedStorageSize>::value,callable_type(NestedCallableTypes...)> nested_function;
    typedef const nested_function& const_nested_function_reference;

    template<typename Arg, typename ... Args>
    composed_callable_func(const Arg& i_callable, const Args& ... i_callables);
    composed_callable_func(const composed_callable_func& i_other);
    composed_callable_func(composed_callable_func&& i_other);
    ~composed_callable_func();
    const_nested_function_reference getNestedCallable() const;

private:
    nested_function m_nestedCallable;
};


struct composed_callable_tag
{};

};

template<typename Callable, typename ... NestedCallableTypes>
class composed_callable : detail::composed_callable_tag, protected detail::composed_callable_func<0,typename mpl::function_signature<Callable>::callable_args_pack,NestedCallableTypes...>
{
    typedef typename mpl::function_signature<Callable>::callable callable;
    typedef typename mpl::function_signature<Callable>::callable_return_type callable_return_type;
    typedef typename mpl::function_signature<Callable>::callable_args_pack callable_args;
    typedef detail::composed_callable_func<0,callable_args,NestedCallableTypes...> base_type;
    static const size_t num_callables = mpl::get_parameter_pack_num_types<callable_args>::value;

public:
    template<typename ... Args>
    composed_callable(const Callable& i_callableTransform, const Args& ... i_args);
    composed_callable(const composed_callable<Callable,NestedCallableTypes...>& other);
    composed_callable(composed_callable<Callable,NestedCallableTypes...>&& other);
    callable_return_type operator()(NestedCallableTypes ... i_args) const;
    callable_return_type eval(NestedCallableTypes ... i_args) const;
    template<int Index>
    const detail::function_impl_base<typename detail::composed_callable_func<Index,callable_args,NestedCallableTypes...>::callable_type,container::parameter_pack<NestedCallableTypes...>>* getNestedCallable() const;
    const Callable& getTransform() const;

private:
    template<int ... Index>
    inline callable_return_type execute(const mpl::sequence<Index...>&, NestedCallableTypes ... i_args) const;

    Callable m_returnTransform;
};

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cComposedCallable.tpp" 1



namespace yame
{
namespace ytl
{
namespace detail
{
template<int Pos,typename ... CallableTypes,typename ... NestedCallableTypes>
template<typename Arg, typename ... Args>
composed_callable_func<Pos,container::parameter_pack<CallableTypes...>,NestedCallableTypes...>::composed_callable_func(const Arg& i_callable, const Args& ... i_callables)
: base_type(i_callables ...)
{
    m_nestedCallable.clone(*i_callable.getFuncPtr());
}
template<int Pos,typename ... CallableTypes,typename ... NestedCallableTypes>
composed_callable_func<Pos,container::parameter_pack<CallableTypes...>,NestedCallableTypes...>::composed_callable_func(const composed_callable_func& other)
: base_type(static_cast<const base_type&>(other))
, m_nestedCallable(other.getNestedCallable())
{
}
template<int Pos,typename ... CallableTypes,typename ... NestedCallableTypes>
composed_callable_func<Pos,container::parameter_pack<CallableTypes...>,NestedCallableTypes...>::composed_callable_func(composed_callable_func&& other)
: base_type(static_cast<base_type&&>(other))
, m_nestedCallable(mpl::move(other.getNestedCallable()))
{
}
template<int Pos,typename ... CallableTypes,typename ... NestedCallableTypes>
composed_callable_func<Pos,container::parameter_pack<CallableTypes...>,NestedCallableTypes...>::~composed_callable_func()
{
    m_nestedCallable.destroy();
}
template<int Pos,typename ... CallableTypes,typename ... NestedCallableTypes>
typename composed_callable_func<Pos,container::parameter_pack<CallableTypes...>,NestedCallableTypes...>::const_nested_function_reference composed_callable_func<Pos,container::parameter_pack<CallableTypes...>,NestedCallableTypes...>::getNestedCallable() const
{
    return m_nestedCallable;
}

}


template<typename Callable, typename ... NestedCallableTypes>
template<typename ... Args>
composed_callable<Callable,NestedCallableTypes...>::composed_callable(const Callable& i_callableTransform, const Args& ... i_args)
: base_type(i_args ...)
, m_returnTransform(i_callableTransform)
{
}
template<typename Callable, typename ... NestedCallableTypes>
composed_callable<Callable,NestedCallableTypes...>::composed_callable(const composed_callable<Callable,NestedCallableTypes...>& other)
: base_type(static_cast<const base_type&>(other))
, m_returnTransform(other.m_returnTransform)
{
}
template<typename Callable, typename ... NestedCallableTypes>
composed_callable<Callable,NestedCallableTypes...>::composed_callable(composed_callable<Callable,NestedCallableTypes...>&& other)
: base_type(mpl::move(static_cast<base_type&&>(other)))
, m_returnTransform(mpl::move(other.m_returnTransform))
{
}
template<typename Callable, typename ... NestedCallableTypes>
typename composed_callable<Callable,NestedCallableTypes...>::callable_return_type composed_callable<Callable,NestedCallableTypes...>::operator()(NestedCallableTypes ... i_args) const
{
    typedef typename mpl::create_range_rank<0,num_callables>::type rangeSeq;

    return execute(rangeSeq(), mpl::forward<NestedCallableTypes>(i_args)...);
}
template<typename Callable, typename ... NestedCallableTypes>
template<int ... Index>
typename composed_callable<Callable,NestedCallableTypes...>::callable_return_type composed_callable<Callable,NestedCallableTypes...>::execute(const mpl::sequence<Index...>&, NestedCallableTypes ... i_args) const
{
    return m_returnTransform( detail::composed_callable_func<Index,callable_args,NestedCallableTypes...>::getNestedCallable().getFuncPtr()->operator()(mpl::forward<NestedCallableTypes>(i_args) ...) ...);
}
template<typename Callable, typename ... NestedCallableTypes>
template<int Index>
const detail::function_impl_base<typename detail::composed_callable_func<Index,typename composed_callable<Callable,NestedCallableTypes...>::callable_args,NestedCallableTypes...>::callable_type,container::parameter_pack<NestedCallableTypes...>>* composed_callable<Callable,NestedCallableTypes...>::getNestedCallable() const
{
    static_assert(Index < num_callables, "Index out of bounds");

    return detail::composed_callable_func<Index,callable_args,NestedCallableTypes...>::getNestedCallable().getFuncPtr();
}
template<typename Callable, typename ... NestedCallableTypes>
const Callable& composed_callable<Callable,NestedCallableTypes...>::getTransform() const
{
    return m_returnTransform;
}

}
}
# 90 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cComposedCallable.h" 2
# 3 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cAgnosticCallable.tpp" 2

namespace yame
{
namespace ytl
{

template<typename Return,typename ... Types>
template<typename Callable,typename ... IntermediateTypes>
agnostic_composed_callable<Return(Types...)>::agnostic_composed_callable(const Callable& i_transformReturn, const function<IntermediateTypes(Types...)>& ... i_baseFunctions)
{
    m_composedCallable = composed_callable<function<Return(IntermediateTypes...)>,Types...>(i_transformReturn, i_baseFunctions ...);
    m_intermediateDimension = mpl::get_num_types<IntermediateTypes...>::value;
}
template<typename Return,typename ... Types>
Return agnostic_composed_callable<Return(Types...)>::operator()(Types ... i_args) const
{
    return m_composedCallable(mpl::forward<Types>(i_args) ...);
}
template<typename Return,typename ... Types>
size_t agnostic_composed_callable<Return(Types...)>::getNumIntermediateTypes() const
{
    return m_intermediateDimension;
}
template<typename Return,typename ... Types>
template<typename ... IntermediateTypes>
const detail::function_impl_base<Return,container::parameter_pack<IntermediateTypes...>>* agnostic_composed_callable<Return(Types...)>::getTransform() const
{
    if(const detail::functor_impl<composed_callable<function<Return(IntermediateTypes...)>,Types...>,Return,Types...>* functor = dynamic_cast<const detail::functor_impl<composed_callable<function<Return(IntermediateTypes...)>,Types...>,Return,Types...>*>(m_composedCallable.getFuncPtr()))
    {
        const composed_callable<function<Return(IntermediateTypes...)>,Types...>& nestedCallable = functor->getCallable();

        const function<Return(IntermediateTypes...)>& nestedTransform = nestedCallable.getTransform();

        return nestedTransform.getFuncPtr();
    }
    else
    {
        return __null;
    }
}
template<typename Return,typename ... Types>
template<int Index,typename ... IntermediateTypes>
const detail::function_impl_base<Return,container::parameter_pack<Types...>>* agnostic_composed_callable<Return(Types...)>::getNestedCallable() const
{
    if(const detail::functor_impl<composed_callable<function<Return(IntermediateTypes...)>,Types...>,Return,Types...>* functor = dynamic_cast<const detail::functor_impl<composed_callable<function<Return(IntermediateTypes...)>,Types...>,Return,Types...>*>(m_composedCallable.getFuncPtr()))
    {
        const composed_callable<function<Return(IntermediateTypes...)>,Types...>& nestedCallable = functor->getCallable();

        return nestedCallable.template getNestedCallable<Index>();
    }
    else
    {
        return __null;
    }
}

}
}
# 45 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cAgnosticCallable.h" 2
# 4 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunction.tpp" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cPassByValueFunctor.h" 1
       



namespace yame
{
namespace ytl
{

template<typename Return,typename ... Types>
class pass_by_value_functor;

template<typename Return,typename ... Types>
class pass_by_value_functor<Return(Types...)>
{
public:
    pass_by_value_functor(const function<Return(Types...)>& i_function);
    Return operator()(typename mpl::drop_constness<typename mpl::drop_reference<Types>::type>::type ...) const;
    const function<Return(Types...)>& getForwardedFunction() const;

private:
    function<Return(Types...)> m_nestedFunction;
};

}

namespace mpl
{

template<typename Return,typename ... Types>
struct is_local_invariant<ytl::pass_by_value_functor<Return,Types...>>
{
    static const bool value = false;
};

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cPassByValueFunctor.tpp" 1

namespace yame
{
namespace ytl
{

template<typename Return,typename ... Types>
pass_by_value_functor<Return(Types...)>::pass_by_value_functor(const function<Return(Types...)>& i_function)
: m_nestedFunction(i_function)
{
}
template<typename Return,typename ... Types>
Return pass_by_value_functor<Return(Types...)>::operator()(typename mpl::drop_constness<typename mpl::drop_reference<Types>::type>::type ... i_args) const
{
    return m_nestedFunction.eval(i_args ...);
}
template<typename Return,typename ... Types>
const function<Return(Types...)>& pass_by_value_functor<Return(Types...)>::getForwardedFunction() const
{
    return m_nestedFunction;
}

}
}
# 39 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cPassByValueFunctor.h" 2
# 5 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunction.tpp" 2

namespace yame
{
namespace ytl
{

template<typename Return, typename ... Types>
template<typename ... Args>
typename function<Return(Types...)>::template specType<Args&&...>::type function<Return(Types...)>::specializer::operator()(const function<Return(Types...)>& i_func, Args&& ... i_vals) const
{
    typename specType<Args...>::type specFunc;

    typename detail::function_storage<k_embeddedStorageSize, Return(Types...)>::FuncPtr _funcPtr = i_func.getFuncPtr();

    if(auto _specFuncPtr = _funcPtr->specialize(specFunc.getArena(), i_func.getArenaSize(), mpl::forward<Args>(i_vals)...))
    {
        specFunc = _specFuncPtr;
    }


    return specFunc;
}
template<typename Return, typename ... Types>
template<typename ... TTypes>
function<Return(TTypes...)> function<Return(Types...)>::composer::operator()(const function<Return(Types...)>& i_func, const function<typename mpl::drop_constness<typename mpl::drop_reference<Types>::type>::type(TTypes...)>& ... i_functions) const
{
    return yame::ytl::agnostic_composed_callable<Return(TTypes...)>(pass_by_value_functor<Return(Types...)>(i_func),i_functions ...);
}

template<typename Return, typename ... Types>
function<Return(Types...)>::function(mpl::null_ptr_type)
: detail::function_storage<k_embeddedStorageSize,Return(Types...)>()
{
}
template<typename Return, typename ... Types>
function<Return(Types...)>::function(const function& other)
: detail::function_storage<k_embeddedStorageSize, Return(Types...)>(other)
{
}
template<typename Return, typename ... Types>
function<Return(Types...)>::function(function&& other)
: detail::function_storage<k_embeddedStorageSize, Return(Types...)>(mpl::move(other))
{
}
template<typename Return, typename ... Types>
function<Return(Types...)>::function(detail::function_impl_base<Return,container::parameter_pack<Types...>>* funcBase)
: detail::function_storage<k_embeddedStorageSize, Return(Types...)>(funcBase)
{
}
template<typename Return, typename ... Types>
template<typename T>
function<Return(Types...)>::function(T&& functor, typename mpl::enable_if<is_valid_functor<T>::value>::type* foo)
{
    typedef detail::functor_impl<typename mpl::drop_constness<typename mpl::drop_reference<T>::type>::type,Return,Types...> Functor;

    detail::function_storage<k_embeddedStorageSize, Return(Types...)>::template construct<Functor>(mpl::forward<T>(functor));
}
template<typename Return, typename ... Types>
function<Return(Types...)>::function(Return(*call)(Types...))
{
    typedef detail::free_function_impl<Return,Types...> Functor;

    detail::function_storage<k_embeddedStorageSize, Return(Types...)>::template construct<Functor>(call);
}
template<typename Return, typename ... Types>
template<typename T>
function<Return(Types...)>::function(T *pRef, Return(T::*call)(Types...))
{
    typedef detail::relative_function_impl<T,Return,Types...> Functor;

    detail::function_storage<k_embeddedStorageSize, Return(Types...)>::template construct<Functor>(pRef, call);
}
template<typename Return, typename ... Types>
function<Return(Types...)>::~function()
{
    detail::function_storage<k_embeddedStorageSize, Return(Types...)>::destroy();
}
template<typename Return, typename ... Types>
function<Return(Types...)>& function<Return(Types...)>::operator=(const function& other)
{
    detail::function_storage<k_embeddedStorageSize, Return(Types...)>::operator=(other);

    return *this;
}
template<typename Return, typename ... Types>
function<Return(Types...)>& function<Return(Types...)>::operator=(function&& other)
{
    detail::function_storage<k_embeddedStorageSize, Return(Types...)>::operator=(mpl::move(other));

    return *this;
}
template<typename Return, typename ... Types>
function<Return(Types...)>& function<Return(Types...)>::operator=(detail::function_impl_base<Return,container::parameter_pack<Types...>>* funcBase)
{
    detail::function_storage<k_embeddedStorageSize, Return(Types...)>::operator=(funcBase);

    return *this;
}
template<typename Return, typename ... Types>
function<Return(Types...)>& function<Return(Types...)>::operator=(mpl::null_ptr_type)
{
    detail::function_storage<k_embeddedStorageSize, Return(Types...)>::destroy();

    return *this;
}
template<typename Return, typename ... Types>
template<typename ... Args>
Return function<Return(Types...)>::eval(Args&& ... args) const
{
    typename detail::function_storage<k_embeddedStorageSize, Return(Types...)>::FuncPtr _funcPtr = detail::function_storage<k_embeddedStorageSize, Return(Types...)>::getFuncPtr();

    return _funcPtr->operator()(mpl::forward<Args>(args)...);
}
template<typename Return, typename ... Types>
template<typename ... Args>
typename mpl::static_if<function<Return(Types...)>::types_resolver::template is_specialization<Args&&...>::value,typename function<Return(Types...)>::template specType<Args&&...>::type,typename function<Return(Types...)>::template compositeType<Args...>::type>::type function<Return(Types...)>::operator()(Args&& ... i_args) const
{
    typedef typename mpl::static_if<types_resolver::template is_specialization<Args&&...>::value,specializer,composer>::type caller;

 return caller()(*this,mpl::forward<Args>(i_args) ...);
}
template<typename Return, typename ... Types>
template<int ... ArgIndexs, typename ... Args>
typename create_function<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<ArgIndexs...>::type>::type function<Return(Types...)>::specializeAt(Args&& ... args) const
{
    typedef typename create_function<Return, typename mpl::get_sub_parameter_pack<Types...>::template not_at<ArgIndexs...>::type>::type retType;

    retType specFunc;

    typename detail::function_storage<k_embeddedStorageSize, Return(Types...)>::FuncPtr _funcPtr = detail::function_storage<k_embeddedStorageSize, Return(Types...)>::getFuncPtr();

    if(auto _specFuncPtr = _funcPtr->template specializeAt<ArgIndexs...>(specFunc.getArena(), this->getArenaSize(), mpl::forward<Args>(args)...))
    {
        specFunc = _specFuncPtr;
    }


    return specFunc;
}
template<typename Return, typename ... Types>
bool function<Return(Types...)>::operator==(mpl::null_ptr_type) const
{
    return this->empty();
}
template<typename Return, typename ... Types>
bool function<Return(Types...)>::operator!=(mpl::null_ptr_type) const
{
    return this->empty() == false;
}
template<typename Return, typename ... Types>
detail::function_impl_base<Return,container::parameter_pack<Types...>>* function<Return(Types...)>::getFuncPtr() const
{
    return detail::function_storage<k_embeddedStorageSize, Return(Types...)>::getFuncPtr();
}
template<typename Return, typename ... Types>
function<Return(Types...)> function<Return(Types...)>::clone(const detail::function_impl_base<Return,container::parameter_pack<Types...>>* i_funcPtr)
{
    function<Return(Types...)> res;

    if(i_funcPtr != __null)
    {
        res.clone(*i_funcPtr);
    }

    return res;
}


template<typename Return>
function<Return()>::function(mpl::null_ptr_type)
: detail::function_storage<k_embeddedStorageSize, Return()>()
{
}
template<typename Return>
function<Return()>::function(const function& other)
: detail::function_storage<k_embeddedStorageSize, Return()>(other)
{
}
template<typename Return>
function<Return()>::function(function&& other)
: detail::function_storage<k_embeddedStorageSize, Return()>(mpl::move(other))
{
}
template<typename Return>
function<Return()>::function(detail::function_impl_base<Return,container::parameter_pack<>>* funcBase)
: detail::function_storage<k_embeddedStorageSize, Return()>(funcBase)
{
}
template<typename Return>
template<typename T>
function<Return()>::function(T&& functor, typename mpl::enable_if<is_valid_functor<T>::value>::type* foo)
{
    typedef detail::functor_impl<typename mpl::drop_reference<T>::type,Return> Functor;

    detail::function_storage<k_embeddedStorageSize, Return()>::template construct<Functor>(mpl::forward<T>(functor));
}
template<typename Return>
function<Return()>::function(Return(*call)())
{
    typedef detail::free_function_impl<Return> Functor;

    detail::function_storage<k_embeddedStorageSize, Return()>::template construct<Functor>(call);
}
template<typename Return>
template<typename T>
function<Return()>::function(T *pRef, Return(T::*call)())
{
    typedef detail::relative_function_impl<T,Return> Functor;

    detail::function_storage<k_embeddedStorageSize, Return()>::template construct<Functor>(pRef, call);
}
template<typename Return>
function<Return()>::~function()
{
    detail::function_storage<k_embeddedStorageSize, Return()>::destroy();
}
template<typename Return>
function<Return()>& function<Return()>::operator=(const function& other)
{
    detail::function_storage<k_embeddedStorageSize, Return()>::operator=(other);

    return *this;
}
template<typename Return>
function<Return()>& function<Return()>::operator=(function&& other)
{
    detail::function_storage<k_embeddedStorageSize, Return()>::operator=(mpl::move(other));

    return *this;
}
template<typename Return>
function<Return()>& function<Return()>::operator=(detail::function_impl_base<Return,container::parameter_pack<>>* funcBase)
{
    detail::function_storage<k_embeddedStorageSize, Return()>::operator=(funcBase);

    return *this;
}
template<typename Return>
function<Return()>& function<Return()>::operator=(mpl::null_ptr_type)
{
    detail::function_storage<k_embeddedStorageSize, Return()>::destroy();

    return *this;
}
template<typename Return>
Return function<Return()>::eval() const
{
    typename detail::function_storage<k_embeddedStorageSize, Return()>::FuncPtr _funcPtr = detail::function_storage<k_embeddedStorageSize, Return()>::getFuncPtr();

    return _funcPtr->operator()();
}
template<typename Return>
function<Return()>::operator Return() const
{
    typename detail::function_storage<k_embeddedStorageSize, Return()>::FuncPtr _funcPtr = detail::function_storage<k_embeddedStorageSize, Return()>::getFuncPtr();

    return _funcPtr->operator()();
}
template<typename Return>
Return function<Return()>::operator()() const
{
    typename detail::function_storage<k_embeddedStorageSize, Return()>::FuncPtr _funcPtr = detail::function_storage<k_embeddedStorageSize, Return()>::getFuncPtr();

    return _funcPtr->operator()();
}
# 284 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/detail/cFunction.tpp"
template<typename Return>
bool function<Return()>::operator==(mpl::null_ptr_type) const
{
    return this->empty();
}
template<typename Return>
bool function<Return()>::operator!=(mpl::null_ptr_type) const
{
    return this->empty() == false;
}

template<typename Object, typename Return, typename ... Types>
function<Return(Types...)> make_function(Object* i_object, Return(Object::*i_funcPtr)(Types...))
{
    return function<Return(Types...)>(i_object, i_funcPtr);
}
template<typename Return, typename ... Types>
function<Return(Types...)> make_function(Return(*i_funcPtr)(Types...))
{
    return function<Return(Types...)>(i_funcPtr);
}
template<typename Return>
detail::function_impl_base<Return,container::parameter_pack<>>* function<Return()>::getFuncPtr() const
{
    return detail::function_storage<k_embeddedStorageSize, Return()>::getFuncPtr();
}
template<typename Return>
function<Return()> function<Return()>::clone(const detail::function_impl_base<Return,container::parameter_pack<>>* i_funcPtr)
{
    function<Return()> res;

    if(i_funcPtr != __null)
    {
        res.clone(*i_funcPtr);
    }

    return res;
}

}
}
# 158 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/functional/cFunction.h" 2
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterableBase.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterator.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterator.h"
       




# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIteratorTag.h" 1
       

namespace yame
{
namespace container
{
namespace detail
{
namespace impl
{


struct InputIteratorTag {};
struct OutputIteratorTag {};
struct ForwardIteratorTag : InputIteratorTag {};
struct BidirectionalIteratorTag : ForwardIteratorTag {};
struct RandomAccessIteratorTag : BidirectionalIteratorTag {};
struct ReverseIterator {};
struct ReverseBidirectionalIteratorTag : ReverseIterator {};
struct ReverseRandomAccessIteratorTag : ReverseBidirectionalIteratorTag {};

}
}
}
}
# 21 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterator.h" 2

namespace yame
{
namespace container
{
namespace detail
{


template<typename>
class cInputIterableBasePrivate;
template<typename>
class cOutputIterableBasePrivate;
template<typename>
class cForwardIterableBasePrivate;
template<typename>
class cBidirectionalIterableBasePrivate;
template<typename>
class cRandomAccessIterableBasePrivate;
template<typename,typename,typename,typename>
class cIterableBaseImpl;
template<template <typename> class,typename>
class cIterable;

enum ReferenceCategory
{
    NonConstReference = 0,
    ConstReference = 1,
    Value = 2
};

template<typename>
struct deduceCategoryFromType;

template<typename T>
struct deduceCategoryFromType<const T&>
{
    static const ReferenceCategory category = ReferenceCategory::ConstReference;
};

template<typename T>
struct deduceCategoryFromType<T&>
{
    static const ReferenceCategory category = ReferenceCategory::NonConstReference;
};

template<typename T>
struct deduceCategoryFromType
{
    static const ReferenceCategory category = ReferenceCategory::Value;
};

template<typename,ReferenceCategory>
struct getReference;

template<typename TT>
struct getReference<TT,ReferenceCategory::NonConstReference>
{
    typedef typename mpl::add_reference<TT>::type type;
    static const ReferenceCategory value = NonConstReference;
};
template<typename TT>
struct getReference<TT,ReferenceCategory::ConstReference>
{
    typedef typename mpl::add_constness<typename mpl::add_reference<TT>::type>::type type;
    static const ReferenceCategory value = ConstReference;
};
template<typename TT>
struct getReference<TT,ReferenceCategory::Value>
{
    typedef typename mpl::drop_reference<typename mpl::drop_constness<TT>::type>::type type;
    static const ReferenceCategory value = Value;
};

namespace impl
{


template<typename Traits>
class cIteratorImpl : public Traits::tag
{
public:
 typedef typename Traits::raw_type raw_type;
 typedef typename Traits::value_type value_type;
 typedef typename Traits::pointer_type pointer_type;
 typedef typename Traits::difference_type difference_type;
 typedef typename Traits::reference reference;
 typedef typename Traits::const_reference const_reference;
 typedef typename Traits::reference_pointer reference_pointer;
 typedef typename Traits::iterable_private_interface iterable_private_interface;
 typedef typename Traits::iterator_type iterator_type;
 typedef typename Traits::const_iterator_type const_iterator_type;
 static const ReferenceCategory category = Traits::category;

    cIteratorImpl(const cIteratorImpl<Traits>&);
    cIteratorImpl(cIteratorImpl<Traits>&&);
    cIteratorImpl(const iterable_private_interface& iter);
    cIteratorImpl(const iterable_private_interface& iter, const ytl::function<bool(const_reference)>& filter);
    ~cIteratorImpl();

    inline iterator_type& operator=(const cIteratorImpl<Traits>& other);
    inline iterator_type operator++(int);

    static pointer_type const m_pHead;

protected:
    void setCurrentNode(pointer_type currNode);
    pointer_type getCurrentNode() const;

 const iterable_private_interface* m_iterable;
    pointer_type m_pCurrentNode = m_pHead;
    ytl::function<bool(const_reference)> m_filter;
};

template<typename Traits>
class cInputIteratorImpl : public cIteratorImpl<Traits>
{
    template<typename,typename,typename,typename>
    friend class cConstIterableBaseImpl;
    template<typename,typename,typename,typename>
    friend class cIterableBaseImpl;
    template<template <typename> class,typename>
    friend class cIterable;
    template<typename,typename>
    friend class cConstIterableImpl;
    template<typename>
    friend class cBidirectionalIterableImpl;
    template<typename,typename,typename,typename,template<typename,typename,typename,typename>class>
    friend class cReversableBaseIterableImpl;

public:
 typedef typename cIteratorImpl<Traits>::raw_type raw_type;
 typedef typename cIteratorImpl<Traits>::value_type value_type;
 typedef typename cIteratorImpl<Traits>::pointer_type pointer_type;
 typedef typename cIteratorImpl<Traits>::difference_type difference_type;
 typedef typename cIteratorImpl<Traits>::reference reference;
 typedef typename cIteratorImpl<Traits>::const_reference const_reference;
 typedef typename cIteratorImpl<Traits>::reference_pointer reference_pointer;
 typedef typename cIteratorImpl<Traits>::iterator_type iterator_type;
 typedef typename cIteratorImpl<Traits>::const_iterator_type const_iterator_type;
 static const ReferenceCategory category = cIteratorImpl<Traits>::category;

 using cIteratorImpl<Traits>::operator++;
 using cIteratorImpl<Traits>::operator=;

    inline iterator_type& operator++();
    inline reference operator*();
    inline bool operator==(const cInputIteratorImpl<Traits>& other);
    inline bool operator!=(const cInputIteratorImpl<Traits>& other);
    inline pointer_type operator->();

protected:
 using cIteratorImpl<Traits>::cIteratorImpl;
};

template<typename Traits>
class cOutputIteratorImpl : public cIteratorImpl<Traits>
{
    template<typename,typename,typename>
    friend class cConstIterableBaseImpl;
    template<typename,typename,typename>
    friend class cIterableBaseImpl;
    template<template <typename> class,typename>
    friend class cIterable;
    template<typename,typename>
    friend class cConstIterableImpl;
    template<typename>
    friend class cBidirectionalIterableImpl;
    template<typename,typename,typename,template<typename,typename,typename>class>
    friend class cReversableBaseIterableImpl;

public:
 typedef typename cIteratorImpl<Traits>::raw_type raw_type;
 typedef typename cIteratorImpl<Traits>::value_type value_type;
 typedef typename cIteratorImpl<Traits>::pointer_type pointer_type;
 typedef typename cIteratorImpl<Traits>::difference_type difference_type;
 typedef typename cIteratorImpl<Traits>::reference reference;
 typedef typename cIteratorImpl<Traits>::const_reference const_reference;
 typedef typename cIteratorImpl<Traits>::reference_pointer reference_pointer;
 typedef typename cIteratorImpl<Traits>::iterator_type iterator_type;
 typedef typename cIteratorImpl<Traits>::const_iterator_type const_iterator_type;
 static const ReferenceCategory category = cIteratorImpl<Traits>::category;

 using cIteratorImpl<Traits>::operator++;
 using cIteratorImpl<Traits>::operator=;

    inline iterator_type& operator++();
    inline iterator_type& operator*();
 inline iterator_type& operator=(const value_type&);

protected:
 using cIteratorImpl<Traits>::cIteratorImpl;
};

template<typename Traits>
class cForwardIteratorImpl : public cInputIteratorImpl<Traits>
{
    template<typename,typename,typename,typename>
    friend class cConstIterableBaseImpl;
    template<typename,typename,typename,typename>
    friend class cIterableBaseImpl;
    template<template <typename> class,typename>
    friend class cIterable;
    template<typename,typename>
    friend class cConstIterableImpl;
    template<typename>
    friend class cBidirectionalIterableImpl;
    template<typename,typename,typename,typename,template<typename,typename,typename,typename>class>
    friend class cReversableBaseIterableImpl;

public:
 typedef typename cInputIteratorImpl<Traits>::raw_type raw_type;
 typedef typename cInputIteratorImpl<Traits>::value_type value_type;
 typedef typename cInputIteratorImpl<Traits>::pointer_type pointer_type;
 typedef typename cInputIteratorImpl<Traits>::difference_type difference_type;
 typedef typename cInputIteratorImpl<Traits>::reference reference;
 typedef typename cInputIteratorImpl<Traits>::const_reference const_reference;
 typedef typename cInputIteratorImpl<Traits>::reference_pointer reference_pointer;
 typedef typename cInputIteratorImpl<Traits>::iterator_type iterator_type;
 typedef typename cInputIteratorImpl<Traits>::const_iterator_type const_iterator_type;
 static const ReferenceCategory category = cInputIteratorImpl<Traits>::category;

 using cInputIteratorImpl<Traits>::operator++;
 using cInputIteratorImpl<Traits>::operator=;
 using cInputIteratorImpl<Traits>::operator==;
 using cInputIteratorImpl<Traits>::operator!=;
    using cInputIteratorImpl<Traits>::operator->;

protected:
 using cInputIteratorImpl<Traits>::cInputIteratorImpl;
};

template<typename Traits>
class cBidirectionalIteratorImpl : public cForwardIteratorImpl<Traits>
{
    template<typename,typename,typename,typename>
    friend class cConstIterableBaseImpl;
    template<typename,typename,typename,typename>
    friend class cIterableBaseImpl;
    template<template <typename> class,typename>
    friend class cIterable;
    template<typename,typename>
    friend class cConstIterableImpl;
    template<typename>
    friend class cBidirectionalIterableImpl;
    template<typename,typename,typename,typename,template<typename,typename,typename,typename>class>
    friend class cReversableBaseIterableImpl;

public:
 typedef typename cForwardIteratorImpl<Traits>::raw_type raw_type;
 typedef typename cForwardIteratorImpl<Traits>::value_type value_type;
 typedef typename cForwardIteratorImpl<Traits>::pointer_type pointer_type;
 typedef typename cForwardIteratorImpl<Traits>::difference_type difference_type;
 typedef typename cForwardIteratorImpl<Traits>::reference reference;
 typedef typename cForwardIteratorImpl<Traits>::const_reference const_reference;
 typedef typename cForwardIteratorImpl<Traits>::reference_pointer reference_pointer;
 typedef typename cForwardIteratorImpl<Traits>::iterator_type iterator_type;
 typedef typename cForwardIteratorImpl<Traits>::const_iterator_type const_iterator_type;
 static const ReferenceCategory category = cForwardIteratorImpl<Traits>::category;

 using cForwardIteratorImpl<Traits>::operator=;
 using cForwardIteratorImpl<Traits>::operator*;
 using cForwardIteratorImpl<Traits>::operator==;
 using cForwardIteratorImpl<Traits>::operator!=;
    using cForwardIteratorImpl<Traits>::operator->;


    inline iterator_type operator++(int);
    inline iterator_type& operator++();
    inline iterator_type& operator--();
    inline iterator_type operator--(int);

protected:
 using cForwardIteratorImpl<Traits>::cForwardIteratorImpl;
};

template<typename Traits>
class cRandomAccessIteratorImpl : public cBidirectionalIteratorImpl<Traits>
{
    template<typename,typename,typename,typename>
    friend class cConstIterableBaseImpl;
    template<typename,typename,typename,typename>
    friend class cIterableBaseImpl;
    template<template <typename> class,typename>
    friend class cIterable;
    template<typename,typename>
    friend class cConstIterableImpl;
    template<typename>
    friend class cBidirectionalIterableImpl;
    template<typename,typename,typename,typename,template<typename,typename,typename,typename>class>
    friend class cReversableBaseIterableImpl;

public:
 typedef typename cBidirectionalIteratorImpl<Traits>::raw_type raw_type;
 typedef typename cBidirectionalIteratorImpl<Traits>::value_type value_type;
 typedef typename cBidirectionalIteratorImpl<Traits>::pointer_type pointer_type;
 typedef typename cBidirectionalIteratorImpl<Traits>::difference_type difference_type;
 typedef typename cBidirectionalIteratorImpl<Traits>::reference reference;
 typedef typename cBidirectionalIteratorImpl<Traits>::const_reference const_reference;
 typedef typename cBidirectionalIteratorImpl<Traits>::reference_pointer reference_pointer;
 typedef typename cBidirectionalIteratorImpl<Traits>::iterator_type iterator_type;
 typedef typename cBidirectionalIteratorImpl<Traits>::const_iterator_type const_iterator_type;
 static const ReferenceCategory category = cBidirectionalIteratorImpl<Traits>::category;

 using cBidirectionalIteratorImpl<Traits>::operator++;
 using cBidirectionalIteratorImpl<Traits>::operator=;
 using cBidirectionalIteratorImpl<Traits>::operator--;
 using cBidirectionalIteratorImpl<Traits>::operator*;
 using cBidirectionalIteratorImpl<Traits>::operator==;
 using cBidirectionalIteratorImpl<Traits>::operator!=;
    using cBidirectionalIteratorImpl<Traits>::operator->;

    inline difference_type operator-(const cRandomAccessIteratorImpl<Traits>& other) const;
    inline iterator_type operator-(u32 index) const;
    inline iterator_type& operator-=(u32 index) const;
    inline iterator_type operator+(u32 index) const;
    inline iterator_type& operator+=(u32 index) const;
 inline reference operator[](size_t index);
 inline bool operator<(const cRandomAccessIteratorImpl<Traits>& other) const;
 inline bool operator>(const cRandomAccessIteratorImpl<Traits>& other) const;
 inline bool operator<=(const cRandomAccessIteratorImpl<Traits>& other) const;
 inline bool operator>=(const cRandomAccessIteratorImpl<Traits>& other) const;

protected:
 using cBidirectionalIteratorImpl<Traits>::cBidirectionalIteratorImpl;
};

template<typename T, ReferenceCategory _category>
struct AgnosticIteratorTraits
{
    typedef T raw_type;
    typedef typename mpl::drop_reference<typename mpl::drop_constness<T>::type>::type value_type;
    typedef typename mpl::drop_reference<typename mpl::drop_constness<T>::type>::type* pointer_type;
    typedef size_t difference_type;
    typedef typename getReference<T,_category>::type reference;

    typedef const value_type& const_reference;
    typedef typename mpl::drop_reference<typename mpl::drop_constness<T>::type>::type* reference_pointer;
    static const ReferenceCategory category = _category;
};

template<typename T, template<class> class Iterator, typename Iterable, typename Tag, ReferenceCategory category>
struct IteratorTraits : AgnosticIteratorTraits<T,category>
{
    typedef Tag tag;
    typedef Iterator<IteratorTraits<T,Iterator,Iterable,Tag,category>> iterator_type;
    typedef typename IteratorTraits<T,Iterator,Iterable,Tag,mpl::static_if<category==ReferenceCategory::Value,getReference<T,ReferenceCategory::Value>,getReference<T,ReferenceCategory::ConstReference>>::type::value>::iterator_type const_iterator_type;
    typedef typename AgnosticIteratorTraits<T,category>::raw_type raw_type;
    typedef typename AgnosticIteratorTraits<T,category>::value_type value_type;
    typedef typename AgnosticIteratorTraits<T,category>::difference_type difference_type;
    typedef typename AgnosticIteratorTraits<T,category>::reference reference;
    typedef typename AgnosticIteratorTraits<T,category>::const_reference const_reference;
    typedef typename AgnosticIteratorTraits<T,category>::reference_pointer reference_pointer;
    typedef Iterable iterable_private_interface;
};

template<typename T,typename IterableInterface,ReferenceCategory>
using cAgnosticInputIterator = impl::cInputIteratorImpl<impl::IteratorTraits<T,impl::cInputIteratorImpl,IterableInterface,InputIteratorTag,ReferenceCategory::ConstReference>>;

template<typename T,typename IterableInterface,ReferenceCategory>
using cAgnosticOutputIterator = impl::cOutputIteratorImpl<impl::IteratorTraits<T,impl::cOutputIteratorImpl,IterableInterface,OutputIteratorTag,ReferenceCategory::NonConstReference>>;

template<typename T, typename IterableInterface,ReferenceCategory category>
using cAgnosticForwardIterator = impl::cForwardIteratorImpl<impl::IteratorTraits<T,impl::cForwardIteratorImpl,IterableInterface,ForwardIteratorTag,category>>;

template<typename T, typename IterableInterface,ReferenceCategory category>
using cAgnosticBidirectionalIterator = impl::cBidirectionalIteratorImpl<impl::IteratorTraits<T,impl::cBidirectionalIteratorImpl,IterableInterface,BidirectionalIteratorTag,category>>;

template<typename T, typename IterableInterface,ReferenceCategory category>
using cAgnosticRandomAccessIterator = impl::cRandomAccessIteratorImpl<impl::IteratorTraits<T,impl::cRandomAccessIteratorImpl,IterableInterface,RandomAccessIteratorTag,category>>;

template<typename T, typename IterableInterface,ReferenceCategory category>
using cReverseAgnosticBidirectionalIterator = impl::cBidirectionalIteratorImpl<impl::IteratorTraits<T,impl::cBidirectionalIteratorImpl,IterableInterface,ReverseBidirectionalIteratorTag,category>>;

template<typename T, typename IterableInterface,ReferenceCategory category>
using cReverseAgnosticRandomAccessIterator = impl::cRandomAccessIteratorImpl<impl::IteratorTraits<T,impl::cRandomAccessIteratorImpl,IterableInterface,ReverseRandomAccessIteratorTag,category>>;

}

template<typename T>
using cInputIterator = impl::cAgnosticInputIterator<T,cInputIterableBasePrivate<impl::AgnosticIteratorTraits<T,ReferenceCategory::ConstReference>>,ReferenceCategory::ConstReference>;
template<typename T>
using cOutputIterator = impl::cAgnosticOutputIterator<T,cOutputIterableBasePrivate<impl::AgnosticIteratorTraits<T,ReferenceCategory::NonConstReference>>,ReferenceCategory::NonConstReference>;
template<typename T>
using cForwardIterator = impl::cAgnosticForwardIterator<T,cForwardIterableBasePrivate<impl::AgnosticIteratorTraits<T,deduceCategoryFromType<T>::category>>,deduceCategoryFromType<T>::category>;
template<typename T>
using cBidirectionalIterator = impl::cAgnosticBidirectionalIterator<T,cBidirectionalIterableBasePrivate<impl::AgnosticIteratorTraits<T,deduceCategoryFromType<T>::category>>,deduceCategoryFromType<T>::category>;
template<typename T>
using cRandomAccessIterator = impl::cAgnosticRandomAccessIterator<T,cRandomAccessIterableBasePrivate<impl::AgnosticIteratorTraits<T,deduceCategoryFromType<T>::category>>,deduceCategoryFromType<T>::category>;

template<typename T>
using cReverseBidirectionalIterator = impl::cReverseAgnosticBidirectionalIterator<T,cBidirectionalIterableBasePrivate<impl::AgnosticIteratorTraits<T,deduceCategoryFromType<T>::category>>,deduceCategoryFromType<T>::category>;
template<typename T>
using cReverseRandomAccessIterator = impl::cReverseAgnosticRandomAccessIterator<T,cRandomAccessIterableBasePrivate<impl::AgnosticIteratorTraits<T,deduceCategoryFromType<T>::category>>,deduceCategoryFromType<T>::category>;

}
}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp" 1
# 47 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp"
namespace yame
{
namespace container
{
namespace detail
{
namespace impl
{



template<typename Traits>
typename cIteratorImpl<Traits>::pointer_type const cIteratorImpl<Traits>::m_pHead = reinterpret_cast<pointer_type const>(0xc1c1);

template<typename Traits>
cIteratorImpl<Traits>::cIteratorImpl(const cIteratorImpl<Traits>& iter)
: m_pCurrentNode(m_pHead)
, m_filter(iter.m_filter)
, m_iterable(iter.m_iterable)
{
    m_pCurrentNode = m_iterable->acquireNode(iter.m_pCurrentNode);
}
template<typename Traits>
cIteratorImpl<Traits>::cIteratorImpl(cIteratorImpl<Traits>&& iter)
: m_pCurrentNode(iter.m_pCurrentNode)
, m_filter(mpl::move(iter.m_filter))
, m_iterable(iter.m_iterable)
{
    iter.m_pCurrentNode = m_pHead;
}
template<typename Traits>
cIteratorImpl<Traits>::cIteratorImpl(const iterable_private_interface& iter)
: m_iterable(&iter)
, m_filter(null_ptr)
, m_pCurrentNode(m_pHead)
{
}
template<typename Traits>
cIteratorImpl<Traits>::cIteratorImpl(const iterable_private_interface& iter, const ytl::function<bool(const_reference)>& filter)
: m_iterable(&iter)
, m_filter(filter)
, m_pCurrentNode(m_pHead)
{
}
template<typename Traits>
cIteratorImpl<Traits>::~cIteratorImpl()
{
    ((m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 94, __PRETTY_FUNCTION__));

    m_iterable->releaseNode(m_pCurrentNode);
}
template<typename Traits>
typename cIteratorImpl<Traits>::iterator_type& cIteratorImpl<Traits>::operator=(const cIteratorImpl<Traits>& other)
{
    ((m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 101, __PRETTY_FUNCTION__));
    ((other.m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("other.m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 102, __PRETTY_FUNCTION__));

    m_iterable->releaseNode(m_pCurrentNode);

    m_iterable = other.m_iterable;

    m_filter = other.m_filter;

    m_pCurrentNode = m_iterable->acquireNode(other.m_pCurrentNode);

    return static_cast<typename Traits::iterator_type&>(*this);
}
template<typename Traits>
void cIteratorImpl<Traits>::setCurrentNode(pointer_type currNode)
{
    ((m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 117, __PRETTY_FUNCTION__));

    m_pCurrentNode = (currNode == m_pHead || m_filter == null_ptr || m_filter(m_iterable->getValue(currNode))) ? currNode : m_pHead;
}
template<typename Traits>
typename cIteratorImpl<Traits>::pointer_type cIteratorImpl<Traits>::getCurrentNode() const
{
    return m_pCurrentNode;
}
template<typename Traits>
typename Traits::iterator_type cIteratorImpl<Traits>::operator++(int)
{
    typename Traits::iterator_type res(static_cast<typename Traits::iterator_type&>(*this));

    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 131, __PRETTY_FUNCTION__)); if(m_pCurrentNode != this->m_pHead) { m_pCurrentNode = this->m_iterable->getNextElem(m_pCurrentNode); while(m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(m_pCurrentNode))) { break; } m_pCurrentNode = this->m_iterable->getNextElem(m_pCurrentNode); } } else { m_pCurrentNode = m_pCurrentNode; }

    return res;
}



template<typename Traits>
typename cInputIteratorImpl<Traits>::iterator_type& cInputIteratorImpl<Traits>::operator++()
{
    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 141, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };

    return static_cast<typename Traits::iterator_type&>(*this);
}
template<typename Traits>
typename cInputIteratorImpl<Traits>::reference cInputIteratorImpl<Traits>::operator*()
{
    ((this->m_pCurrentNode!=this->m_pHead && "Dereferencing the head node!") ? static_cast<void> (0) : __assert_fail ("this->m_pCurrentNode!=this->m_pHead && \"Dereferencing the head node!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 148, __PRETTY_FUNCTION__));

    return this->m_iterable->getValue(this->m_pCurrentNode);
}
template<typename Traits>
bool cInputIteratorImpl<Traits>::operator==(const cInputIteratorImpl<Traits>& other)
{
    return this->m_pCurrentNode == other.m_pCurrentNode;
}
template<typename Traits>
bool cInputIteratorImpl<Traits>::operator!=(const cInputIteratorImpl<Traits>& other)
{
    return this->m_pCurrentNode != other.m_pCurrentNode;
}
template<typename Traits>
typename cInputIteratorImpl<Traits>::pointer_type cInputIteratorImpl<Traits>::operator->()
{
    ((this->m_pCurrentNode!=this->m_pHead && "Dereferencing the head node!") ? static_cast<void> (0) : __assert_fail ("this->m_pCurrentNode!=this->m_pHead && \"Dereferencing the head node!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 165, __PRETTY_FUNCTION__));

    reference tmp = this->m_iterable->getValue(this->m_pCurrentNode);

    return &tmp;
}




template<typename Traits>
typename cOutputIteratorImpl<Traits>::iterator_type& cOutputIteratorImpl<Traits>::operator++()
{
    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 178, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };

    return static_cast<typename Traits::iterator_type&>(*this);
}
template<typename Traits>
typename cOutputIteratorImpl<Traits>::iterator_type& cOutputIteratorImpl<Traits>::operator*()
{
    return static_cast<typename Traits::iterator_type&>(*this);
}
template<typename Traits>
typename cOutputIteratorImpl<Traits>::iterator_type& cOutputIteratorImpl<Traits>::operator=(const value_type& value)
{
    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 190, __PRETTY_FUNCTION__));
    ((this->m_pCurrentNode!=this->m_pHead && "Dereferencing the head node!") ? static_cast<void> (0) : __assert_fail ("this->m_pCurrentNode!=this->m_pHead && \"Dereferencing the head node!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 191, __PRETTY_FUNCTION__));

    this->m_iterable->setValue(this->m_pCurrentNode, value);

    return static_cast<typename Traits::iterator_type&>(*this);
}



template<typename Traits>
typename cBidirectionalIteratorImpl<Traits>::iterator_type cBidirectionalIteratorImpl<Traits>::operator++(int)
{
    static const bool isReverseIterator = mpl::is_base_of<detail::impl::ReverseIterator, typename Traits::tag>::value;

    typename Traits::iterator_type res(static_cast<typename Traits::iterator_type&>(*this));

    if(isReverseIterator)
    {
        ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 209, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getPrevElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getPrevElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };
    }
    else
    {
        ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 213, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };
    }

    return res;
}
template<typename Traits>
typename cBidirectionalIteratorImpl<Traits>::iterator_type& cBidirectionalIteratorImpl<Traits>::operator++()
{
    static const bool isReverseIterator = mpl::is_base_of<detail::impl::ReverseIterator, typename Traits::tag>::value;

    if(isReverseIterator)
    {
        ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 225, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getPrevElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getPrevElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };
    }
    else
    {
        ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 229, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };
    }

    return static_cast<typename Traits::iterator_type&>(*this);
}
template<typename Traits>
typename cBidirectionalIteratorImpl<Traits>::iterator_type& cBidirectionalIteratorImpl<Traits>::operator--()
{
    static const bool isReverseIterator = mpl::is_base_of<detail::impl::ReverseIterator, typename Traits::tag>::value;

    if(isReverseIterator)
    {
        ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 241, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };
    }
    else
    {
        ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 245, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getPrevElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getPrevElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };
    }

    return static_cast<typename Traits::iterator_type&>(*this);
}
template<typename Traits>
typename cBidirectionalIteratorImpl<Traits>::iterator_type cBidirectionalIteratorImpl<Traits>::operator--(int)
{
    typename Traits::iterator_type res(static_cast<typename Traits::iterator_type&>(*this));

    static const bool isReverseIterator = mpl::is_base_of<detail::impl::ReverseIterator, typename Traits::tag>::value;

    if(isReverseIterator)
    {
        ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 259, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getNextElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };
    }
    else
    {
        ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 263, __PRETTY_FUNCTION__)); if(this->m_pCurrentNode != this->m_pHead) { this->m_pCurrentNode = this->m_iterable->getPrevElem(this->m_pCurrentNode); while(this->m_pCurrentNode != this->m_pHead) { if(this->m_filter == null_ptr || this->m_filter.eval(this->m_iterable->getValue(this->m_pCurrentNode))) { break; } this->m_pCurrentNode = this->m_iterable->getPrevElem(this->m_pCurrentNode); } } else { this->m_pCurrentNode = this->m_pCurrentNode; };
    }

    return res;
}



template<typename Traits>
typename cRandomAccessIteratorImpl<Traits>::difference_type cRandomAccessIteratorImpl<Traits>::operator-(const cRandomAccessIteratorImpl<Traits>& other) const
{
    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 274, __PRETTY_FUNCTION__));
    ((this->m_iterable == other.m_iterable && "You must compare iterators from the same iterable") ? static_cast<void> (0) : __assert_fail ("this->m_iterable == other.m_iterable && \"You must compare iterators from the same iterable\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 275, __PRETTY_FUNCTION__));

    return this->m_iterable->getIndexOfNode(this->m_pCurrentNode) - this->m_iterable->getIndexOfNode(other.m_pCurrentNode);
}
template<typename Traits>
typename cRandomAccessIteratorImpl<Traits>::iterator_type cRandomAccessIteratorImpl<Traits>::operator-(u32 index) const
{
    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 282, __PRETTY_FUNCTION__));

    typename Traits::iterator_type res(*this);

    res.setCurrentNode(this->m_iterable->shiftNodeByIndex(res.m_pCurrentNode,-index));

    return res;
}
template<typename Traits>
typename cRandomAccessIteratorImpl<Traits>::iterator_type& cRandomAccessIteratorImpl<Traits>::operator-=(u32 index) const
{
    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 293, __PRETTY_FUNCTION__));

    this->setCurrentNode(this->m_iterable->shiftNodeByIndex(this->m_pCurrentNode,-index));

    return static_cast<typename Traits::iterator_type&>(*this);
}
template<typename Traits>
typename cRandomAccessIteratorImpl<Traits>::iterator_type cRandomAccessIteratorImpl<Traits>::operator+(u32 index) const
{
    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 302, __PRETTY_FUNCTION__));

    typename Traits::iterator_type res(*this);

    res.setCurrentNode(this->m_iterable->shiftNodeByIndex(res.m_pCurrentNode,index));

    return res;
}
template<typename Traits>
typename cRandomAccessIteratorImpl<Traits>::iterator_type& cRandomAccessIteratorImpl<Traits>::operator+=(u32 index) const
{
    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 313, __PRETTY_FUNCTION__));

    this->setCurrentNode(this->m_iterable->shiftNodeByIndex(this->m_pCurrentNode,index));

    return static_cast<typename Traits::iterator_type&>(*this);
}
template<typename Traits>
typename cRandomAccessIteratorImpl<Traits>::reference cRandomAccessIteratorImpl<Traits>::operator[](size_t index)
{
    ((this->m_iterable && "Unconsisent situation") ? static_cast<void> (0) : __assert_fail ("this->m_iterable && \"Unconsisent situation\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterator.tpp", 322, __PRETTY_FUNCTION__));

    return this->m_iterable->getValue(this->m_iterable->shiftNodeByIndex(this->m_pCurrentNode,index));
}
template<typename Traits>
bool cRandomAccessIteratorImpl<Traits>::operator<(const cRandomAccessIteratorImpl<Traits>& other) const
{
    return (other - *this) < 0;
}
template<typename Traits>
bool cRandomAccessIteratorImpl<Traits>::operator>(const cRandomAccessIteratorImpl<Traits>& other) const
{
    return (other - *this) > 0;
}
template<typename Traits>
bool cRandomAccessIteratorImpl<Traits>::operator<=(const cRandomAccessIteratorImpl<Traits>& other) const
{
    return (other - *this) <= 0;
}
template<typename Traits>
bool cRandomAccessIteratorImpl<Traits>::operator>=(const cRandomAccessIteratorImpl<Traits>& other) const
{
    return (other - *this) >= 0;
}

}
}
}
}
# 420 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterator.h" 2
# 19 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterableBase.h" 2

namespace yame
{
namespace mpl
{
template<typename T>
struct AddType
{
    typedef typename static_if<is_copy_constructible<T>::value, typename add_reference<typename add_constness<T>::type>::type, typename add_rreference<T>::type>::type type;
};
}

namespace container
{
namespace detail
{


template<typename Iterator>
class cConstIterableBase
{
public:
    typedef Iterator iterator_type;
    typedef typename iterator_type::const_iterator_type const_iterator_type;
    typedef typename iterator_type::raw_type raw_type;
    typedef typename iterator_type::value_type value_type;
    typedef typename iterator_type::pointer_type pointer_type;
    typedef typename iterator_type::reference reference;
    typedef typename iterator_type::const_reference const_reference;
    static const bool is_const = true;

    virtual ~cConstIterableBase() = default;
    virtual iterator_type begin(const ytl::function<bool(const_reference)>& filter = null_ptr) = 0;
    virtual iterator_type end() = 0;
    virtual const_iterator_type cbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) const = 0;
    virtual const_iterator_type cend() const = 0;
    virtual size_t getSize() const = 0;
    virtual bool empty() const = 0;
};

template<typename Iterator>
class cIterableBase : virtual public cConstIterableBase<Iterator>
{
public:
    typedef typename cConstIterableBase<Iterator>::iterator_type iterator_type;
    typedef typename cConstIterableBase<Iterator>::const_iterator_type const_iterator_type;
    typedef typename cConstIterableBase<Iterator>::raw_type raw_type;
    typedef typename cConstIterableBase<Iterator>::value_type value_type;
    typedef typename cConstIterableBase<Iterator>::pointer_type pointer_type;
    typedef typename cConstIterableBase<Iterator>::reference reference;
    typedef typename cConstIterableBase<Iterator>::const_reference const_reference;
    typedef typename mpl::AddType<value_type>::type add_type;
    static const bool is_const = false;

    using cConstIterableBase<Iterator>::begin;
    using cConstIterableBase<Iterator>::end;
    using cConstIterableBase<Iterator>::cbegin;
    using cConstIterableBase<Iterator>::cend;
    using cConstIterableBase<Iterator>::getSize;
    using cConstIterableBase<Iterator>::empty;

    virtual iterator_type erase(iterator_type i_it) = 0;
    virtual iterator_type add(add_type i_value) = 0;
};

template<typename Iterator, typename ReverseIterator>
class cConstReversableIterableInterface : virtual public cConstIterableBase<Iterator>
{
public:
    typedef ReverseIterator reverse_iterator_type;
    typedef typename ReverseIterator::const_iterator_type const_reverse_iterator_type;
    typedef typename cConstIterableBase<Iterator>::iterator_type iterator_type;
    typedef typename cConstIterableBase<Iterator>::const_iterator_type const_iterator_type;
    typedef typename cConstIterableBase<Iterator>::raw_type raw_type;
    typedef typename cConstIterableBase<Iterator>::value_type value_type;
    typedef typename cConstIterableBase<Iterator>::pointer_type pointer_type;
    typedef typename cConstIterableBase<Iterator>::reference reference;
    typedef typename cConstIterableBase<Iterator>::const_reference const_reference;

    using cConstIterableBase<Iterator>::begin;
    using cConstIterableBase<Iterator>::end;
    using cConstIterableBase<Iterator>::cbegin;
    using cConstIterableBase<Iterator>::cend;
    using cConstIterableBase<Iterator>::getSize;
    using cConstIterableBase<Iterator>::empty;

    virtual reverse_iterator_type rbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) = 0;
    virtual reverse_iterator_type rend() = 0;
    virtual const_reverse_iterator_type crbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) const = 0;
    virtual const_reverse_iterator_type crend() const = 0;
};

template<typename Iterator, typename ReverseIterator>
class cReversableIterableInterface : public cConstReversableIterableInterface<Iterator,ReverseIterator>, virtual public cIterableBase<Iterator>
{
public:
    typedef typename cConstReversableIterableInterface<Iterator,ReverseIterator>::reverse_iterator_type reverse_iterator_type;
    typedef typename cConstReversableIterableInterface<Iterator,ReverseIterator>::const_reverse_iterator_type const_reverse_iterator_type;
    typedef typename cConstReversableIterableInterface<Iterator,ReverseIterator>::iterator_type iterator_type;
    typedef typename cConstReversableIterableInterface<Iterator,ReverseIterator>::const_iterator_type const_iterator_type;
    typedef typename cConstReversableIterableInterface<Iterator,ReverseIterator>::raw_type raw_type;
    typedef typename cConstReversableIterableInterface<Iterator,ReverseIterator>::value_type value_type;
    typedef typename cConstReversableIterableInterface<Iterator,ReverseIterator>::pointer_type pointer_type;
    typedef typename cConstReversableIterableInterface<Iterator,ReverseIterator>::reference reference;
    typedef typename cConstReversableIterableInterface<Iterator,ReverseIterator>::const_reference const_reference;
    typedef typename cIterableBase<Iterator>::add_type add_type;

    using cConstReversableIterableInterface<Iterator,ReverseIterator>::begin;
    using cConstReversableIterableInterface<Iterator,ReverseIterator>::end;
    using cConstReversableIterableInterface<Iterator,ReverseIterator>::cbegin;
    using cConstReversableIterableInterface<Iterator,ReverseIterator>::cend;
    using cConstReversableIterableInterface<Iterator,ReverseIterator>::getSize;
    using cConstReversableIterableInterface<Iterator,ReverseIterator>::empty;
    using cIterableBase<Iterator>::add;
    using cIterableBase<Iterator>::erase;

    virtual reverse_iterator_type rbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) = 0;
    virtual reverse_iterator_type rend() = 0;
    virtual const_reverse_iterator_type crbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) const = 0;
    virtual const_reverse_iterator_type crend() const = 0;
};

}




template<typename T>
using cConstInputIterable = detail::cConstIterableBase<detail::cInputIterator<T>>;
template<typename T>
using cConstOutputIterable = detail::cConstIterableBase<detail::cOutputIterator<T>>;
template<typename T>
using cConstForwardIterable = detail::cConstIterableBase<detail::impl::cAgnosticForwardIterator<T,detail::cForwardIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::deduceCategoryFromType<T>::category>>,detail::deduceCategoryFromType<T>::category>>;
template<typename T>
using cConstBidirectionalIterable = detail::cConstReversableIterableInterface<detail::impl::cAgnosticBidirectionalIterator<T,detail::cBidirectionalIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::deduceCategoryFromType<T>::category>>,detail::deduceCategoryFromType<T>::category>,detail::cReverseBidirectionalIterator<T>>;
template<typename T>
using cConstRandomAccessIterable = detail::cConstReversableIterableInterface<detail::impl::cAgnosticRandomAccessIterator<T,detail::cRandomAccessIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::deduceCategoryFromType<T>::category>>,detail::deduceCategoryFromType<T>::category>,detail::cReverseRandomAccessIterator<T>>;


template<typename T>
using cInputIterable = detail::cIterableBase<detail::cInputIterator<T>>;
template<typename T>
using cOutputIterable = detail::cIterableBase<detail::cOutputIterator<T>>;
template<typename T>
using cForwardIterable = detail::cIterableBase<detail::impl::cAgnosticForwardIterator<T,detail::cForwardIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::deduceCategoryFromType<T>::category>>,detail::deduceCategoryFromType<T>::category>>;
template<typename T>
using cBidirectionalIterable = detail::cReversableIterableInterface<detail::impl::cAgnosticBidirectionalIterator<T,detail::cBidirectionalIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::deduceCategoryFromType<T>::category>>,detail::deduceCategoryFromType<T>::category>,detail::cReverseBidirectionalIterator<T>>;
template<typename T>
using cRandomAccessIterable = detail::cReversableIterableInterface<detail::impl::cAgnosticRandomAccessIterator<T,detail::cRandomAccessIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::deduceCategoryFromType<T>::category>>,detail::deduceCategoryFromType<T>::category>,detail::cReverseRandomAccessIterator<T>>;


namespace detail
{

template<typename To,typename From>
inline To sendNodeToIterator(From i_from);
template<typename To,typename From>
inline To receiveNodeFromIterator(From i_from);


template<typename Traits>
class cIterableBasePrivate
{
public:
    typedef typename Traits::raw_type raw_type;
    typedef typename Traits::value_type value_type;
    typedef typename Traits::pointer_type pointer_type;
    typedef typename Traits::reference reference;
    typedef typename Traits::const_reference const_reference;
    static const ReferenceCategory category = Traits::category;

    virtual ~cIterableBasePrivate() = default;
    virtual pointer_type getFirstElem() const = 0;
    virtual pointer_type getNextElem(pointer_type currNode) const = 0;
    virtual void releaseNode(pointer_type i_node) const = 0;
    virtual pointer_type acquireNode(pointer_type i_node) const = 0;
    virtual reference getValue(pointer_type currNode) const = 0;
};

template<typename Traits>
class cInputIterableBasePrivate : public cIterableBasePrivate<Traits>
{
public:
    typedef typename cIterableBasePrivate<Traits>::raw_type raw_type;
    typedef typename cIterableBasePrivate<Traits>::value_type value_type;
    typedef typename cIterableBasePrivate<Traits>::pointer_type pointer_type;
    typedef typename cIterableBasePrivate<Traits>::reference reference;
    typedef typename cIterableBasePrivate<Traits>::const_reference const_reference;
    static const ReferenceCategory category = cIterableBasePrivate<Traits>::category;
};

template<typename Traits>
class cOutputIterableBasePrivate : public cIterableBasePrivate<Traits>
{
public:
    typedef typename cIterableBasePrivate<Traits>::raw_type raw_type;
    typedef typename cIterableBasePrivate<Traits>::value_type value_type;
    typedef typename cIterableBasePrivate<Traits>::pointer_type pointer_type;
    typedef typename cIterableBasePrivate<Traits>::reference reference;
    typedef typename cIterableBasePrivate<Traits>::const_reference const_reference;

    virtual void setValue(pointer_type node, const value_type& value) const = 0;
};

template<typename Traits>
class cForwardIterableBasePrivate : public cInputIterableBasePrivate<Traits>
{
public:
    typedef typename cInputIterableBasePrivate<Traits>::raw_type raw_type;
    typedef typename cInputIterableBasePrivate<Traits>::value_type value_type;
    typedef typename cInputIterableBasePrivate<Traits>::pointer_type pointer_type;
    typedef typename cInputIterableBasePrivate<Traits>::reference reference;
    typedef typename cInputIterableBasePrivate<Traits>::const_reference const_reference;
    static const ReferenceCategory category = cInputIterableBasePrivate<Traits>::category;
};

template<typename Traits>
class cBidirectionalIterableBasePrivate : public cForwardIterableBasePrivate<Traits>
{
public:
    typedef typename cForwardIterableBasePrivate<Traits>::raw_type raw_type;
    typedef typename cForwardIterableBasePrivate<Traits>::value_type value_type;
    typedef typename cForwardIterableBasePrivate<Traits>::pointer_type pointer_type;
    typedef typename cForwardIterableBasePrivate<Traits>::reference reference;
    typedef typename cForwardIterableBasePrivate<Traits>::const_reference const_reference;
    static const ReferenceCategory category = cForwardIterableBasePrivate<Traits>::category;

    virtual pointer_type getPrevElem(pointer_type currNode) const = 0;
    virtual pointer_type getLastElem() const = 0;
};

template<typename Traits>
class cRandomAccessIterableBasePrivate : public cBidirectionalIterableBasePrivate<Traits>
{
public:
    typedef typename cBidirectionalIterableBasePrivate<Traits>::raw_type raw_type;
    typedef typename cBidirectionalIterableBasePrivate<Traits>::value_type value_type;
    typedef typename cBidirectionalIterableBasePrivate<Traits>::pointer_type pointer_type;
    typedef typename cBidirectionalIterableBasePrivate<Traits>::reference reference;
    typedef typename cBidirectionalIterableBasePrivate<Traits>::const_reference const_reference;
    static const ReferenceCategory category = cBidirectionalIterableBasePrivate<Traits>::category;

    virtual size_t getIndexOfNode(pointer_type node) const = 0;
    virtual pointer_type shiftNodeByIndex(pointer_type node, int val) const = 0;
};


template<typename ValueType, typename PrivateInterface, typename PublicInterface, typename Iterator>
class cConstIterableBaseImpl : protected PrivateInterface, public PublicInterface
{
    template<typename,typename>
    friend class cConstIterableImpl;
    template<size_t,typename,size_t>
    friend class cIterableImplBackEnd;

public:
    typedef PrivateInterface iterable_private_interface;
    typedef PublicInterface iterable_public_interface;
    typedef typename Iterator::raw_type raw_type;
    typedef typename Iterator::value_type value_type;
    typedef typename Iterator::pointer_type pointer_type;
    typedef typename Iterator::reference reference;
    typedef typename Iterator::const_reference const_reference;
    typedef typename Iterator::iterator_type iterator_type;
    typedef typename Iterator::const_iterator_type const_iterator_type;


    cConstIterableBaseImpl() = default;
    cConstIterableBaseImpl(const cConstIterableBaseImpl&) = delete;


    iterator_type begin(const ytl::function<bool(const_reference)>& filter = null_ptr) override;
    iterator_type end() override;
    const_iterator_type cbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) const override;
    const_iterator_type cend() const override;

    size_t getSize() const override;
    bool empty() const override;
    reference getValue(pointer_type currNode) const override;
    static inline pointer_type getHead();

protected:
    typedef typename mpl::add_pointer<ValueType>::type value_pointer_type;


    inline void setRootNode(value_pointer_type i_newRoot);
    inline iterator_type constructIteratorAtNode(pointer_type i_node, const ytl::function<bool(const_reference)>& filter = null_ptr) const;
    inline const_iterator_type constructConstIteratorAtNode(pointer_type i_node, const ytl::function<bool(const_reference)>& filter = null_ptr) const;
    pointer_type acquireNode(pointer_type i_node) const override;
    void releaseNode(pointer_type i_node) const override;


    inline value_pointer_type getRootNode() const;
    inline pointer_type getCurrentNode(const iterator_type& i_it);
    inline pointer_type getCurrentNode(const const_iterator_type& i_it) const;
    template<typename T>
    inline typename mpl::add_pointer<T>::type getTypedRootNode() const;
    template<typename T>
    inline typename mpl::add_pointer<T>::type getTypedCurrentNode(const iterator_type& i_it);
    template<typename T>
    inline typename mpl::add_pointer<T>::type getTypedCurrentNode(const const_iterator_type& i_it) const;

protected:
    static value_pointer_type const m_pHead;
    value_pointer_type m_pRoot = m_pHead;
};

template<typename PointerType, typename AddType>
class cNonConstIterableInterface
{
public:
 virtual void eraseNode(PointerType) = 0;
 virtual PointerType addNode(AddType) = 0;
};


template<typename ValueType, typename PrivateInterface, typename PublicInterface, typename Iterator>
class cIterableBaseImpl : public cNonConstIterableInterface<typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::pointer_type, typename PublicInterface::add_type>, public cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>
{
    template<template <typename> class Iterable, typename Traits>
    friend class cIterable;

public:
    typedef typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::iterable_private_interface iterable_private_interface;
    typedef typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::iterable_public_interface iterable_public_interface;
    typedef typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::raw_type raw_type;
    typedef typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::value_type value_type;
    typedef typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::pointer_type pointer_type;
    typedef typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::reference reference;
    typedef typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::const_reference const_reference;
    typedef typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::iterator_type iterator_type;
    typedef typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::const_iterator_type const_iterator_type;
    typedef typename PublicInterface::add_type add_type;

    cIterableBaseImpl() = default;
    cIterableBaseImpl(const cIterableBaseImpl&) = delete;

    iterator_type erase(iterator_type i_it) override;
    iterator_type add(add_type i_value) override;
};

template<typename ValueType, typename PrivateInterface, typename PublicInterface, typename Iterator, template<typename,typename,typename,typename> class Base>
class cReversableBaseIterableImpl : public Base<ValueType,PrivateInterface,PublicInterface,Iterator>
{
public:
    typedef typename PublicInterface::reverse_iterator_type reverse_iterator_type;
    typedef typename PublicInterface::const_reverse_iterator_type const_reverse_iterator_type;
    typedef typename Base<ValueType,PrivateInterface,PublicInterface,Iterator>::iterable_private_interface iterable_private_interface;
    typedef typename Base<ValueType,PrivateInterface,PublicInterface,Iterator>::iterable_public_interface iterable_public_interface;
    typedef typename Base<ValueType,PrivateInterface,PublicInterface,Iterator>::raw_type raw_type;
    typedef typename Base<ValueType,PrivateInterface,PublicInterface,Iterator>::value_type value_type;
    typedef typename Base<ValueType,PrivateInterface,PublicInterface,Iterator>::pointer_type pointer_type;
    typedef typename Base<ValueType,PrivateInterface,PublicInterface,Iterator>::reference reference;
    typedef typename Base<ValueType,PrivateInterface,PublicInterface,Iterator>::const_reference const_reference;
    typedef typename Base<ValueType,PrivateInterface,PublicInterface,Iterator>::iterator_type iterator_type;
    typedef typename Base<ValueType,PrivateInterface,PublicInterface,Iterator>::const_iterator_type const_iterator_type;

    reverse_iterator_type rbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) override;
    reverse_iterator_type rend() override;
    const_reverse_iterator_type crbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) const override;
    const_reverse_iterator_type crend() const override;
};




template<typename ValueType, typename ViewType = ValueType>
using cConstInputIterableBaseImpl = cConstIterableBaseImpl<ValueType,cInputIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,ReferenceCategory::ConstReference>>,cConstInputIterable<ViewType>,detail::cInputIterator<ViewType>>;
template<typename ValueType, typename ViewType = ValueType>
using cConstOutputIterableBaseImpl = cConstIterableBaseImpl<ValueType,cOutputIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,ReferenceCategory::NonConstReference>>,cConstOutputIterable<ViewType>,detail::cOutputIterator<ViewType>>;
template<typename ValueType, typename ViewType = ValueType>
using cConstForwardIterableBaseImpl = cConstIterableBaseImpl<ValueType,cForwardIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,cConstForwardIterable<ViewType>,detail::impl::cAgnosticForwardIterator<ViewType,cForwardIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,detail::deduceCategoryFromType<ViewType>::category>>;
template<typename ValueType, typename ViewType = ValueType>
using cConstBidirectionalIterableBaseImpl = cReversableBaseIterableImpl<ValueType,cBidirectionalIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,cConstBidirectionalIterable<ViewType>,detail::impl::cAgnosticBidirectionalIterator<ViewType,cBidirectionalIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,detail::deduceCategoryFromType<ViewType>::category>,cConstIterableBaseImpl>;
template<typename ValueType, typename ViewType = ValueType>
using cConstRandomAccessIterableBaseImpl = cReversableBaseIterableImpl<ValueType,cRandomAccessIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,cConstRandomAccessIterable<ViewType>,detail::impl::cAgnosticRandomAccessIterator<ViewType,cRandomAccessIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,detail::deduceCategoryFromType<ViewType>::category>,cConstIterableBaseImpl>;


template<typename ValueType, typename ViewType = ValueType>
using cInputIterableBaseImpl = cIterableBaseImpl<ValueType,cInputIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,ReferenceCategory::ConstReference>>,cInputIterable<ViewType>,detail::cInputIterator<ViewType>>;
template<typename ValueType, typename ViewType = ValueType>
using cOutputIterableBaseImpl = cIterableBaseImpl<ValueType,cOutputIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,ReferenceCategory::NonConstReference>>,cOutputIterable<ViewType>, detail::cOutputIterator<ViewType>>;
template<typename ValueType, typename ViewType = ValueType>
using cForwardIterableBaseImpl = cIterableBaseImpl<ValueType,cForwardIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,cForwardIterable<ViewType>,detail::impl::cAgnosticForwardIterator<ViewType,cForwardIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,detail::deduceCategoryFromType<ViewType>::category>>;
template<typename ValueType, typename ViewType = ValueType>
using cBidirectionalIterableBaseImpl = cReversableBaseIterableImpl<ValueType,cBidirectionalIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,cBidirectionalIterable<ViewType>,detail::impl::cAgnosticBidirectionalIterator<ViewType,cBidirectionalIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,detail::deduceCategoryFromType<ViewType>::category>,cIterableBaseImpl>;
template<typename ValueType, typename ViewType = ValueType>
using cRandomAccessIterableBaseImpl = cReversableBaseIterableImpl<ValueType,cRandomAccessIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,cRandomAccessIterable<ViewType>,detail::impl::cAgnosticRandomAccessIterator<ViewType,cRandomAccessIterableBasePrivate<impl::AgnosticIteratorTraits<ViewType,detail::deduceCategoryFromType<ViewType>::category>>,detail::deduceCategoryFromType<ViewType>::category>,cIterableBaseImpl>;


template<typename T>
using cInputIterablePrivate = detail::cInputIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::ReferenceCategory::ConstReference>>;
template<typename T>
using cOutputIterablePrivate = detail::cOutputIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::ReferenceCategory::NonConstReference>>;
template<typename T>
using cForwardIterablePrivate = detail::cForwardIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::deduceCategoryFromType<T>::category>>;
template<typename T>
using cBidirectionalIterablePrivate = detail::cBidirectionalIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::deduceCategoryFromType<T>::category>>;
template<typename T>
using cRandomAccessIterablePrivate = detail::cRandomAccessIterableBasePrivate<detail::impl::AgnosticIteratorTraits<T,detail::deduceCategoryFromType<T>::category>>;

}
}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableBase.tpp" 1


namespace yame
{
namespace container
{
namespace detail
{

template<typename To,typename From>
To sendNodeToIterator(From i_from)
{
    return reinterpret_cast<To>(i_from);
}
template<typename To,typename From>
To receiveNodeFromIterator(From i_from)
{
    return reinterpret_cast<To>(i_from);
}

template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::value_pointer_type const cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::m_pHead = reinterpret_cast<value_pointer_type const>(0xc1c1);

template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
void cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::setRootNode(value_pointer_type i_newRoot)
{
    m_pRoot = i_newRoot;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::value_pointer_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::getRootNode() const
{
    return m_pRoot;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
template<typename T>
typename mpl::add_pointer<T>::type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::getTypedRootNode() const
{
    return (m_pRoot) ? static_cast<typename mpl::add_pointer<T>::type>(m_pRoot) : static_cast<T*>(iterator_type::m_pHead);
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
size_t cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::getSize() const
{
    size_t size = 0;
    pointer_type currNode = this->getFirstElem();

    while(currNode != iterator_type::m_pHead)
    {
        size++;
        currNode = this->getNextElem(currNode);
    }

    return size;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
bool cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::empty() const
{
    return m_pRoot == reinterpret_cast<value_pointer_type>(iterator_type::m_pHead);
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::reference cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::getValue(pointer_type currNode) const
{
    return *currNode;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::iterator_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::begin(const ytl::function<bool(const_reference)>& filter)
{
    iterator_type res(*this, filter);

    pointer_type currNode = this->getFirstElem();

    if(filter != null_ptr)
    {
        while(currNode != iterator_type::m_pHead && filter.eval(*currNode) == false)
        {
            currNode = this->getNextElem(currNode);
        }
    }

    res.setCurrentNode(currNode);

    return res;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::iterator_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::end()
{
    iterator_type res(*this);

    res.setCurrentNode(iterator_type::m_pHead);

    return res;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::const_iterator_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::cbegin(const ytl::function<bool(const_reference)>& filter) const
{
    const_iterator_type res(*this,filter);

    pointer_type currNode = this->getFirstElem();

    if(filter != null_ptr)
    {
        while(currNode != iterator_type::m_pHead && filter.eval(*currNode) == false)
        {
            currNode = this->getNextElem(currNode);
        }
    }

    res.setCurrentNode(currNode);

    return res;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::const_iterator_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::cend() const
{
    const_iterator_type res(*this);

    res.setCurrentNode(iterator_type::m_pHead);

    return res;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::pointer_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::getHead()
{
    return iterator_type::m_pHead;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::iterator_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::constructIteratorAtNode(pointer_type i_node, const ytl::function<bool(const_reference)>& filter) const
{
    iterator_type res(*this, filter);

    res.setCurrentNode(i_node);

    return res;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::const_iterator_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::constructConstIteratorAtNode(pointer_type i_node, const ytl::function<bool(const_reference)>& filter) const
{
    const_iterator_type res(*this,filter);

    res.setCurrentNode(i_node);

    return res;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::pointer_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::acquireNode(pointer_type i_node) const
{
    return i_node;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
void cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::releaseNode(pointer_type i_node) const
{

}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::pointer_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::getCurrentNode(const iterator_type& i_it)
{
    return i_it.getCurrentNode();
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::pointer_type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::getCurrentNode(const const_iterator_type& i_it) const
{
    return i_it.getCurrentNode();
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
template<typename T>
typename mpl::add_pointer<T>::type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::getTypedCurrentNode(const iterator_type& i_it)
{
    return reinterpret_cast<typename mpl::add_pointer<T>::type>(i_it.getCurrentNode());
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
template<typename T>
typename mpl::add_pointer<T>::type cConstIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::getTypedCurrentNode(const const_iterator_type& i_it) const
{
    return reinterpret_cast<typename mpl::add_pointer<T>::type>(i_it.getCurrentNode());
}

template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::iterator_type cIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::erase(iterator_type i_it)
{
    iterator_type it(*this);

    pointer_type currNode = i_it.getCurrentNode();

    if(currNode != iterator_type::m_pHead)
    {
        pointer_type nextNode = this->getNextElem(currNode);
        this->eraseNode(currNode);

        it.setCurrentNode(nextNode);
    }

    return it;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator>
typename cIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::iterator_type cIterableBaseImpl<ValueType,PrivateInterface,PublicInterface,Iterator>::add(add_type i_value)
{
    pointer_type newNode = this->addNode(mpl::forward<add_type>(i_value));

    iterator_type it(*this);

    it.setCurrentNode(newNode);

    return it;
}

template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator, template<typename,typename,typename,typename> class Base>
typename cReversableBaseIterableImpl<ValueType,PrivateInterface,PublicInterface,Iterator,Base>::reverse_iterator_type cReversableBaseIterableImpl<ValueType,PrivateInterface,PublicInterface,Iterator,Base>::rbegin(const ytl::function<bool(const_reference)>& filter)
{
    reverse_iterator_type res(*this, filter);

    pointer_type currNode = this->getLastElem();

    if(filter != null_ptr)
    {
        while(currNode != iterator_type::m_pHead && filter.eval(*currNode) == false)
        {
            currNode = this->getPrevElem(currNode);
        }
    }

    res.setCurrentNode(currNode);

    return res;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator, template<typename,typename,typename,typename> class Base>
typename cReversableBaseIterableImpl<ValueType,PrivateInterface,PublicInterface,Iterator,Base>::reverse_iterator_type cReversableBaseIterableImpl<ValueType,PrivateInterface,PublicInterface,Iterator,Base>::rend()
{
    reverse_iterator_type res(*this);

    return res;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator, template<typename,typename,typename,typename> class Base>
typename cReversableBaseIterableImpl<ValueType,PrivateInterface,PublicInterface,Iterator,Base>::const_reverse_iterator_type cReversableBaseIterableImpl<ValueType,PrivateInterface,PublicInterface,Iterator,Base>::crbegin(const ytl::function<bool(const_reference)>& filter) const
{
    const_reverse_iterator_type res(*this,filter);

    pointer_type currNode = this->getLastElem();

    if(filter != null_ptr)
    {
        while(currNode != iterator_type::m_pHead && filter.eval(*currNode) == false)
        {
            currNode = this->getPrevElem(currNode);
        }
    }

    res.setCurrentNode(currNode);

    return res;
}
template<typename ValueType,typename PrivateInterface, typename PublicInterface, typename Iterator, template<typename,typename,typename,typename> class Base>
typename cReversableBaseIterableImpl<ValueType,PrivateInterface,PublicInterface,Iterator,Base>::const_reverse_iterator_type cReversableBaseIterableImpl<ValueType,PrivateInterface,PublicInterface,Iterator,Base>::crend() const
{
    const_reverse_iterator_type res(*this);

    return res;
}

}
}
}
# 424 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterableBase.h" 2
# 27 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cArray.h" 2


namespace yame
{
namespace container
{

template<typename Container>
class cWritableContainer;

template<typename T, typename A = memory::cTypedSystemAllocator<T> >
class cArray : public detail::cRandomAccessIterableBaseImpl<T,T&>
{
    static_assert(mpl::is_const<T>::value == false && mpl::is_reference<T>::value == false, "Const/ reference types are not supported");

public:
    typedef typename detail::cRandomAccessIterableBaseImpl<T,T&>::iterator_type iterator_type;
    typedef typename detail::cRandomAccessIterableBaseImpl<T,T&>::const_iterator_type const_iterator_type;
    typedef typename detail::cRandomAccessIterableBaseImpl<T,T&>::reverse_iterator_type reverse_iterator_type;
    typedef typename detail::cRandomAccessIterableBaseImpl<T,T&>::const_reverse_iterator_type const_reverse_iterator_type;
    typedef typename detail::cRandomAccessIterableBaseImpl<T,T&>::iterable_public_interface iterable_public_interface;
    typedef typename detail::cConstRandomAccessIterableBaseImpl<T,T&>::iterable_public_interface const_iterable_public_interface;
    typedef typename detail::cRandomAccessIterableBaseImpl<T,T&>::pointer_type pointer_type;
    typedef typename detail::cRandomAccessIterableBaseImpl<T,T&>::add_type add_type;
    static const detail::ReferenceCategory category = iterator_type::category;
    typedef typename mpl::drop_reference<T>::type& lreference;
    typedef const typename mpl::drop_reference<T>::type& const_lreference;
    typedef typename mpl::drop_reference<T>::type&& rreference;
    typedef typename mpl::drop_reference<T>::type value_type;
    typedef T particle;
    static const size_t npos=-1;

    using detail::cRandomAccessIterableBaseImpl<T,T&>::begin;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::end;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::rbegin;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::rend;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::cbegin;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::cend;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::crbegin;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::crend;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::getSize;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::empty;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::add;
    using detail::cRandomAccessIterableBaseImpl<T,T&>::erase;

    cArray();
    cArray(const cArray& other);
    cArray(cArray&& other);
    cArray(const std::initializer_list<T>& i_initList);
    cArray(const_lreference value, u32 length=1);
    cArray(rreference value, u32 length=1);
    cArray(const value_type* data, u32 length);
    cArray(const std::vector<T>& other);
    virtual ~cArray();
    cArray& operator=(const cArray& other);
    cArray& operator=(cArray&& other);
    cArray<T,A> operator+(const cArray<T,A>& other) const;
    cArray<T,A>& operator+=(const cArray<T,A>& other);
    virtual const_lreference operator[](const u32 index) const;
    virtual lreference operator[](const u32 index);
    virtual lreference at(const u32 index);
    virtual bool operator==(const cArray& other) const;
    virtual bool operator!=(const cArray& other) const;
    cArray subArr(const u32 initPos, const u32 length) const;
    const value_type* getArray() const;
    value_type* getArray();
    void reset(T value=0);
    void reset(const T& value);
    void reset(T&& value=0);
    inline void insert(const_iterator_type itPos, const_iterator_type itOtherInit, const_iterator_type itOtherEnd);
    template<typename ... TT>
    inline lreference insert(const_iterator_type itPos, TT&& ... i_args);
    template<typename ... TT>
    lreference push_back(TT&& ... i_args);
    template<typename ... TT>
    lreference push_front(TT&& ... i_args);
    lreference front();
    lreference back();
    inline const_lreference front() const;
    inline const_lreference back() const;
    void resize(u32 size);
    void pop();
    void clear();
    iterator_type erase(u32 initPos, u32 length=1);
    size_t getCapacity() const;
    size_t getSize() const override;
    void reserve(u32 newCap);
    cArray<s16> find(const cArray<T>& other) const;
    s16 find_first_of(const_lreference other) const;
    s16 find_last_of(const_lreference other) const;
    void replace(u32 prevPos, u32 newPos);
    static cArray<cArray<T> > tokenize(cArray<T> stream, value_type separator);
    cArray<cArray<T> > tokenize(value_type separator) const;
    static bool equal(const cArray& arrayA, const cArray& arrayB);
    bool equal(const cArray& other) const;
    static u32 copyBlock(const value_type* source, value_type* dest, u32 numBits, u8 offset, u8 endianess);

protected:
    virtual value_type* acquireMem(size_t size);
    virtual void releaseMem(value_type* node);
    inline value_type* allocate(size_t size);
    inline value_type* reallocate(value_type* ptr, size_t oldSize, size_t newSize);
    inline void deallocate(value_type* node, bool destroy=true);
    virtual bool isInBounds(const value_type* address) const;
    inline void construct(const value_type* address);
    template<typename TT, typename ... TTs>
    inline void construct(const value_type* address, TT&& i_arg, TTs&& ... i_args);
    inline void destruct(value_type* initAddress, value_type* addressEnd);
    template<typename TT>
    inline void assign(TT&& val, value_type* address);
    template<typename ... TT>
    inline lreference _insert(u32 pos, TT&& ... other);
    inline value_type* getAddressAtIndex(size_t index) const;


    pointer_type getFirstElem() const override;
    pointer_type getLastElem() const override;
    pointer_type getNextElem(pointer_type currNode) const override;
    pointer_type getPrevElem(pointer_type currNode) const override;
    pointer_type shiftNodeByIndex(pointer_type node, int index) const override;
    size_t getIndexOfNode(pointer_type node) const override;


    void eraseNode(pointer_type i_valueNode) override;
    pointer_type addNode(add_type i_value) override;

    size_t m_capacity;
    const A& m_alloc;
    size_t m_size;
};

typedef cArray<c8> arrayC8;
typedef cArray<u8> arrayU8;
typedef cArray<u16> arrayU16;
typedef cArray<u32> arrayU32;
typedef cArray<f32> arrayF32;
typedef cArray<f64> arrayF64;
typedef cArray<s8> arrayS8;
typedef cArray<s16> arrayS16;
typedef cArray<s32> arrayS32;

}
}

template<typename T, typename A>
yame::container::cArray<T,A>& operator<<(yame::container::cArray<T,A>& o_array, const yame::container::cArray<T,A>& i_array);
template<typename T, typename A>
yame::container::cArray<T,A>& operator>>(const yame::container::cArray<T,A>& i_array, yame::container::cArray<T,A>& o_array);
template<typename T, typename A>
yame::container::cArray<T,A>& operator<<(yame::container::cArray<T,A>& o_array, const typename yame::container::cArray<T,A>::particle& i_value);
template<typename T, typename A>
yame::container::cArray<T,A>& operator>>(const typename yame::container::cArray<T,A>::particle& i_value, yame::container::cArray<T,A>& o_array);

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp" 1

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cAlgorithm.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cAlgorithm.h"
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterable.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterable.h"
       


# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cPair.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cPair.h"
       



namespace yame
{
namespace container
{
template<typename T, typename R>
class cPair
{
private:
    template<typename>
    struct isPair;

    template<typename TT,typename RR>
    struct isPair<cPair<TT,RR>>
    {
        static const bool value = true;
    };
    template<typename TT>
    struct isPair
    {
        static const bool value = false;
    };

public:
    typedef T first_type;
    typedef R second_type;
    typedef typename mpl::add_reference<T>::type first_type_reference;
    typedef typename mpl::add_reference<R>::type second_type_reference;

    cPair<T,R>();
    template<typename TFirst>
    cPair<T,R>(TFirst&& i_first, typename mpl::enable_if<isPair<typename mpl::drop_constness<typename mpl::drop_reference<typename mpl::drop_pointer<TFirst>::type>::type>::type>::value == false>::type* foo = __null);
    template<typename TFirst, typename TSecond, typename ... TSeconds>
    cPair<T,R>(TFirst&& i_first, TSecond&& i_arg, TSeconds&& ... i_args);
    cPair<T,R>(const cPair<T,R>& other);
    virtual ~cPair<T,R>();
    cPair<T,R>& operator=(const cPair<T,R>& other);
    cPair<T,R>& operator=(cPair<T,R>&& other);
    bool operator==(const cPair<T,R>& other) const;

private:
    first_type m_first;
    second_type m_second;

public:
    first_type_reference first;
    second_type_reference second;
};

typedef cPair<s32,s32> cRange;


template<typename T, typename R>
inline cPair<T,R> make_pair(T i_first, R i_second);

}

namespace mpl
{

template<typename T, typename R>
struct is_copy_constructible<container::cPair<T,R>>
{
    static const bool value = is_copy_constructible<T>::value && is_copy_constructible<R>::value;
};

template<typename>
struct AddType;

template<typename T, typename R>
struct AddType<container::cPair<T,R>>
{
    typedef typename drop_reference<T>::type rawT;
    typedef typename drop_reference<R>::type rawR;
    typedef typename static_if<is_copy_constructible<container::cPair<T,R>>::value, typename add_reference<typename add_constness<container::cPair<rawT,rawR>>::type>::type, typename add_rreference<container::cPair<rawT,rawR>>::type>::type type;
};

template<typename T, typename R>
struct PairType
{
    typedef typename drop_reference<T>::type rawT;
    typedef typename drop_reference<R>::type rawR;
    typedef typename static_if<is_copy_constructible<rawT>::value, typename add_reference<typename add_constness<rawT>::type>::type, typename add_rreference<rawT>::type>::type first_type;
    typedef typename static_if<is_copy_constructible<rawR>::value, typename add_reference<typename add_constness<rawR>::type>::type, typename add_rreference<rawR>::type>::type second_type;
    typedef typename static_if<is_copy_constructible<container::cPair<T,R>>::value, typename add_reference<typename add_constness<container::cPair<rawT,rawR>>::type>::type, typename add_rreference<container::cPair<rawT,rawR>>::type>::type type;
};

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cPair.tpp" 1

namespace yame
{
namespace container
{
template<typename T, typename R>
cPair<T,R>::cPair()
: m_first(T())
, m_second(R())
, first(m_first)
, second(m_second)
{
}
template<typename T, typename R>
template<typename TFirst>
cPair<T,R>::cPair(TFirst&& i_first, typename mpl::enable_if<isPair<typename mpl::drop_constness<typename mpl::drop_reference<typename mpl::drop_pointer<TFirst>::type>::type>::type>::value == false>::type* foo)
: m_first(mpl::forward<TFirst>(i_first))
, m_second(R())
, first(m_first)
, second(m_second)
{
}
template<typename T, typename R>
template<typename TFirst, typename TSecond, typename ... TSeconds>
cPair<T,R>::cPair(TFirst&& i_first, TSecond&& i_arg, TSeconds&& ... i_args)
: m_first(mpl::forward<TFirst>(i_first))
, m_second(mpl::forward<TSecond>(i_arg), mpl::forward<TSeconds>(i_args)...)
, first(m_first)
, second(m_second)
{
}
template<typename T, typename R>
cPair<T,R>::cPair(const cPair<T,R>& other)
: m_first(other.m_first)
, m_second(other.m_second)
, first(m_first)
, second(m_second)
{
}
template<typename T, typename R>
cPair<T,R>::~cPair()
{
}
template<typename T, typename R>
cPair<T,R>& cPair<T,R>::operator=(const cPair<T,R>& other)
{
    m_first = other.m_first;
    m_second = other.m_second;

    return *this;
}
template<typename T, typename R>
cPair<T,R>& cPair<T,R>::operator=(cPair<T,R>&& other)
{
    m_first = mpl::move(other.m_first);
    m_second = mpl::move(other.m_second);

    return *this;
}
template<typename T, typename R>
bool cPair<T,R>::operator==(const cPair<T,R>& other) const
{
    return (m_first == other.m_first) && (m_second == other.m_second);
}


template<typename T, typename R>
cPair<T,R> make_pair(T i_first, R i_second)
{
    return cPair<T,R>(mpl::forward<T>(i_first), mpl::forward<R>(i_second));
}

}
}
# 108 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cPair.h" 2
# 19 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterable.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImpl.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImpl.h"
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cMemoryPool.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cMemoryPool.h"
       
# 24 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/System/memory/cMemoryPool.h"
namespace yame
{
namespace memory
{

class IMemoryProvider;

class cMemoryPool

: private cMemoryTracker

{
    friend class cMemoryMgr;

public:
    typedef cMemoryPool allocator;

    void* allocate(size_t numUnits, size_t unitSize) const;
    void deallocate(void *ptr) const;
    void *reallocate(void *ptr, size_t numUnits, size_t unitSize) const;

protected:
    cMemoryPool(size_t maxNumChunks, unsigned char unitSizeBitPos, IMemoryProvider& i_memProvider);
    cMemoryPool(const cMemoryPool&) = delete;
    cMemoryPool(cMemoryPool&&) = delete;
    ~cMemoryPool();

private:
    struct cMemoryBank
    {
        cMemoryBank(void* i_ref, size_t i_maxNumChunks, size_t i_unitSizeBitPos);
        cMemoryBank(const cMemoryBank&) = delete;
        cMemoryBank(cMemoryBank&&);
        ~cMemoryBank();

        size_t m_nextFreeChunk;
        void* m_pRef;
        size_t* m_mem_bufctl;
    };

    size_t m_unitSizeBitPos;
    size_t m_maxNumChunks;
    IMemoryProvider& m_memoryProvider;
    mutable std::vector<cMemoryBank> m_memoryBankArr;
    mutable std::vector<size_t> m_memoryBankPointer;
    mutable size_t m_currMemoryBank;
};

template<typename T>
class cTypedMemoryPool : public cMemoryPool
{
    friend class cMemoryMgr;

public:
    typedef cMemoryPool allocator;

    using cMemoryPool::allocate;
    using cMemoryPool::deallocate;
    using cMemoryPool::reallocate;

private:
    cTypedMemoryPool(size_t maxNumChunks, IMemoryProvider& i_memProvider);
};

}
}
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImpl.h" 2


# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImplBackEnd.h" 1
       



namespace yame
{
namespace container
{
namespace detail
{

template<typename Iterable>
class cIterableImplBackEndInterface
{
public:
    virtual ~cIterableImplBackEndInterface() = default;
    virtual const Iterable& getPrivateIterable() const = 0;
};

template<typename Iterable>
class cForwardIterableImplBackEndInterface : virtual public cIterableImplBackEndInterface<Iterable>
{
public:
    virtual const cForwardIterableImplBackEndInterface* getNextIterable() const = 0;
};

template<typename Iterable>
class cBidirectionalIterableImplBackEndInterface : virtual public cIterableImplBackEndInterface<Iterable>
{
public:
    virtual const cBidirectionalIterableImplBackEndInterface* getNextIterable() const = 0;
    virtual const cBidirectionalIterableImplBackEndInterface* getPrevIterable() const = 0;
};

template<typename IterableBackEnd, typename Traits>
class cForwardIterableImplBackEnd : virtual public cForwardIterableImplBackEndInterface<typename Traits::iterable_private_interface>
{
public:
    typedef typename Traits::iterable_private_interface iterable_private_interface;
    typedef cForwardIterableImplBackEndInterface<typename Traits::iterable_private_interface> nested_iterable_interface;

    cForwardIterableImplBackEnd() = default;
    cForwardIterableImplBackEnd(const nested_iterable_interface& prevIterable);
private:
    const nested_iterable_interface* getNextIterable() const override;
    template<typename T>
    inline const nested_iterable_interface* _getNextIterable(const T* iterableBackEnd, decltype(&T::m_nestedIterable) foo = __null) const;
    inline const nested_iterable_interface* _getNextIterable(...) const;
};

template<typename IterableBackEnd, typename Traits>
class cBidirectionalIterableImplBackEnd : public cBidirectionalIterableImplBackEndInterface<typename Traits::iterable_private_interface>
{
public:
    typedef typename Traits::iterable_private_interface iterable_private_interface;
    typedef cBidirectionalIterableImplBackEndInterface<typename Traits::iterable_private_interface> nested_iterable_interface;

    cBidirectionalIterableImplBackEnd() = default;
    cBidirectionalIterableImplBackEnd(const nested_iterable_interface& prevIterable);

private:
    const nested_iterable_interface* getNextIterable() const override;
    const nested_iterable_interface* getPrevIterable() const override;
    template<typename T>
    inline const nested_iterable_interface* _getNextIterable(const T* iterableBackEnd, decltype(&T::m_nestedIterable) foo = __null) const;
    inline const nested_iterable_interface* _getNextIterable(...) const;

    const nested_iterable_interface* m_prevIterable = __null;
};

template<size_t numIterables, typename Traits, size_t IterablePos>
class cIterableImplBackEnd;

template<size_t NumIterables, typename Traits>
class cIterableImplBackEnd<NumIterables,Traits,0> : public mpl::static_if<mpl::is_base_of<impl::BidirectionalIteratorTag,typename Traits::iterator_type>::value,cBidirectionalIterableImplBackEnd<cIterableImplBackEnd<NumIterables,Traits,0>,Traits>,cForwardIterableImplBackEnd<cIterableImplBackEnd<NumIterables,Traits,0>,Traits>>::type
{
    typedef typename mpl::static_if<mpl::is_base_of<impl::BidirectionalIteratorTag,typename Traits::iterator_type>::value,cBidirectionalIterableImplBackEnd<cIterableImplBackEnd<NumIterables,Traits,0>,Traits>,cForwardIterableImplBackEnd<cIterableImplBackEnd<NumIterables,Traits,0>,Traits>>::type backend_base;
    friend backend_base;
protected:
 typedef typename Traits::iterable_private_interface iterable_private_interface;
 typedef typename Traits::forwarded_iterable_private_interface forwarded_iterable_private_interface;
    typedef typename Traits::iterator_type iterator_type;
    typedef typename Traits::const_iterator_type const_iterator_type;
    typedef typename Traits::forwarded_iterator_type forwarded_iterator_type;
    typedef typename Traits::const_forwarded_iterator_type const_forwarded_iterator_type;
 typedef typename Traits::value_type value_type;
 typedef typename Traits::forwarded_type forwarded_type;
 typedef typename Traits::forwarded_reference forwarded_reference;
 typedef typename Traits::const_forwarded_reference const_forwarded_reference;
    typedef typename backend_base::nested_iterable_interface nested_iterable_interface;

public:
    static const size_t iterable_pos = 0;
    static const size_t num_iterables = NumIterables;

    cIterableImplBackEnd(const iterable_private_interface& i_iterable);
    cIterableImplBackEnd(const nested_iterable_interface& i_prevIterable, const iterable_private_interface& i_iterable);
    template<int IterablePosition>
    inline const nested_iterable_interface& getNthIterable() const;

private:
    const iterable_private_interface& getPrivateIterable() const override;

    const iterable_private_interface& m_privateIterable;
};

template<size_t NumIterables, typename Traits, size_t IterablePos>
class cIterableImplBackEnd : public mpl::static_if<mpl::is_base_of<impl::BidirectionalIteratorTag,typename Traits::iterator_type>::value,cBidirectionalIterableImplBackEnd<cIterableImplBackEnd<NumIterables,Traits,IterablePos>,Traits>,cForwardIterableImplBackEnd<cIterableImplBackEnd<NumIterables,Traits,IterablePos>,Traits>>::type
{
    typedef typename mpl::static_if<mpl::is_base_of<impl::BidirectionalIteratorTag,typename Traits::iterator_type>::value,cBidirectionalIterableImplBackEnd<cIterableImplBackEnd<NumIterables,Traits,IterablePos>,Traits>,cForwardIterableImplBackEnd<cIterableImplBackEnd<NumIterables,Traits,IterablePos>,Traits>>::type backend_base;
    friend backend_base;
protected:
 typedef typename Traits::iterable_private_interface iterable_private_interface;
 typedef typename Traits::forwarded_iterable_private_interface forwarded_iterable_private_interface;
    typedef typename Traits::iterator_type iterator_type;
    typedef typename Traits::const_iterator_type const_iterator_type;
    typedef typename Traits::forwarded_iterator_type forwarded_iterator_type;
    typedef typename Traits::const_forwarded_iterator_type const_forwarded_iterator_type;
 typedef typename Traits::value_type value_type;
 typedef typename Traits::forwarded_type forwarded_type;
 typedef typename Traits::forwarded_reference forwarded_reference;
 typedef typename Traits::const_forwarded_reference const_forwarded_reference;
    typedef typename backend_base::nested_iterable_interface nested_iterable_interface;

public:
    static const size_t iterable_pos = IterablePos;
    static const size_t num_iterables = NumIterables;

    template<typename ... Types>
    cIterableImplBackEnd(const iterable_private_interface& i_privateIterable, Types&& ... i_privateIterables);
    template<typename ... Types>
    cIterableImplBackEnd(const nested_iterable_interface& i_prevIterable, const iterable_private_interface& i_privateIterable, Types&& ... i_privateIterables);
    template<int IterablePosition>
    inline const nested_iterable_interface& getNthIterable() const;

private:
    const iterable_private_interface& getPrivateIterable() const override;

    const iterable_private_interface& m_privateIterable;
    cIterableImplBackEnd<NumIterables,Traits,IterablePos-1> m_nestedIterable;
};

}
}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImplBackEnd.tpp" 1

namespace yame
{
namespace container
{
namespace detail
{

template<typename IterableBackEnd,typename Traits>
cForwardIterableImplBackEnd<IterableBackEnd,Traits>::cForwardIterableImplBackEnd(const nested_iterable_interface& prevIterable)
{
}
template<typename IterableBackEnd,typename Traits>
template<typename T>
const typename cForwardIterableImplBackEnd<IterableBackEnd,Traits>::nested_iterable_interface* cForwardIterableImplBackEnd<IterableBackEnd,Traits>::_getNextIterable(const T* iterableBackEnd, decltype(&T::m_nestedIterable) foo) const
{
    return &iterableBackEnd->m_nestedIterable;
}
template<typename IterableBackEnd,typename Traits>
const typename cForwardIterableImplBackEnd<IterableBackEnd,Traits>::nested_iterable_interface* cForwardIterableImplBackEnd<IterableBackEnd,Traits>::_getNextIterable(...) const
{
    return __null;
}
template<typename IterableBackEnd,typename Traits>
const typename cForwardIterableImplBackEnd<IterableBackEnd,Traits>::nested_iterable_interface* cForwardIterableImplBackEnd<IterableBackEnd,Traits>::getNextIterable() const
{
    return _getNextIterable(static_cast<const IterableBackEnd*>(this));
}

template<typename IterableBackEnd,typename Traits>
cBidirectionalIterableImplBackEnd<IterableBackEnd,Traits>::cBidirectionalIterableImplBackEnd(const nested_iterable_interface& i_prevIterable)
: m_prevIterable(&i_prevIterable)
{
}
template<typename IterableBackEnd,typename Traits>
template<typename T>
const typename cBidirectionalIterableImplBackEnd<IterableBackEnd,Traits>::nested_iterable_interface* cBidirectionalIterableImplBackEnd<IterableBackEnd,Traits>::_getNextIterable(const T* iterableBackEnd, decltype(&T::m_nestedIterable) foo) const
{
    return &iterableBackEnd->m_nestedIterable;
}
template<typename IterableBackEnd,typename Traits>
const typename cBidirectionalIterableImplBackEnd<IterableBackEnd,Traits>::nested_iterable_interface* cBidirectionalIterableImplBackEnd<IterableBackEnd,Traits>::_getNextIterable(...) const
{
    return __null;
}
template<typename IterableBackEnd,typename Traits>
const typename cBidirectionalIterableImplBackEnd<IterableBackEnd,Traits>::nested_iterable_interface* cBidirectionalIterableImplBackEnd<IterableBackEnd,Traits>::getNextIterable() const
{
    return _getNextIterable(static_cast<const IterableBackEnd*>(this));
}
template<typename IterableBackEnd,typename Traits>
const typename cBidirectionalIterableImplBackEnd<IterableBackEnd,Traits>::nested_iterable_interface* cBidirectionalIterableImplBackEnd<IterableBackEnd,Traits>::getPrevIterable() const
{
    return m_prevIterable;
}

template<size_t NumIterables, typename Traits>
cIterableImplBackEnd<NumIterables,Traits,0>::cIterableImplBackEnd(const iterable_private_interface& i_iterable)
: backend_base()
, m_privateIterable(i_iterable)
{
}
template<size_t NumIterables, typename Traits>
cIterableImplBackEnd<NumIterables,Traits,0>::cIterableImplBackEnd(const nested_iterable_interface& i_prevIterable, const iterable_private_interface& i_iterable)
: backend_base(i_prevIterable)
, m_privateIterable(i_iterable)
{
}
template<size_t NumIterables, typename Traits>
const typename Traits::iterable_private_interface& cIterableImplBackEnd<NumIterables,Traits,0>::getPrivateIterable() const
{
    return m_privateIterable;
}
template<size_t NumIterables, typename Traits>
template<int IterablePosition>
const typename cIterableImplBackEnd<NumIterables,Traits,0>::nested_iterable_interface& cIterableImplBackEnd<NumIterables,Traits,0>::getNthIterable() const
{
    static_assert(IterablePosition==0,"Index out of bounds");

    return *this;
}

template<size_t NumIterables, typename Traits, size_t IterablePos>
template<typename ... IterableTypes>
cIterableImplBackEnd<NumIterables,Traits,IterablePos>::cIterableImplBackEnd(const iterable_private_interface& i_privateIterable, IterableTypes&& ... i_privateIterables)
: backend_base()
, m_privateIterable(i_privateIterable)
, m_nestedIterable(*this,mpl::forward<IterableTypes>(i_privateIterables)...)
{
}
template<size_t NumIterables, typename Traits, size_t IterablePos>
template<typename ... IterableTypes>
cIterableImplBackEnd<NumIterables,Traits,IterablePos>::cIterableImplBackEnd(const nested_iterable_interface& i_prevIterable, const iterable_private_interface& i_privateIterable, IterableTypes&& ... i_privateIterables)
: backend_base(i_prevIterable)
, m_privateIterable(i_privateIterable)
, m_nestedIterable(*this,mpl::forward<IterableTypes>(i_privateIterables)...)
{
}
template<size_t NumIterables, typename Traits, size_t IterablePos>
const typename cIterableImplBackEnd<NumIterables,Traits,IterablePos>::iterable_private_interface& cIterableImplBackEnd<NumIterables,Traits,IterablePos>::getPrivateIterable() const
{
    return m_privateIterable;
}
template<size_t NumIterables, typename Traits, size_t IterablePos>
template<int IterablePosition>
const typename cIterableImplBackEnd<NumIterables,Traits,IterablePos>::nested_iterable_interface& cIterableImplBackEnd<NumIterables,Traits,IterablePos>::getNthIterable() const
{
    if(IterablePosition == 0)
    {
        return *this;
    }
    else
    {
        return m_nestedIterable.template getNthIterable<IterablePosition-1>();
    }
}

}
}
}
# 147 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImplBackEnd.h" 2
# 21 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImpl.h" 2

namespace yame
{
namespace container
{
namespace detail
{

extern const memory::cMemoryPool& k_pairAllocator;

template<typename,typename>
class cConstIterableImpl;

template<typename Traits, int ... indexs>
class cConstIterableImpl<Traits,mpl::sequence<indexs...>> : public cIterableImplBackEnd<Traits::numIterables,Traits,Traits::numIterables-1>, protected Traits::forwarded_iterable_private_interface, public Traits::forwarded_iterable_public_interface
{
    template<typename,typename>
    friend class cConstIterableImpl;

    template<typename,typename...>
    struct iterable_circular_dep_compliant;

    template<typename Foo>
    struct iterable_circular_dep_compliant<Foo>
    {
        static bool checkCircularDep(const typename Traits::forwarded_iterable_private_interface& thisObject)
        {
            return false;
        }
    };

    template<typename Foo, typename Iterable,typename ... Iterables>
    struct iterable_circular_dep_compliant<Foo,Iterable,Iterables...>
    {
        static bool checkCircularDep(const typename Traits::forwarded_iterable_private_interface& thisObject, const Iterable& i_iterable, const Iterables& ... i_iterables)
        {
            return static_cast<const void *>(&thisObject) == static_cast<const void*>(&i_iterable) || iterable_circular_dep_compliant<Foo,Iterables...>::checkCircularDep(thisObject, i_iterables...);
        }
    };

    template<typename,typename...>
    struct iterable_iterator_compliant;

    template<typename Foo>
    struct iterable_iterator_compliant<Foo>
    {
        static const bool value = true;
    };

    template<typename Foo, typename Iterator,typename ... Iterators>
    struct iterable_iterator_compliant<Foo,Iterator,Iterators...>
    {
        static const bool value = mpl::is_base_of<typename Traits::iterator_type, Iterator>::value
                                    && iterable_iterator_compliant<Foo,Iterators...>::value;
    };

    template<typename Foo,ReferenceCategory...>
    struct iterable_category_compliant;

    template<typename Foo>
    struct iterable_category_compliant<Foo>
    {
        static const bool value = true;
    };

    template<typename Foo,ReferenceCategory category,ReferenceCategory ... categories>
    struct iterable_category_compliant<Foo,category,categories...>
    {
        static const bool value = (Traits::forwarded_category == ReferenceCategory::Value ||
                                    (Traits::forwarded_category == ReferenceCategory::ConstReference && category != ReferenceCategory::Value) ||
                                    (Traits::forwarded_category == ReferenceCategory::NonConstReference && category == ReferenceCategory::NonConstReference))
                                    && iterable_category_compliant<Foo,categories...>::value;
    };

    template<typename Foo,typename ... Iterables>
    struct iterable_constness_compliant;

    template<typename Foo>
    struct iterable_constness_compliant<Foo>
    {
        static const bool value = true;
    };

    template<typename Foo,typename Iterable,typename ... Iterables>
    struct iterable_constness_compliant<Foo,Iterable,Iterables...>
    {
        static const bool value = (Traits::iterable_public_interface::is_const == true || Iterable::is_const == false)
                                    && iterable_constness_compliant<Foo,Iterables...>::value;
    };

protected:
 typedef typename Traits::iterable_private_interface iterable_private_interface;
 typedef typename Traits::forwarded_iterable_private_interface forwarded_iterable_private_interface;
 typedef typename Traits::iterable_public_interface iterable_public_interface;
 typedef typename Traits::forwarded_iterable_public_interface forwarded_iterable_public_interface;
    typedef typename Traits::iterator_type iterator_type;
    typedef typename Traits::const_iterator_type const_iterator_type;
    typedef typename Traits::forwarded_iterator_type forwarded_iterator_type;
    typedef typename Traits::const_forwarded_iterator_type const_forwarded_iterator_type;
 typedef typename Traits::value_type value_type;
 typedef typename Traits::pointer_type pointer_type;
 typedef typename Traits::forwarded_type forwarded_type;
 typedef typename Traits::forwarded_pointer_type forwarded_pointer_type;
 typedef typename Traits::forwarded_reference forwarded_reference;
 typedef typename Traits::const_forwarded_reference const_forwarded_reference;

public:
    template<typename ... Iterables>
    cConstIterableImpl(const Iterables& ... i_privateIterables);


    forwarded_iterator_type begin(const ytl::function<bool(const_forwarded_reference)>& filter = null_ptr) override;
    forwarded_iterator_type end() override;
    const_forwarded_iterator_type cbegin(const ytl::function<bool(const_forwarded_reference)>& filter = null_ptr) const override;
    const_forwarded_iterator_type cend() const override;
    size_t getSize() const override;
    bool empty() const override;

protected:
    typedef typename cIterableImplBackEnd<Traits::numIterables,Traits,Traits::numIterables-1>::nested_iterable_interface nested_iterable_interface;

    struct pair_node
    {
        const nested_iterable_interface* backendInterface;
        pointer_type innerNode;

        pair_node(const nested_iterable_interface* _backendInterface, pointer_type _innerNode) : backendInterface(_backendInterface), innerNode(_innerNode){}
    };


    inline static forwarded_pointer_type createPair(const nested_iterable_interface* i_interface, pointer_type i_pointer);
    inline static void deletePair(pair_node* i_pointer);

    forwarded_pointer_type getFirstElem() const override;
    forwarded_pointer_type getNextElem(forwarded_pointer_type currNode) const override;
    forwarded_pointer_type acquireNode(forwarded_pointer_type i_node) const override;
    void releaseNode(forwarded_pointer_type i_node) const override;
    virtual pointer_type getNextElemInCurrentIterable(const nested_iterable_interface* currIterableBackEnd, pointer_type currNode) const;
};

template<typename Traits, typename Sequence>
class cConstIterableWithTransformImpl;

template<typename Traits, int ... indexs>
class cConstIterableWithTransformImpl<Traits,mpl::sequence<indexs...>> : public cConstIterableImpl<Traits,mpl::sequence<indexs...>>
{
protected:
 typedef typename Traits::forwarded_iterable_private_interface forwarded_iterable_private_interface;
 typedef typename Traits::iterable_public_interface iterable_public_interface;
 typedef typename Traits::forwarded_iterable_public_interface forwarded_iterable_public_interface;
    typedef typename Traits::iterator_type iterator_type;
    typedef typename Traits::const_iterator_type const_iterator_type;
    typedef typename Traits::forwarded_iterator_type forwarded_iterator_type;
    typedef typename Traits::const_forwarded_iterator_type const_forwarded_iterator_type;
 typedef typename Traits::raw_type raw_type;
 typedef typename Traits::value_type value_type;
 typedef typename Traits::forwarded_raw_type forwarded_raw_type;
 typedef typename Traits::forwarded_type forwarded_type;
 typedef typename Traits::pointer_type pointer_type;
 typedef typename Traits::forwarded_pointer_type forwarded_pointer_type;
 typedef typename Traits::forwarded_reference forwarded_reference;
 typedef typename Traits::const_forwarded_reference const_forwarded_reference;
 typedef typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::pair_node pair_node;
    typedef typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::nested_iterable_interface nested_iterable_interface;

    using cConstIterableImpl<Traits,mpl::sequence<indexs...>>::createPair;
    using cConstIterableImpl<Traits,mpl::sequence<indexs...>>::deletePair;

public:
 typedef typename Traits::iterable_private_interface iterable_private_interface;

    template<typename ... IterablesAndFunction>
    cConstIterableWithTransformImpl(const IterablesAndFunction& ... i_values);

protected:
    forwarded_reference getValue(forwarded_pointer_type currNode) const override;

private:
    ytl::function<forwarded_raw_type(raw_type)> m_transform;
};

template<typename Traits>
class cConstIterableWithoutTransformImpl : public cConstIterableImpl<Traits,typename mpl::create_range_rank<0,Traits::numIterables>::type>
{
protected:
 typedef typename Traits::iterable_private_interface iterable_private_interface;
 typedef typename Traits::forwarded_iterable_private_interface forwarded_iterable_private_interface;
 typedef typename Traits::iterable_public_interface iterable_public_interface;
 typedef typename Traits::forwarded_iterable_public_interface forwarded_iterable_public_interface;
    typedef typename Traits::iterator_type iterator_type;
    typedef typename Traits::const_iterator_type const_iterator_type;
    typedef typename Traits::forwarded_iterator_type forwarded_iterator_type;
    typedef typename Traits::const_forwarded_iterator_type const_forwarded_iterator_type;
 typedef typename Traits::value_type value_type;
 typedef typename Traits::forwarded_type forwarded_type;
 typedef typename Traits::pointer_type pointer_type;
 typedef typename Traits::forwarded_pointer_type forwarded_pointer_type;
 typedef typename Traits::forwarded_reference forwarded_reference;
 typedef typename Traits::const_forwarded_reference const_forwarded_reference;
 typedef typename cConstIterableImpl<Traits,typename mpl::create_range_rank<0,Traits::numIterables>::type>::pair_node pair_node;

    using cConstIterableImpl<Traits,typename mpl::create_range_rank<0,Traits::numIterables>::type>::createPair;
    using cConstIterableImpl<Traits,typename mpl::create_range_rank<0,Traits::numIterables>::type>::deletePair;

public:
    using cConstIterableImpl<Traits,typename mpl::create_range_rank<0,Traits::numIterables>::type>::cConstIterableImpl;

protected:
    typedef typename cConstIterableImpl<Traits,typename mpl::create_range_rank<0,Traits::numIterables>::type>::nested_iterable_interface nested_iterable_interface;

    forwarded_reference getValue(forwarded_pointer_type currNode) const override;
};

template<typename Traits>
class cInputIterableImpl : public mpl::static_if<mpl::is_same_type<typename Traits::raw_type,typename Traits::forwarded_raw_type>::value,cConstIterableWithoutTransformImpl<Traits>,cConstIterableWithTransformImpl<Traits, typename mpl::create_range_rank<0,Traits::numIterables>::type>>::type
{
protected:
    typedef typename mpl::static_if<mpl::is_same_type<typename Traits::raw_type,typename Traits::forwarded_raw_type>::value,cConstIterableWithoutTransformImpl<Traits>,cConstIterableWithTransformImpl<Traits, typename mpl::create_range_rank<0,Traits::numIterables>::type>>::type base_type;
    typedef typename Traits::forwarded_iterable_public_interface iterable_public_interface;
 typedef typename base_type::pair_node pair_node;

    using base_type::createPair;
    using base_type::deletePair;

public:
    typedef typename base_type::forwarded_iterator_type iterator_type;
    typedef typename base_type::const_forwarded_iterator_type const_iterator_type;
 typedef typename base_type::forwarded_type value_type;
 typedef typename base_type::forwarded_pointer_type pointer_type;
 typedef typename base_type::forwarded_reference reference;
 typedef typename base_type::const_forwarded_reference const_reference;

    using base_type::base_type;
    using base_type::begin;
    using base_type::end;
    using base_type::cbegin;
    using base_type::cend;
    using base_type::getSize;
    using base_type::empty;
};

template<typename Traits>
class cOutputIterableImpl : public cConstIterableWithoutTransformImpl<Traits>
{
protected:
 typedef typename Traits::value_type inner_value_type;
 typedef typename Traits::pointer_type inner_pointer_type;
 typedef typename Traits::reference inner_reference;
 typedef typename Traits::const_reference const_inner_reference;
    typedef typename Traits::forwarded_iterable_public_interface iterable_public_interface;
 typedef typename cConstIterableWithoutTransformImpl<Traits>::pair_node pair_node;

    using cConstIterableWithoutTransformImpl<Traits>::createPair;
    using cConstIterableWithoutTransformImpl<Traits>::deletePair;

public:
    typedef typename cConstIterableWithoutTransformImpl<Traits>::forwarded_iterator_type iterator_type;
    typedef typename cConstIterableWithoutTransformImpl<Traits>::const_forwarded_iterator_type const_iterator_type;
 typedef typename cConstIterableWithoutTransformImpl<Traits>::forwarded_type value_type;
 typedef typename cConstIterableWithoutTransformImpl<Traits>::forwarded_pointer_type pointer_type;
 typedef typename cConstIterableWithoutTransformImpl<Traits>::forwarded_reference reference;
 typedef typename cConstIterableWithoutTransformImpl<Traits>::const_forwarded_reference const_reference;

    using cConstIterableWithoutTransformImpl<Traits>::cConstIterableWithoutTransformImpl;
    using cConstIterableWithoutTransformImpl<Traits>::begin;
    using cConstIterableWithoutTransformImpl<Traits>::end;
    using cConstIterableWithoutTransformImpl<Traits>::cbegin;
    using cConstIterableWithoutTransformImpl<Traits>::cend;
    using cConstIterableWithoutTransformImpl<Traits>::getSize;
    using cConstIterableWithoutTransformImpl<Traits>::empty;

protected:
    typedef typename cConstIterableWithoutTransformImpl<Traits>::nested_iterable_interface nested_iterable_interface;

    void setValue(pointer_type i_valueNode, const value_type& i_value) const override;
};

template<typename Traits>
using cForwardIterableImpl = cInputIterableImpl<Traits>;

template<typename Traits>
class cBidirectionalIterableImpl : public cForwardIterableImpl<Traits>
{
protected:
 typedef typename Traits::value_type inner_value_type;
 typedef typename Traits::pointer_type inner_pointer_type;
 typedef typename Traits::reference inner_reference;
 typedef typename Traits::const_reference const_inner_reference;
    typedef typename Traits::iterator_type inner_iterator_type;
    typedef typename Traits::const_iterator_type inner_const_iterator_type;
    typedef typename Traits::iterable_private_interface inner_iterable_private_interface;
    typedef typename Traits::forwarded_iterable_public_interface iterable_public_interface;
 typedef typename Traits::forwarded_pointer_type forwarded_pointer_type;
 typedef typename cForwardIterableImpl<Traits>::pair_node pair_node;
    typedef typename cForwardIterableImpl<Traits>::nested_iterable_interface nested_iterable_interface;

    using cForwardIterableImpl<Traits>::createPair;
    using cForwardIterableImpl<Traits>::deletePair;

public:
    typedef typename cForwardIterableImpl<Traits>::iterator_type iterator_type;
    typedef typename cForwardIterableImpl<Traits>::const_iterator_type const_iterator_type;
 typedef typename cForwardIterableImpl<Traits>::value_type value_type;
 typedef typename cForwardIterableImpl<Traits>::pointer_type pointer_type;
 typedef typename cForwardIterableImpl<Traits>::reference reference;
 typedef typename cForwardIterableImpl<Traits>::const_reference const_reference;
    typedef typename Traits::reverse_forwarded_iterator_type reverse_iterator_type;
    typedef typename Traits::const_reverse_forwarded_iterator_type const_reverse_iterator_type;

    using cForwardIterableImpl<Traits>::cForwardIterableImpl;
    using cForwardIterableImpl<Traits>::begin;
    using cForwardIterableImpl<Traits>::end;
    using cForwardIterableImpl<Traits>::cbegin;
    using cForwardIterableImpl<Traits>::cend;
    using cForwardIterableImpl<Traits>::getSize;
    using cForwardIterableImpl<Traits>::empty;

    reverse_iterator_type rbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) override;
    reverse_iterator_type rend() override;
    const_reverse_iterator_type crbegin(const ytl::function<bool(const_reference)>& filter = null_ptr) const override;
    const_reverse_iterator_type crend() const override;

protected:
    pointer_type getLastElem() const override;
    pointer_type getPrevElem(pointer_type currNode) const override;
    virtual inner_pointer_type getPrevElemInCurrentIterable(const nested_iterable_interface* currIterableBackEnd, inner_pointer_type currNode) const;
};

template<typename Traits>
class cRandomAccessIterableImpl : public cBidirectionalIterableImpl<Traits>
{
protected:
    typedef typename cBidirectionalIterableImpl<Traits>::nested_iterable_interface nested_iterable_interface;
 typedef typename Traits::value_type inner_value_type;
 typedef typename Traits::pointer_type inner_pointer_type;
 typedef typename Traits::reference inner_reference;
 typedef typename Traits::const_reference const_inner_reference;
    typedef typename Traits::iterator_type inner_iterator_type;
    typedef typename Traits::const_iterator_type inner_const_iterator_type;
    typedef typename Traits::iterable_private_interface inner_iterable_private_interface;
    typedef typename Traits::forwarded_iterable_public_interface iterable_public_interface;
 typedef typename cBidirectionalIterableImpl<Traits>::pair_node pair_node;

    using cBidirectionalIterableImpl<Traits>::createPair;
    using cBidirectionalIterableImpl<Traits>::deletePair;

public:
    typedef typename cBidirectionalIterableImpl<Traits>::iterator_type iterator_type;
    typedef typename cBidirectionalIterableImpl<Traits>::const_iterator_type const_iterator_type;
 typedef typename cBidirectionalIterableImpl<Traits>::value_type value_type;
 typedef typename cBidirectionalIterableImpl<Traits>::pointer_type pointer_type;
 typedef typename cBidirectionalIterableImpl<Traits>::reference reference;
 typedef typename cBidirectionalIterableImpl<Traits>::const_reference const_reference;

    using cBidirectionalIterableImpl<Traits>::cBidirectionalIterableImpl;
    using cBidirectionalIterableImpl<Traits>::begin;
    using cBidirectionalIterableImpl<Traits>::end;
    using cBidirectionalIterableImpl<Traits>::cbegin;
    using cBidirectionalIterableImpl<Traits>::cend;
    using cBidirectionalIterableImpl<Traits>::getSize;
    using cBidirectionalIterableImpl<Traits>::empty;

    size_t getIndexOfNode(pointer_type node) const override;
    pointer_type shiftNodeByIndex(pointer_type node, int val) const override;
};

}
}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImpl.tpp" 1


namespace yame
{
namespace container
{
namespace detail
{

template<typename Traits, int ... indexs>
template<typename ... Iterables>
cConstIterableImpl<Traits,mpl::sequence<indexs...>>::cConstIterableImpl(const Iterables& ... i_privateIterables)
: cIterableImplBackEnd<Traits::numIterables,Traits,Traits::numIterables-1>(static_cast<const iterable_private_interface&>(i_privateIterables) ...)
{
    static_assert(iterable_category_compliant<void, Iterables::category ...>::value, "You have to follow category rules for iterables, look .h file for more details");
    static_assert(iterable_constness_compliant<void, Iterables...>::value, "You cannot have non const iterables with const nested iterables");
    bool circularDepDetected = iterable_circular_dep_compliant<void,Iterables...>::checkCircularDep(*this, i_privateIterables...);
    ((circularDepDetected == false && "Circular dependency detected in nested iterables") ? static_cast<void> (0) : __assert_fail ("circularDepDetected == false && \"Circular dependency detected in nested iterables\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImpl.tpp", 18, __PRETTY_FUNCTION__));
}
template<typename Traits, int ... indexs>
typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::forwarded_pointer_type cConstIterableImpl<Traits,mpl::sequence<indexs...>>::createPair(const nested_iterable_interface* i_interface, pointer_type i_pointer)
{
    return reinterpret_cast<forwarded_pointer_type>((u8*)memcpy((u8*)memcpy(k_pairAllocator.allocate(1, sizeof(pair_node)),&i_interface, sizeof(i_interface)) + sizeof(i_interface),&i_pointer, sizeof(i_pointer)) - sizeof(i_interface));
}
template<typename Traits, int ... indexs>
void cConstIterableImpl<Traits,mpl::sequence<indexs...>>::deletePair(pair_node* i_pointer)
{
    k_pairAllocator.deallocate(i_pointer);
}
template<typename Traits, int ... indexs>
typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::forwarded_pointer_type cConstIterableImpl<Traits,mpl::sequence<indexs...>>::getFirstElem() const
{
    const nested_iterable_interface* firstBackend = static_cast<const nested_iterable_interface*>(this);

    pointer_type newType = firstBackend->getPrivateIterable().getFirstElem();

    return (newType != iterator_type::m_pHead) ? createPair(firstBackend,newType) : forwarded_iterator_type::m_pHead;
}
template<typename Traits, int ... indexs>
typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::pointer_type cConstIterableImpl<Traits,mpl::sequence<indexs...>>::getNextElemInCurrentIterable(const nested_iterable_interface* currIterableBackEnd, pointer_type currNode) const
{
    const iterable_private_interface& currIterable = currIterableBackEnd->getPrivateIterable();

    pointer_type nextNode = currIterable.getNextElem(currNode);

    return nextNode;
}
template<typename Traits, int ... indexs>
typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::forwarded_pointer_type cConstIterableImpl<Traits,mpl::sequence<indexs...>>::getNextElem(forwarded_pointer_type currNode) const
{
    pair_node* currPair = receiveNodeFromIterator<pair_node*>(currNode);
    const nested_iterable_interface* nextIterableBackEnd = currPair->backendInterface;
    pointer_type nextNode = getNextElemInCurrentIterable(nextIterableBackEnd, currPair->innerNode);

    while(nextIterableBackEnd && nextNode == iterator_type::m_pHead)
    {
        nextIterableBackEnd->getPrivateIterable().releaseNode(nextNode);

        nextIterableBackEnd = nextIterableBackEnd->getNextIterable();

        nextNode = (nextIterableBackEnd) ? nextIterableBackEnd->getPrivateIterable().getFirstElem() : iterator_type::m_pHead;
    }

    if(nextNode != iterator_type::m_pHead)
    {
        currPair->backendInterface = nextIterableBackEnd;
        currPair->innerNode = nextNode;

        return sendNodeToIterator<forwarded_pointer_type>(currPair);
    }
    else
    {

        deletePair(currPair);

        return forwarded_iterator_type::m_pHead;
    }
}
template<typename Traits, int ... indexs>
size_t cConstIterableImpl<Traits,mpl::sequence<indexs...>>::getSize() const
{
    size_t size = 0;
    const nested_iterable_interface* currBackend = static_cast<const nested_iterable_interface*>(this);

    while(currBackend)
    {
        const forwarded_iterable_public_interface& currPublicIterable = dynamic_cast<const forwarded_iterable_public_interface&>(currBackend->getPrivateIterable());
        size += currPublicIterable.getSize();
        currBackend = currBackend->getNextIterable();
    }

    return size;
}

template<typename Traits, int ... indexs>
bool cConstIterableImpl<Traits,mpl::sequence<indexs...>>::empty() const
{
    bool isEmpty = true;
    const nested_iterable_interface* currBackend = static_cast<const nested_iterable_interface*>(this);

    while(currBackend)
    {
        if(currBackend->getPrivateIterable().getFirstElem() != iterator_type::m_pHead)
        {
            isEmpty = false;
            break;
        }
        currBackend = currBackend->getNextIterable();
    }

    return isEmpty;
}

template<typename Traits, int ... indexs>
typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::forwarded_iterator_type cConstIterableImpl<Traits,mpl::sequence<indexs...>>::begin(const ytl::function<bool(const_forwarded_reference)>& filter)
{
    forwarded_iterator_type res(*this, filter);

    forwarded_pointer_type newNode = this->getFirstElem();

    if(filter != null_ptr)
    {
        while(newNode != forwarded_iterator_type::m_pHead && filter.eval(this->getValue(newNode)) == false)
        {
            newNode = this->getNextElem(newNode);
        }
    }

    res.setCurrentNode(newNode);

    return res;
}

template<typename Traits, int ... indexs>
typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::forwarded_iterator_type cConstIterableImpl<Traits,mpl::sequence<indexs...>>::end()
{
    forwarded_iterator_type res(*this);

    res.setCurrentNode(forwarded_iterator_type::m_pHead);

    return res;
}

template<typename Traits, int ... indexs>
typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::const_forwarded_iterator_type cConstIterableImpl<Traits,mpl::sequence<indexs...>>::cbegin(const ytl::function<bool(const_forwarded_reference)>& filter) const
{
    const_forwarded_iterator_type res(*this, filter);

    forwarded_pointer_type newNode = this->getFirstElem();

    if(filter != null_ptr)
    {
        while(newNode != forwarded_iterator_type::m_pHead && filter.eval(this->getValue(newNode)) == false)
        {
            newNode = this->getNextElem(newNode);
        }
    }

    res.setCurrentNode(newNode);

    return res;
}

template<typename Traits, int ... indexs>
typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::const_forwarded_iterator_type cConstIterableImpl<Traits,mpl::sequence<indexs...>>::cend() const
{
    const_forwarded_iterator_type res(*this);

    res.setCurrentNode(forwarded_iterator_type::m_pHead);

    return res;
}

template<typename Traits, int ... indexs>
typename cConstIterableImpl<Traits,mpl::sequence<indexs...>>::forwarded_pointer_type cConstIterableImpl<Traits,mpl::sequence<indexs...>>::acquireNode(forwarded_pointer_type i_node) const
{
    if(i_node != forwarded_iterator_type::m_pHead)
    {
        pair_node* currPair = receiveNodeFromIterator<pair_node*>(i_node);

        return createPair(currPair->backendInterface, currPair->backendInterface->getPrivateIterable().acquireNode(currPair->innerNode));
    }
    else
    {
        return i_node;
    }
}

template<typename Traits, int ... indexs>
void cConstIterableImpl<Traits,mpl::sequence<indexs...>>::releaseNode(forwarded_pointer_type i_node) const
{
    if(i_node != forwarded_iterator_type::m_pHead)
    {
        pair_node* currPair = receiveNodeFromIterator<pair_node*>(i_node);

        currPair->backendInterface->getPrivateIterable().releaseNode(currPair->innerNode);

        deletePair(currPair);
    }
}


template<typename Traits>
void cOutputIterableImpl<Traits>::setValue(pointer_type i_node, const value_type& i_value) const
{
    if(i_node != iterator_type::m_pHead)
    {
        pair_node* currPair = receiveNodeFromIterator<pair_node*>(i_node);

        currPair->backendInterface->getPrivateIterable().setValue(currPair->innerNode, value_type(i_value));
    }
}

template<typename Traits>
typename cBidirectionalIterableImpl<Traits>::reverse_iterator_type cBidirectionalIterableImpl<Traits>::rbegin(const ytl::function<bool(const_reference)>& filter)
{
    reverse_iterator_type res(*this, filter);

    forwarded_pointer_type newNode = this->getLastElem();

    if(filter != null_ptr)
    {
        while(newNode != iterator_type::m_pHead && filter.eval(this->getValue(newNode)) == false)
        {
            newNode = this->getPrevElem(newNode);
        }
    }

    res.setCurrentNode(newNode);

    return res;
}
template<typename Traits>
typename cBidirectionalIterableImpl<Traits>::reverse_iterator_type cBidirectionalIterableImpl<Traits>::rend()
{
    reverse_iterator_type res(*this);

    return res;
}
template<typename Traits>
typename cBidirectionalIterableImpl<Traits>::const_reverse_iterator_type cBidirectionalIterableImpl<Traits>::crbegin(const ytl::function<bool(const_reference)>& filter) const
{
    const_reverse_iterator_type res(*this, filter);

    forwarded_pointer_type newNode = this->getLastElem();

    if(filter != null_ptr)
    {
        while(newNode != iterator_type::m_pHead && filter.eval(this->getValue(newNode)) == false)
        {
            newNode = this->getPrevElem(newNode);
        }
    }

    res.setCurrentNode(newNode);

    return res;
}
template<typename Traits>
typename cBidirectionalIterableImpl<Traits>::const_reverse_iterator_type cBidirectionalIterableImpl<Traits>::crend() const
{
    const_reverse_iterator_type res(*this);

    return res;
}
template<typename Traits>
typename cBidirectionalIterableImpl<Traits>::pointer_type cBidirectionalIterableImpl<Traits>::getLastElem() const
{
    const nested_iterable_interface& lastBackend = this->template getNthIterable<Traits::numIterables-1>();

    return createPair(&lastBackend,lastBackend.getPrivateIterable().getLastElem());
}
template<typename Traits>
typename cBidirectionalIterableImpl<Traits>::inner_pointer_type cBidirectionalIterableImpl<Traits>::getPrevElemInCurrentIterable(const nested_iterable_interface* currIterableBackEnd, inner_pointer_type currNode) const
{
    const inner_iterable_private_interface& currIterable = currIterableBackEnd->getPrivateIterable();

    inner_pointer_type prevNode = currIterable.getPrevElem(currNode);

    return prevNode;
}
template<typename Traits>
typename cBidirectionalIterableImpl<Traits>::pointer_type cBidirectionalIterableImpl<Traits>::getPrevElem(pointer_type currNode) const
{
    pair_node* currPair = receiveNodeFromIterator<pair_node*>(currNode);
    const nested_iterable_interface* prevIterableBackEnd = currPair->backendInterface;
    inner_pointer_type prevNode = getPrevElemInCurrentIterable(prevIterableBackEnd, currPair->innerNode);

    while(prevIterableBackEnd && prevNode == inner_iterator_type::m_pHead)
    {
        prevIterableBackEnd->getPrivateIterable().releaseNode(prevNode);

        prevIterableBackEnd = prevIterableBackEnd->getPrevIterable();

        prevNode = (prevIterableBackEnd) ? prevIterableBackEnd->getPrivateIterable().getLastElem() : inner_iterator_type::m_pHead;
    }

    if(prevNode != inner_iterator_type::m_pHead)
    {
        currPair->backendInterface = prevIterableBackEnd;
        currPair->innerNode = prevNode;

        return sendNodeToIterator<pointer_type>(currPair);
    }
    else
    {

        deletePair(currPair);

        return iterator_type::m_pHead;
    }
}

template<typename Traits>
size_t cRandomAccessIterableImpl<Traits>::getIndexOfNode(pointer_type currNode) const
{
    pair_node* currPair = receiveNodeFromIterator<pair_node*>(currNode);

    const inner_iterable_private_interface& currIterable = currPair->backendInterface->getPrivateIterable();

    return currIterable.getIndexOfNode(currPair->innerNode);
}

template<typename Traits>
typename cRandomAccessIterableImpl<Traits>::pointer_type cRandomAccessIterableImpl<Traits>::shiftNodeByIndex(pointer_type node, int index) const
{
    pair_node* currPair = receiveNodeFromIterator<pair_node*>(node);

    const nested_iterable_interface* currIterableBackEnd = currPair->backendInterface;
    inner_pointer_type currNode = currPair->innerNode;
    const inner_iterable_private_interface& currIterable = currIterableBackEnd->getPrivateIterable();

    while(currIterableBackEnd)
    {
        currNode = currIterable.shiftNodeByIndex(currNode,index);

        if(currNode == inner_iterator_type::m_pHead)
        {
            currIterable.releaseNode(currNode);
            currIterableBackEnd = (index > 0) ? currIterableBackEnd->getNextIterable() : currIterableBackEnd->getPrevIterable();
            const inner_iterable_private_interface& nextIterable = currIterableBackEnd->getPrivateIterable();
            index = (index > 0) ? index - nextIterable.getIndexOfNode(currNode) : index + nextIterable.getIndexOfNode(currNode);
            currNode = (index > 0) ? nextIterable.getFirstElem() : nextIterable.getLastElem();
        }
        else
        {
            break;
        }
    }

    if(currNode != inner_iterator_type::m_pHead)
    {
        currPair->backendInterface = currIterableBackEnd;
        currPair->innerNode = currNode;

        return sendNodeToIterator<pointer_type>(currPair);
    }
    else
    {

        deletePair(currPair);

        return iterator_type::m_pHead;
    }
}



template<typename Traits>
typename cConstIterableWithoutTransformImpl<Traits>::forwarded_reference cConstIterableWithoutTransformImpl<Traits>::getValue(forwarded_pointer_type currNode) const
{
    pair_node* currPair = receiveNodeFromIterator<pair_node*>(currNode);

    const nested_iterable_interface* currIterableBackEnd = currPair->backendInterface;

    return currIterableBackEnd->getPrivateIterable().getValue(currPair->innerNode);
}



template<typename Traits, int ... indexs>
template<typename ... IterablesAndFunction>
cConstIterableWithTransformImpl<Traits,mpl::sequence<indexs...>>::cConstIterableWithTransformImpl(const IterablesAndFunction& ... i_values)
: cConstIterableImpl<Traits,mpl::sequence<indexs...>>(mpl::nth_val_of<indexs>(i_values...)...)
, m_transform(mpl::nth_val_of<mpl::get_num_ranks<indexs...>::value>(i_values...))
{}
template<typename Traits, int ... indexs>
typename cConstIterableWithTransformImpl<Traits,mpl::sequence<indexs...>>::forwarded_reference cConstIterableWithTransformImpl<Traits,mpl::sequence<indexs...>>::getValue(forwarded_pointer_type currNode) const
{
    pair_node* currPair = receiveNodeFromIterator<pair_node*>(currNode);

    const nested_iterable_interface* nextIterableBackEnd = currPair->backendInterface;

    return m_transform.eval(nextIterableBackEnd->getPrivateIterable().getValue(currPair->innerNode));
}

}
}
}
# 391 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterableImpl.h" 2
# 20 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterable.h" 2

namespace yame
{
namespace container
{
namespace detail
{

template<template <typename> class Iterable, typename Traits>
using cConstIterable = Iterable<Traits>;

template<template <typename> class Iterable, typename Traits>
class cIterable : public Iterable<Traits>
{
    typedef typename cConstIterableWithoutTransformImpl<Traits>::nested_iterable_interface nested_iterable_interface;
    typedef typename Traits::iterator_type inner_iterator_type;
    typedef typename Traits::pointer_type inner_pointer_type;
    typedef typename Traits::iterable_public_interface inner_iterable_public_interface;
    typedef typename Traits::iterable_private_interface inner_iterable_private_interface;
    typedef typename inner_iterable_public_interface::add_type add_type;
    typedef cNonConstIterableInterface<inner_pointer_type, add_type> inner_iterable;
    typedef typename Iterable<Traits>::pair_node pair_node;

public:
    typedef typename Iterable<Traits>::iterator_type iterator_type;
    typedef typename Iterable<Traits>::const_iterator_type const_iterator_type;
 typedef typename Iterable<Traits>::value_type value_type;
 typedef typename Iterable<Traits>::pointer_type pointer_type;
 typedef typename Iterable<Traits>::reference reference;
 typedef typename Iterable<Traits>::const_reference const_reference;

    using Iterable<Traits>::Iterable;
    using Iterable<Traits>::begin;
    using Iterable<Traits>::end;
    using Iterable<Traits>::cbegin;
    using Iterable<Traits>::cend;
    using Iterable<Traits>::getSize;
    using Iterable<Traits>::empty;

    iterator_type erase(iterator_type i_it) override;
    iterator_type add(add_type i_value) override;
};

template<typename T, typename TT, template<class> class IterableBasePrivateInterface, template<class> class IterableBasePublicInterface, int _numIterables>
struct IterableTraits
{
    static const ReferenceCategory category = detail::deduceCategoryFromType<T>::category;
    static const ReferenceCategory forwarded_category = detail::deduceCategoryFromType<TT>::category;
 typedef IterableBasePublicInterface<T> iterable_public_interface;
 typedef IterableBasePrivateInterface<impl::AgnosticIteratorTraits<T,category>> iterable_private_interface;
 typedef IterableBasePublicInterface<TT> forwarded_iterable_public_interface;
 typedef IterableBasePrivateInterface<impl::AgnosticIteratorTraits<TT,forwarded_category>> forwarded_iterable_private_interface;
    typedef typename iterable_public_interface::iterator_type iterator_type;
    typedef typename iterable_public_interface::const_iterator_type const_iterator_type;
    typedef typename forwarded_iterable_public_interface::iterator_type forwarded_iterator_type;
    typedef typename forwarded_iterable_public_interface::const_iterator_type const_forwarded_iterator_type;
 typedef typename iterable_public_interface::iterator_type::raw_type raw_type;
 typedef typename iterable_public_interface::iterator_type::value_type value_type;
 typedef typename iterable_public_interface::iterator_type::pointer_type pointer_type;
 typedef typename forwarded_iterable_public_interface::iterator_type::raw_type forwarded_raw_type;
 typedef typename forwarded_iterable_public_interface::iterator_type::value_type forwarded_type;
 typedef typename forwarded_iterable_public_interface::iterator_type::pointer_type forwarded_pointer_type;
 typedef typename iterable_public_interface::iterator_type::reference reference;
 typedef typename forwarded_iterable_public_interface::iterator_type::reference forwarded_reference;
 typedef typename iterable_public_interface::iterator_type::const_reference const_reference;
 typedef typename forwarded_iterable_public_interface::iterator_type::const_reference const_forwarded_reference;
    static const size_t numIterables = _numIterables;
};

template<typename T, typename TT, template<class> class IterableBasePrivateInterface, template<class> class IterableBasePublicInterface, int _numIterables>
struct ReversableIterableTraits : IterableTraits<T,TT,IterableBasePrivateInterface,IterableBasePublicInterface,_numIterables>
{
    typedef typename IterableBasePublicInterface<TT>::reverse_iterator_type reverse_forwarded_iterator_type;
    typedef typename IterableBasePublicInterface<TT>::const_reverse_iterator_type const_reverse_forwarded_iterator_type;
};

}


template<typename T, typename TT = T>
using cConstInputIntraIterable = detail::cConstIterable<detail::cInputIterableImpl,detail::IterableTraits<T,TT,detail::cInputIterableBasePrivate,cConstInputIterable,1>>;
template<typename T>
using cConstOutputIntraIterable = detail::cConstIterable<detail::cOutputIterableImpl,detail::IterableTraits<T,T,detail::cOutputIterableBasePrivate,cConstOutputIterable,1>>;
template<typename T, typename TT = T>
using cConstForwardIntraIterable = detail::cConstIterable<detail::cForwardIterableImpl,detail::IterableTraits<T,TT,detail::cForwardIterableBasePrivate,cConstForwardIterable,1>>;
template<typename T, typename TT = T>
using cConstBidirectionalIntraIterable = detail::cConstIterable<detail::cBidirectionalIterableImpl,detail::ReversableIterableTraits<T,TT,detail::cBidirectionalIterableBasePrivate,cConstBidirectionalIterable,1>>;
template<typename T, typename TT = T>
using cConstRandomAccessIntraIterable = detail::cConstIterable<detail::cRandomAccessIterableImpl,detail::ReversableIterableTraits<T,TT,detail::cRandomAccessIterableBasePrivate,cConstRandomAccessIterable,1>>;


template<typename T>
using cInputIntraIterable = detail::cIterable<detail::cInputIterableImpl,detail::IterableTraits<T,T,detail::cInputIterableBasePrivate,cInputIterable,1>>;
template<typename T>
using cOutputIntraIterable = detail::cIterable<detail::cOutputIterableImpl,detail::IterableTraits<T,T,detail::cOutputIterableBasePrivate,cOutputIterable,1>>;
template<typename T>
using cForwardIntraIterable = detail::cIterable<detail::cForwardIterableImpl,detail::IterableTraits<T,T,detail::cForwardIterableBasePrivate,cForwardIterable,1>>;
template<typename T>
using cBidirectionalIntraIterable = detail::cIterable<detail::cBidirectionalIterableImpl,detail::ReversableIterableTraits<T,T,detail::cBidirectionalIterableBasePrivate,cBidirectionalIterable,1>>;
template<typename T>
using cRandomAccessIntraIterable = detail::cIterable<detail::cRandomAccessIterableImpl,detail::ReversableIterableTraits<T,T,detail::cRandomAccessIterableBasePrivate,cRandomAccessIterable,1>>;


template<int numIterables, typename T, typename TT = T>
using cConstInputInterIterable = detail::cConstIterable<detail::cInputIterableImpl,detail::IterableTraits<T,TT,detail::cInputIterableBasePrivate,cConstInputIterable,numIterables>>;
template<int numIterables, typename T>
using cConstOutputInterIterable = detail::cConstIterable<detail::cOutputIterableImpl,detail::IterableTraits<T,T,detail::cOutputIterableBasePrivate,cConstOutputIterable,numIterables>>;
template<int numIterables, typename T, typename TT = T>
using cConstForwardInterIterable = detail::cConstIterable<detail::cForwardIterableImpl,detail::IterableTraits<T,TT,detail::cForwardIterableBasePrivate,cConstForwardIterable,numIterables>>;
template<int numIterables, typename T, typename TT = T>
using cConstBidirectionalInterIterable = detail::cConstIterable<detail::cBidirectionalIterableImpl,detail::ReversableIterableTraits<T,TT,detail::cBidirectionalIterableBasePrivate,cConstBidirectionalIterable,numIterables>>;
template<int numIterables, typename T, typename TT = T>
using cConstRandomAccessInterIterable = detail::cConstIterable<detail::cRandomAccessIterableImpl,detail::ReversableIterableTraits<T,TT,detail::cRandomAccessIterableBasePrivate,cConstRandomAccessIterable,numIterables>>;





}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cIterable.tpp" 1

namespace yame
{
namespace container
{
namespace detail
{

template<template <typename> class Iterable, typename Traits>
typename cIterable<Iterable,Traits>::iterator_type cIterable<Iterable,Traits>::erase(iterator_type i_it)
{
    pointer_type currNode = i_it.getCurrentNode();
    pair_node* currPair = reinterpret_cast<pair_node*>(const_cast<typename mpl::drop_constness<pointer_type>::type>(currNode));
    const nested_iterable_interface* firstBackend = static_cast<const cIterableImplBackEnd<Traits::numIterables,Traits,0>*>(this);
    inner_iterable_private_interface& firstPrivateIterable = const_cast<inner_iterable_private_interface&>(firstBackend->getPrivateIterable());

    inner_iterable& firstIterable = *static_cast<inner_iterable *>((void *)((u8*)&firstPrivateIterable - sizeof(inner_iterable)));

    iterator_type it(*this);

    if(currPair->innerNode != inner_iterator_type::m_pHead)
    {
        inner_pointer_type nextNode = firstPrivateIterable.getNextElem(currPair->innerNode);
        firstIterable.eraseNode(currPair->innerNode);

        it.setCurrentNode(this->createPair(firstBackend,nextNode));
    }

    return it;
}
template<template <typename> class Iterable, typename Traits>
typename cIterable<Iterable,Traits>::iterator_type cIterable<Iterable,Traits>::add(add_type i_value)
{
    const nested_iterable_interface* firstBackend = static_cast<const cIterableImplBackEnd<Traits::numIterables,Traits,0>*>(this);
    inner_iterable_private_interface& firstPrivateIterable = const_cast<inner_iterable_private_interface&>(firstBackend->getPrivateIterable());

    inner_iterable& firstIterable = *static_cast<inner_iterable *>((void *)((u8*)&firstPrivateIterable - sizeof(inner_iterable)));

    inner_pointer_type newNode = firstIterable.addNode(mpl::forward<add_type>(i_value));

    iterator_type it(*this);

    it.setCurrentNode(this->createPair(firstBackend,newNode));

    return it;
}

}
}
}
# 141 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cIterable.h" 2
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cAlgorithm.h" 2

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/optional.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/optional.h"
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/inner_types.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/inner_types.h"
       

namespace yame
{
namespace ytl
{

template<typename T>
struct optional_type;

template<typename T>
struct optional_type<T&>
{
public:

    typedef typename std::remove_cv<T>::type raw_type;
    typedef T internal_type;
    typedef T& ref_type;
    typedef const T& cref_type;
    typedef T& rref_type;
    typedef T* pointer_type;
    typedef const T* cpointer_type;

public:
    internal_type& m_data;

public:
    optional_type(internal_type& other);
    optional_type(const optional_type<T&>& other);

    optional_type() = delete;
    optional_type(internal_type&& other) = delete;
    optional_type(optional_type<T&>&& other) = delete;
    T& operator=(internal_type& other) = delete;
    T& operator=(internal_type&& other) = delete;
    T& operator=(optional_type<T&>&& other) = delete;
    bool operator==(const optional_type<T&>& other) const;
    bool operator==(optional_type<T&>&& other) const;
    rref_type extract();
    ref_type get();
    pointer_type operator->();
    cpointer_type operator->() const;
    template<typename Type>
    static void construct(void* address, Type&& val);
    static void destroy(void* address);
    template<typename Type>
    static void assign(void* address, Type&& val);
    static void swap(void* addressA, internal_type& valA, void* addressB, internal_type& valB);
};

template<typename T>
struct optional_type<T&&>
{
public:

    typedef typename std::remove_cv<T>::type raw_type;
    typedef T internal_type;
    typedef T&& ref_type;
    typedef T&& cref_type;
    typedef T&& rref_type;
    typedef T* pointer_type;
    typedef const T* cpointer_type;

public:
    internal_type&& m_data;

public:
    optional_type(T&& other);
    optional_type(const optional_type<T&&>& other);

    optional_type() = delete;
    optional_type(internal_type& other) = delete;
    optional_type(optional_type<T&&>&& other) = delete;
    T& operator=(internal_type& other) = delete;
    T& operator=(internal_type&& other) = delete;
    T& operator=(optional_type<const T&>&& other) = delete;
    bool operator==(const optional_type<T&&>& other) const;
    bool operator==(optional_type<T&&>&& other) const;
    ref_type get();
    rref_type extract();
    pointer_type operator->();
    cpointer_type operator->() const;
    template<typename Type>
    static void construct(void* address, Type&& val);
    static void destroy(void* address);
    template<typename Type>
    static void assign(void* address, Type&& val);
    static void swap(void* addressA, internal_type&& valA, void* addressB, internal_type&& valB);
};

template<typename T>
struct optional_type
{
private:
    static const bool copyConstr = std::is_copy_constructible<T>::value || std::is_pointer<T>::value;
    static const bool moveConstr = std::is_move_constructible<T>::value || std::is_pointer<T>::value;
    static_assert(copyConstr || moveConstr, "You cannot define a variant in which one of the types are not copy nor move constructible");

    template<typename _TypeTrue, typename _TypeFalse, bool _condition>
    struct getExternalTypeUponCondition;

    template<typename _TypeTrue, typename _TypeFalse>
    struct getExternalTypeUponCondition<_TypeTrue, _TypeFalse, true>
    {
        typedef _TypeTrue type;
    };

    template<typename _TypeTrue, typename _TypeFalse>
    struct getExternalTypeUponCondition<_TypeTrue, _TypeFalse, false>
    {
        typedef _TypeFalse type;
    };

public:

    typedef typename std::remove_cv<T>::type raw_type;
    typedef T internal_type;
    typedef typename getExternalTypeUponCondition<T&, T&&, copyConstr>::type ref_type;
    typedef typename getExternalTypeUponCondition<const T&, const T&&, copyConstr>::type cref_type;
    typedef typename getExternalTypeUponCondition<T&&, T&, moveConstr>::type rref_type;
    typedef T* pointer_type;
    typedef const T* cpointer_type;

public:
    internal_type m_data;

public:
    optional_type(const internal_type& other);
    optional_type(internal_type& other);
    optional_type(internal_type&& other);
    optional_type(const optional_type<T>& other);
    template<typename TType>
    optional_type(TType&& val);
    optional_type& operator=(const internal_type& other);
    optional_type& operator=(internal_type&& other);
    optional_type& operator=(const optional_type<T>& other);
    bool operator==(const optional_type<T>& other) const;
    bool operator==(optional_type<T>&& other) const;
    ref_type get();
    rref_type extract();
    pointer_type operator->();
    cpointer_type operator->() const;
    template<typename Type>
    static void construct(void* address, Type&& val);
    static void destroy(void* address);
    template<typename Type>
    static void assign(void* address, Type&& val);
    static void swap(void* addressA, internal_type& valA, void* addressB, internal_type& valB);
};
}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/inner_types.tpp" 1

namespace yame
{
namespace ytl
{




template<typename T>
optional_type<T&>::optional_type(internal_type& other)
    : m_data(other)
{
}
template<typename T>
optional_type<T&>::optional_type(const optional_type<T&>& other)
    : m_data(other.m_data)
{
}
template<typename T>
typename optional_type<T&>::ref_type optional_type<T&>::get()
{
    return m_data;
}
template<typename T>
typename optional_type<T&>::rref_type optional_type<T&>::extract()
{
    return m_data;
}
template<typename T>
typename optional_type<T&>::pointer_type optional_type<T&>::operator->()
{
    return &m_data;
}
template<typename T>
typename optional_type<T&>::cpointer_type optional_type<T&>::operator->() const
{
    return &m_data;
}
template<typename T>
bool optional_type<T&>::operator==(const optional_type<T&>& other) const
{
    return m_data == other.m_data;
}
template<typename T>
bool optional_type<T&>::operator==(optional_type<T&>&& other) const
{

    return m_data == other.m_data;
}
template<typename T>
template<typename Type>
void optional_type<T&>::construct(void* address, Type&& val)
{
    new(address)optional_type(mpl::forward<Type>(val));

    return;
}
template<typename T>
void optional_type<T&>::destroy(void* address)
{

}
template<typename T>
template<typename Type>
void optional_type<T&>::assign(void* address, Type&& val)
{

    construct<Type>(address, mpl::forward<Type>(val));

    return;
}
template<typename T>
void optional_type<T&>::swap(void* addressA, internal_type& valA, void* addressB, internal_type& valB)
{
    internal_type& tmp = valA;

    construct<internal_type&>(addressA, valB);

    construct<internal_type&>(addressB, tmp);

    return;
}




template<typename T>
optional_type<T&&>::optional_type(T&& other)
    : m_data(mpl::move(other))
{
}
template<typename T>
optional_type<T&&>::optional_type(const optional_type<T&&>& other)
    : m_data(mpl::move(other.m_data))
{
}
template<typename T>
typename optional_type<T&&>::pointer_type optional_type<T&&>::operator->()
{
    return &m_data;
}
template<typename T>
typename optional_type<T&&>::cpointer_type optional_type<T&&>::operator->() const
{
    return &m_data;
}
template<typename T>
bool optional_type<T&&>::operator==(const optional_type<T&&>& other) const
{
    return m_data == mpl::move(other.m_data);
}
template<typename T>
bool optional_type<T&&>::operator==(optional_type<T&&>&& other) const
{
    return m_data == mpl::move(other.m_data);
}
template<typename T>
typename optional_type<T&&>::ref_type optional_type<T&&>::get()
{
    return mpl::move(m_data);
}
template<typename T>
typename optional_type<T&&>::rref_type optional_type<T&&>::extract()
{
    return mpl::move(m_data);
}
template<typename T>
template<typename Type>
void optional_type<T&&>::construct(void* address, Type&& val)
{
    new(address)optional_type(mpl::forward<Type&&>(val));

    return;
}
template<typename T>
void optional_type<T&&>::destroy(void* address)
{

}
template<typename T>
template<typename Type>
void optional_type<T&&>::assign(void* address, Type&& val)
{

    construct<Type>(address, mpl::forward<Type>(val));

    return;
}
template<typename T>
void optional_type<T&&>::swap(void* addressA, internal_type&& valA, void* addressB, internal_type&& valB)
{
    internal_type&& tmp = mpl::move(valA);

    construct<internal_type&&>(addressA, mpl::move(valB));

    construct<internal_type&&>(addressB, mpl::move(tmp));

    return;
}





template<typename T>
optional_type<T>::optional_type(const internal_type& other)
    : m_data(other)
{
}
template<typename T>
optional_type<T>::optional_type(internal_type& other)
    : m_data(other)
{
}
template<typename T>
optional_type<T>::optional_type(internal_type&& other)
    : m_data(mpl::move(other))
{
}
template<typename T>
optional_type<T>::optional_type(const optional_type<T>& other)
    : m_data(other.m_data)
{
}
template<typename T>
template<typename TType>
optional_type<T>::optional_type(TType&& val)
    : m_data(mpl::forward<TType>(val))
{
}
template<typename T>
typename optional_type<T>::pointer_type optional_type<T>::operator->()
{
    return &m_data;
}
template<typename T>
typename optional_type<T>::cpointer_type optional_type<T>::operator->() const
{
    return &m_data;
}
template<typename T>
optional_type<T>& optional_type<T>::operator=(const internal_type& other)
{
    m_data = other;

    return *this;
}
template<typename T>
optional_type<T>& optional_type<T>::operator=(internal_type&& other)
{
    m_data = mpl::move(other);

    return *this;
}
template<typename T>
optional_type<T>& optional_type<T>::operator=(const optional_type<T>& other)
{
    m_data = other.m_data;

    return *this;
}
template<typename T>
bool optional_type<T>::operator==(const optional_type<T>& other) const
{
    return m_data == other.m_data;
}
template<typename T>
bool optional_type<T>::operator==(optional_type<T>&& other) const
{
    return m_data == mpl::move(other.m_data);
}
template<typename T>
typename optional_type<T>::ref_type optional_type<T>::get()
{
    return mpl::forward<optional_type<T>::ref_type>(m_data);
}
template<typename T>
typename optional_type<T>::rref_type optional_type<T>::extract()
{
    return mpl::forward<optional_type<T>::rref_type>(m_data);
}
template<typename T>
template<typename Type>
void optional_type<T>::construct(void* address, Type&& val)
{
    new(address)optional_type(mpl::forward<Type>(val));

    return;
}
template<typename T>
void optional_type<T>::destroy(void* address)
{
    optional_type<T>* _data = reinterpret_cast<optional_type<T>* >(address);

    _data->m_data.~T();

    return;
}
template<typename T>
template<typename Type>
void optional_type<T>::assign(void* address, Type&& val)
{
    optional_type<T>* _data = reinterpret_cast<optional_type<T>* >(address);

    _data->m_data = mpl::forward<Type>(val);

    return;
}
template<typename T>
void optional_type<T>::swap(void* addressA, internal_type& valA, void* addressB, internal_type& valB)
{
    internal_type tmp = valA;

    optional_type<T>* _Adata = reinterpret_cast<optional_type<T>* >(addressA);
    *_Adata = valB;

    optional_type<T>* _Bdata = reinterpret_cast<optional_type<T>* >(addressB);
    *_Bdata = tmp;

    return;
}
}
}
# 167 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/inner_types.h" 2
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/optional.h" 2


namespace yame
{
namespace ytl
{

template<typename T>
class optional
{
template<typename TT>
friend class optional;

template<typename TT>
struct is_optional;

template<typename TT>
struct is_optional<optional<TT> >
{
    static const bool value = true;
};

template<typename TT>
struct is_optional<optional<TT>& >
{
    static const bool value = true;
};

template<typename TT>
struct is_optional<optional<TT>&& >
{
    static const bool value = true;
};

template<typename TT>
struct is_optional
{
    static const bool value = false;
};

template<typename TT>
struct constrCond
{
    typedef typename std::remove_reference<typename std::remove_const<TT>::type>::type type;
    static const bool value = !is_optional<TT>::value && std::is_base_of<type,T>::value;
};



public:

    typedef const typename optional_type<T>::raw_type& reference_const_type;
    typedef typename optional_type<T>::raw_type& reference_type;
    typedef typename optional_type<T>::raw_type&& rreference_type;
    typedef typename optional_type<T>::raw_type* pointer_type;
    typedef const typename optional_type<T>::raw_type* pointer_const_type;

    optional();
    optional(mpl::none_t);
    optional(const optional<T>& other);
    optional(optional<T>&& other);
    optional(reference_type val);
    optional(reference_const_type val);
    optional(rreference_type val);
    template<typename TT>
    optional(const optional<TT>& other);
    template<typename TT>
    optional(optional<TT>&& other);
    optional(mpl::place_holder);
    template<typename TT>
    optional<T>(bool cond, TT&& val);
    template<typename TT>
    explicit optional(TT&& val, typename std::enable_if<!is_optional<TT>::value>::type* foo = nullptr);
    ~optional();
    optional<T>& operator=(const optional<T>& other);
    optional<T>& operator=(optional<T>& other);
    optional<T>& operator=(optional<T>&& other);
    template<typename TT>
    optional<T>& operator=(const optional<TT>& other);
    template<typename TT>
    optional<T>& operator=(optional<TT>& other);
    template<typename TT>
    optional<T>& operator=(optional<TT>&& other);
    optional<T>& operator=(mpl::place_holder);
    optional<T>& operator=(reference_type val);
    optional<T>& operator=(reference_const_type val);
    optional<T>& operator=(rreference_type val);
    template<typename TT>
    optional<T>& operator=(TT&& val);
    bool isInitialized() const;
    operator bool() const;
    bool operator!() const;
    typename optional_type<T>::cref_type get() const;
    typename optional_type<T>::ref_type get();
    typename optional_type<T>::cref_type get_value_or(typename optional_type<T>::cref_type default_value) const;
    typename optional_type<T>::ref_type get_value_or(typename optional_type<T>::ref_type default_value);
    typename optional_type<T>::cpointer_type get_ptr() const;
    typename optional_type<T>::pointer_type get_ptr();
    T extract();
    typename optional_type<T>::ref_type operator*() const;
    typename optional_type<T>::ref_type operator*();
    typename optional_type<T>::cpointer_type operator->() const;
    typename optional_type<T>::pointer_type operator->();
    void swap(const optional<T>& other);

private:
    bool m_is_initialized;
    typedef typename std::aligned_storage<sizeof(optional_type<T>), std::alignment_of<optional_type<T>>::value>::type data_type;
    data_type m_storage;
};

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp" 1


namespace yame
{
namespace ytl
{

template<typename T>
optional<T>::optional()
: m_is_initialized(false)
{
}
template<typename T>
optional<T>::optional(mpl::none_t)
: m_is_initialized(false)
{
}
template<typename T>
optional<T>::optional(const optional<T>& other)
: m_is_initialized(other.m_is_initialized)
{
    if (other.m_is_initialized)
    {
        optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(const_cast<data_type *>(&other.m_storage));

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 26, __PRETTY_FUNCTION__));

        new(&m_storage)optional_type<T>(_data->get());
    }
}
template<typename T>
optional<T>::optional(optional<T>&& other)
: m_is_initialized(other.m_is_initialized)
{
    if (other.m_is_initialized)
    {
        optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(&other.m_storage);

        ((_data && "Access null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Access null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 39, __PRETTY_FUNCTION__));

        new(&m_storage)optional_type<T>(_data->extract());

        optional_type<T>::destroy(&other.m_storage);

        other.m_is_initialized = false;
    }
}
template<typename T>
optional<T>::optional(reference_const_type val)
: m_is_initialized(true)
{
    new(&m_storage)optional_type<T>(val);
}
template<typename T>
optional<T>::optional(reference_type val)
    : m_is_initialized(true)
{
    new(&m_storage)optional_type<T>(val);
}
template<typename T>
optional<T>::optional(rreference_type val)
: m_is_initialized(true)
{
    new(&m_storage)optional_type<T>(mpl::move(val));
}
template<typename T>
template<typename TT>
optional<T>::optional(const optional<TT>& other)
: m_is_initialized(other.m_is_initialized)
{
    if (other.m_is_initialized)
    {
        optional_type<TT> *_data = reinterpret_cast<optional_type<TT> *>(const_cast<typename optional<TT>::data_type *>(&other.m_storage));

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 75, __PRETTY_FUNCTION__));

        new(&m_storage)optional_type<T>(_data->get());
    }
}
template<typename T>
template<typename TT>
optional<T>::optional(optional<TT>&& other)
    : m_is_initialized(other.m_is_initialized)
{
    if (other.m_is_initialized)
    {
        optional_type<TT> *_data = reinterpret_cast<optional_type<TT> *>(&other.m_storage);

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 89, __PRETTY_FUNCTION__));

        new(&m_storage)optional_type<T>(_data->extract());

        optional_type<TT>::destroy(&other.m_storage);

        other.m_is_initialized = false;
    }
}
template<typename T>
optional<T>::optional(mpl::place_holder)
: m_is_initialized(false)
{
}
template<typename T>
template<typename TT>
optional<T>::optional(bool cond, TT&& val)
: m_is_initialized(cond)
{
    if (cond)
    {
        new(&m_storage)optional_type<T>(mpl::forward<TT>(val));
    }
}
template<typename T>
template<typename TT>
optional<T>::optional(TT&& val, typename std::enable_if<!is_optional<TT>::value>::type* foo)
: m_is_initialized(true)
{
    new(&m_storage)optional_type<T>(mpl::forward<TT>(val));
}
template<typename T>
optional<T>::~optional()
{
    if (m_is_initialized)
    {
        optional_type<T>::destroy(&m_storage);
    }
}
template<typename T>
optional<T>& optional<T>::operator=(const optional<T>& other)
{
    if (m_is_initialized)
    {
        if (other.isInitialized())
        {
            optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(const_cast<optional<T>::data_type *>(&other.m_storage));

            ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 137, __PRETTY_FUNCTION__));

            optional_type<T>::assign(&m_storage, _data->get());
        }
        else
        {
            optional_type<T>::destroy(&m_storage);
            m_is_initialized = false;
        }
    }
    else if (other.isInitialized())
    {
        optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(const_cast<optional<T>::data_type *>(&other.m_storage));

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 151, __PRETTY_FUNCTION__));

        new(&m_storage) optional_type<T>(_data->get());

        m_is_initialized = true;
    }

    return *this;
}
template<typename T>
optional<T>& optional<T>::operator=(optional<T>& other)
{
    if (m_is_initialized)
    {
        if (other.isInitialized())
        {
            optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(&other.m_storage);

            ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 169, __PRETTY_FUNCTION__));

            optional_type<T>::assign(&m_storage, _data->get());
        }
        else
        {
            optional_type<T>::destroy(&m_storage);
            m_is_initialized = false;
        }
    }
    else if (other.isInitialized())
    {
        optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(&other.m_storage);

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 183, __PRETTY_FUNCTION__));

        new(&m_storage) optional_type<T>(_data->get());

        m_is_initialized = true;
    }

    return *this;
}
template<typename T>
optional<T>& optional<T>::operator=(optional<T>&& other)
{
    if (m_is_initialized)
    {
        if (other.isInitialized())
        {
            optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(&other.m_storage);

            ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 201, __PRETTY_FUNCTION__));

            optional_type<T>::assign(&m_storage, _data->extract());

            optional_type<T>::destroy(&other.m_storage);

            other.m_is_initialized = false;
        }
        else
        {
            optional_type<T>::destroy(&m_storage);
            m_is_initialized = false;
        }
    }
    else if (other.isInitialized())
    {
        optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(&other.m_storage);

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 219, __PRETTY_FUNCTION__));

        new(&m_storage) optional_type<T>(_data->extract());

        m_is_initialized = true;

        optional_type<T>::destroy(&other.m_storage);

        other.m_is_initialized = false;
    }

    return *this;
}
template<typename T>
template<typename TT>
optional<T>& optional<T>::operator=(const optional<TT>& other)
{
    if (m_is_initialized)
    {
        if (other.isInitialized())
        {
            optional_type<TT> *_data = reinterpret_cast<optional_type<TT> *>(const_cast<typename optional<TT>::data_type *>(&other.m_storage));

            ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 242, __PRETTY_FUNCTION__));

            optional_type<T>::assign(&m_storage, _data->get());
        }
        else
        {
            optional_type<T>::destroy(&m_storage);
            m_is_initialized = false;
        }
    }
    else if (other.isInitialized())
    {
        optional_type<TT> *_data = reinterpret_cast<optional_type<TT> *>(const_cast<typename optional<TT>::data_type *>(&other.m_storage));

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 256, __PRETTY_FUNCTION__));

        new(&m_storage) optional_type<T>(_data->get());

        m_is_initialized = true;
    }

    return *this;
}
template<typename T>
template<typename TT>
optional<T>& optional<T>::operator=(optional<TT>& other)
{
    if (m_is_initialized)
    {
        if (other.isInitialized())
        {
            optional_type<TT> *_data = reinterpret_cast<optional_type<TT> *>(&other.m_storage);

            ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 275, __PRETTY_FUNCTION__));

            optional_type<T>::assign(&m_storage, _data->get());
        }
        else
        {
            optional_type<T>::destroy(&m_storage);
            m_is_initialized = false;
        }
    }
    else if (other.isInitialized())
    {
        optional_type<TT> *_data = reinterpret_cast<optional_type<TT> *>(&other.m_storage);

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 289, __PRETTY_FUNCTION__));

        new(&m_storage) optional_type<T>(_data->get());

        m_is_initialized = true;
    }

    return *this;
}
template<typename T>
template<typename TT>
optional<T>& optional<T>::operator=(optional<TT>&& other)
{
    if (m_is_initialized)
    {
        if (other.isInitialized())
        {
            optional_type<TT> *_data = reinterpret_cast<optional_type<TT> *>(&other.m_storage);

            ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 308, __PRETTY_FUNCTION__));

            optional_type<T>::assign(&m_storage, _data->extract());

            optional_type<TT>::destroy(&other.m_storage);

            other.m_is_initialized = false;
        }
        else
        {
            optional_type<T>::destroy(&m_storage);
            m_is_initialized = false;
        }
    }
    else if (other.isInitialized())
    {
        optional_type<TT> *_data = reinterpret_cast<optional_type<TT> *>(&other.m_storage);

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 326, __PRETTY_FUNCTION__));

        new(&m_storage) optional_type<T>(_data->extract());

        m_is_initialized = true;

        optional_type<TT>::destroy(&other.m_storage);

        other.m_is_initialized = false;
    }

    return *this;
}
template<typename T>
optional<T>& optional<T>::operator=(mpl::place_holder)
{
    if (m_is_initialized)
    {
        optional_type<T>::destroy(&m_storage);

        m_is_initialized = false;
    }

    return *this;
}
template<typename T>
optional<T>& optional<T>::operator=(reference_type val)
{
    if (m_is_initialized)
    {
        optional_type<T>::assign(&m_storage, val);
    }
    else
    {
        new(&m_storage) optional_type<T>(val);

        m_is_initialized = true;
    }

    return *this;
}
template<typename T>
optional<T>& optional<T>::operator=(reference_const_type val)
{
    if (m_is_initialized)
    {
        optional_type<T>::assign(&m_storage, val);
    }
    else
    {
        new(&m_storage) optional_type<T>(val);

        m_is_initialized = true;
    }

    return *this;
}
template<typename T>
optional<T>& optional<T>::operator=(rreference_type val)
{
    if (m_is_initialized)
    {
        optional_type<T>::assign(&m_storage, mpl::move(val));
    }
    else
    {
        new(&m_storage) optional_type<T>(mpl::move(val));

        m_is_initialized = true;
    }

    return *this;
}
template<typename T>
template<typename TT>
optional<T>& optional<T>::operator=(TT&& val)
{
    if (m_is_initialized)
    {
        optional_type<T>::assign(&m_storage, mpl::forward<TT>(val));
    }
    else
    {
        new(&m_storage) optional_type<T>(mpl::forward<TT>(val));

        m_is_initialized = true;
    }

    return *this;
}
template<typename T>
bool optional<T>::isInitialized() const
{
    return m_is_initialized;
}
template<typename T>
optional<T>::operator bool() const
{
    return m_is_initialized;
}
template<typename T>
bool optional<T>::operator!() const
{
    return !m_is_initialized;
}
template<typename T>
typename optional_type<T>::cref_type optional<T>::get() const
{
    ((m_is_initialized && "Accessing non initialized data!") ? static_cast<void> (0) : __assert_fail ("m_is_initialized && \"Accessing non initialized data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 434, __PRETTY_FUNCTION__));

    typedef typename optional_type<T>::cref_type retType;


    optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(const_cast<data_type *>(&m_storage));

    ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 441, __PRETTY_FUNCTION__));

    return mpl::forward<retType>(_data->get());
}
template<typename T>
typename optional_type<T>::ref_type optional<T>::get()
{
    ((m_is_initialized && "Accessing non initialized data!") ? static_cast<void> (0) : __assert_fail ("m_is_initialized && \"Accessing non initialized data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 448, __PRETTY_FUNCTION__));

    typedef typename optional_type<T>::ref_type retType;


    optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(&m_storage);

    ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 455, __PRETTY_FUNCTION__));

    return mpl::forward<retType>(_data->get());
}
template<typename T>
typename optional_type<T>::cref_type optional<T>::get_value_or(typename optional_type<T>::cref_type default_value) const
{
    if (m_is_initialized)
    {
        typedef typename optional_type<T>::cref_type retType;


        optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(const_cast<data_type *>(&m_storage));

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 469, __PRETTY_FUNCTION__));

        return mpl::forward<retType>(_data->get());
    }

    return default_value;
}
template<typename T>
typename optional_type<T>::ref_type optional<T>::get_value_or(typename optional_type<T>::ref_type default_value)
{
    if (m_is_initialized)
    {
        typedef typename optional_type<T>::ref_type retType;


        optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(const_cast<data_type *>(&m_storage));

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 486, __PRETTY_FUNCTION__));

        return mpl::forward<retType>(_data->get());
    }

    return default_value;
}
template<typename T>
typename optional_type<T>::cpointer_type optional<T>::get_ptr() const
{
    if (m_is_initialized)
    {
        typedef typename optional_type<T>::cpointer_type retType;


        optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(const_cast<data_type *>(&m_storage));

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 503, __PRETTY_FUNCTION__));

        return &(_data->m_data);
    }

    return nullptr;
}
template<typename T>
typename optional_type<T>::pointer_type optional<T>::get_ptr()
{
    if (m_is_initialized)
    {
        typedef typename optional_type<T>::cpointer_type retType;


        optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(&m_storage);

        ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 520, __PRETTY_FUNCTION__));

        return &(_data->m_data);
    }

    return nullptr;
}
template<typename T>
T optional<T>::extract()
{
    ((m_is_initialized && "Accessing non initialized data!") ? static_cast<void> (0) : __assert_fail ("m_is_initialized && \"Accessing non initialized data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 530, __PRETTY_FUNCTION__));


    typedef typename optional_type<T>::rref_type retType;
    typedef typename optional_type<T>::internal_type rawType;


    optional_type<T> *_data = reinterpret_cast<optional_type<T> *>(const_cast<data_type *>(&m_storage));

    ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 539, __PRETTY_FUNCTION__));

    rawType res = mpl::forward<retType>(_data->get());

    optional_type<T>::destroy(&m_storage);

    m_is_initialized = false;

    return mpl::forward<retType>(res);
}
template<typename T>
typename optional_type<T>::ref_type optional<T>::operator*() const
{
    ((m_is_initialized && "Accessing non initialized data!") ? static_cast<void> (0) : __assert_fail ("m_is_initialized && \"Accessing non initialized data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 552, __PRETTY_FUNCTION__));

    typedef typename optional_type<T>::ref_type retType;


    optional_type<T> *_data = reinterpret_cast<optional_type<T>*>(const_cast<data_type *>(&m_storage));

    ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 559, __PRETTY_FUNCTION__));

    return mpl::forward<retType>(_data->get());
}
template<typename T>
typename optional_type<T>::ref_type optional<T>::operator*()
{
    ((m_is_initialized && "Accessing non initialized data!") ? static_cast<void> (0) : __assert_fail ("m_is_initialized && \"Accessing non initialized data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 566, __PRETTY_FUNCTION__));

    typedef typename optional_type<T>::ref_type retType;


    optional_type<T> *_data = reinterpret_cast<optional_type<T>*>(&m_storage);

    ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 573, __PRETTY_FUNCTION__));

    return mpl::forward<retType>(_data->get());
}
template<typename T>
typename optional_type<T>::cpointer_type optional<T>::operator->() const
{
    ((m_is_initialized && "Accessing non initialized data!") ? static_cast<void> (0) : __assert_fail ("m_is_initialized && \"Accessing non initialized data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 580, __PRETTY_FUNCTION__));


    optional_type<T> *_data = reinterpret_cast<optional_type<T>*>(const_cast<data_type *>(&m_storage));

    ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 585, __PRETTY_FUNCTION__));

    return _data->operator->();
}
template<typename T>
typename optional_type<T>::pointer_type optional<T>::operator->()
{
    ((m_is_initialized && "Accessing non initialized data!") ? static_cast<void> (0) : __assert_fail ("m_is_initialized && \"Accessing non initialized data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 592, __PRETTY_FUNCTION__));


    optional_type<T> *_data = reinterpret_cast<optional_type<T>*>(const_cast<data_type *>(&m_storage));

    ((_data && "Accessing null data!") ? static_cast<void> (0) : __assert_fail ("_data && \"Accessing null data!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/detail/optional.tpp", 597, __PRETTY_FUNCTION__));

    return _data->operator->();
}
template<typename T>
void optional<T>::swap(const optional<T>& other)
{
    optional<T>& ncOther = const_cast<optional<T>&>(other);

    if (m_is_initialized && ncOther.m_is_initialized)
    {
        optional_type<T> *_thisData = reinterpret_cast<optional_type<T>*>(const_cast<data_type *>(&m_storage));
        optional_type<T> *_otherData = reinterpret_cast<optional_type<T>*>(const_cast<data_type *>(&(ncOther.m_storage)));

        optional_type<T>::swap(&m_storage, _thisData->get(), &(ncOther.m_storage), _otherData->get());
    }
    else if (m_is_initialized)
    {
        optional_type<T> *_thisData = reinterpret_cast<optional_type<T>*>(const_cast<data_type *>(&m_storage));

        new(&(ncOther.m_storage)) optional_type<T>(_thisData->get());
        ncOther.m_is_initialized = true;

        optional_type<T>::destroy(&m_storage);
        m_is_initialized = false;
    }
    else if (ncOther.m_is_initialized)
    {
        optional_type<T> *_otherData = reinterpret_cast<optional_type<T>*>(const_cast<data_type *>(&(ncOther.m_storage)));

        new(&(m_storage)) optional_type<T>(_otherData->get());
        m_is_initialized = true;

        optional_type<T>::destroy(&(ncOther.m_storage));
        ncOther.m_is_initialized = false;
    }
}

}
}
# 132 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/optional/optional.h" 2
# 20 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cAlgorithm.h" 2

namespace yame
{
namespace container
{
namespace detail
{

template<typename IteratorIn>
inline bool equal(IteratorIn& itInitA, IteratorIn& itEndA, IteratorIn& itInitB, IteratorIn& itEndB, const ytl::function<bool(typename IteratorIn::const_reference,typename IteratorIn::const_reference)>& i_eqOp)
{
    bool res = true;

    for(;itInitA!=itEndA && itInitB!=itEndB;++itInitA,++itInitB)
    {
        if(i_eqOp.eval(*itInitA,*itInitB) == false)
        {
            res = false;
            break;
        }
    }

    return res;
}

template<typename Iterator>
inline Iterator cmp(Iterator& itInit, Iterator& itEnd, const ytl::function<bool(typename Iterator::const_reference,typename Iterator::const_reference)>& i_compOp)
{
    ((itInit!=itEnd && "You shall provide a non empty iterator pair") ? static_cast<void> (0) : __assert_fail ("itInit!=itEnd && \"You shall provide a non empty iterator pair\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cAlgorithm.h", 48, __PRETTY_FUNCTION__));

    Iterator itFound = itInit++;

    for(;itInit!=itEnd;++itInit)
    {
        if(i_compOp.eval(*itInit, *itFound))
        {
            itFound = itInit;
        }
    }

    return itFound;
}

template<typename Iterator>
inline typename Iterator::value_type apply(Iterator& itInit, Iterator& itEnd, const ytl::function<typename Iterator::value_type(typename Iterator::const_reference,typename Iterator::const_reference)>& i_op)
{
    ((itInit!=itEnd && "You shall provide a non empty iterator pair") ? static_cast<void> (0) : __assert_fail ("itInit!=itEnd && \"You shall provide a non empty iterator pair\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cAlgorithm.h", 66, __PRETTY_FUNCTION__));

    typename Iterator::value_type cmpValue = *itInit++;

    for(;itInit!=itEnd;++itInit)
    {
        cmpValue = i_op.eval(cmpValue,*itInit);
    }

    return cmpValue;
}

template<typename Traits>
inline void sort(impl::cRandomAccessIteratorImpl<Traits>& itInit, impl::cRandomAccessIteratorImpl<Traits>& itEnd, const ytl::function<bool(typename Traits::const_reference,typename Traits::const_reference)>& i_cmp)
{
    if(itInit == itEnd)
    {
        return;
    }
    else
    {
        const u32 rangeSize = itEnd - itInit;
        size_t pivotInd = rangeSize / 2;
        typename Traits::value_type pivot = *(itInit+pivotInd);
        size_t upperIndex = 0;
        size_t lowerIndex = rangeSize-1;
        bool done = false;

        while(!done)
        {
            while(i_cmp.eval(*(itInit+upperIndex), pivot)) upperIndex++;
            while(i_cmp.eval(pivot,*(itInit+lowerIndex))) lowerIndex--;

            if(upperIndex >= lowerIndex)
            {
                done = true;
                pivotInd = lowerIndex;
            }
            else
            {

                mpl::swapItems(*(itInit+upperIndex),*(itInit+lowerIndex));
            }
        }


        impl::cRandomAccessIteratorImpl<Traits> rangeAA = (pivotInd == 0) ? itInit+1 : (pivotInd == rangeSize) ? itInit : itInit;
        impl::cRandomAccessIteratorImpl<Traits> rangeAB = (pivotInd == 0) ? itEnd : (pivotInd == rangeSize) ? itEnd-1 : itInit+pivotInd;
        impl::cRandomAccessIteratorImpl<Traits> rangeBA = (pivotInd == 0) ? itEnd : (pivotInd == rangeSize) ? itEnd : itInit+pivotInd+1;
        impl::cRandomAccessIteratorImpl<Traits> rangeBB = (pivotInd == 0) ? itEnd : (pivotInd == rangeSize) ? itEnd : itEnd;

        if(rangeAA != rangeAB)
        {
            sort(rangeAA,rangeAB,i_cmp);
        }
        if(rangeBA != rangeBB)
        {
            sort(rangeBA,rangeBB,i_cmp);
        }
    }

    return;
}

template<typename IteratorIn, typename IteratorOut>
inline IteratorOut merge(IteratorIn& itInitA, IteratorIn& itEndA, IteratorIn& itInitB, IteratorIn& itEndB, cIterableBase<IteratorOut>& iterableOut, const ytl::function<typename IteratorIn::value_type(ytl::optional<typename IteratorIn::const_reference>,ytl::optional<typename IteratorIn::const_reference>)>& i_merge)
{
    bool done = false;
    IteratorOut itOut = iterableOut.begin();

    while(!done)
    {
        if(itInitA != itEndA && itInitB != itEndB)
        {
            itOut = iterableOut.add(i_merge.eval(*(itInitA),*(itInitB)));

            ++itInitA;
            ++itInitB;
        }
        else if(itInitA != itEndA)
        {
            itOut = iterableOut.add(i_merge.eval(*(itInitA),none));

            ++itInitA;
        }
        else if(itInitB != itEndB)
        {
            itOut = iterableOut.add(i_merge.eval(none,*(itInitB)));

            ++itInitB;
        }
        else
        {
            done = true;
        }
    }

    return itOut;
}

template<typename Iterator>
inline Iterator find_if(Iterator& itInit, Iterator& itEnd, ytl::function<bool(typename Iterator::const_reference)> i_findOp)
{
    Iterator currIt = itInit;

    for(;currIt!=itEnd;++currIt)
    {
        if(i_findOp.eval(*currIt))
        {
            return static_cast<Iterator&>(currIt);
        }
    }

    return static_cast<Iterator&>(itEnd);
}

template<typename Iterator>
inline typename Iterator::difference_type distance(Iterator& itInit, Iterator& itEnd)
{
    typename Iterator::difference_type dist = 0;

    for(Iterator currIt=itInit;currIt!=itEnd;++currIt,++dist);

    return dist;
}

template<typename T>
inline typename cRandomAccessIterator<T>::difference_type distance(cRandomAccessIterator<T>& itInit, cRandomAccessIterator<T>& itEnd)
{
    return itEnd - itInit;
}

template<typename Iterator>
inline Iterator initialize(Iterator& itInit, Iterator& itEnd, const std::initializer_list<typename Iterator::value_type>& i_initializerList)
{
    const typename Iterator::value_type* currElem = i_initializerList.begin();

    for(;currElem!=i_initializerList.end() && itInit!=itEnd;++currElem,++itInit)
    {
        *itInit = *currElem;
    }

    return static_cast<Iterator&>(itInit);
}

template<typename IteratorIn, typename IteratorOut>
inline IteratorOut assign(container::detail::cIterableBase<IteratorOut>& iterableOut, IteratorIn& itInit, IteratorIn& itEnd)
{
    IteratorOut itOut = iterableOut.begin();

    for(;itInit!=itEnd;++itInit)
    {
        itOut = iterableOut.add(*itInit);
    }

    return itOut;
}

template<typename Iterator>
inline Iterator assign(container::detail::cIterableBase<Iterator>& iterableOut, const std::initializer_list<typename Iterator::value_type>& i_initializerList)
{
    Iterator itOut = iterableOut.begin();

    const typename Iterator::value_type* currElem = i_initializerList.begin();

    for(;currElem!=i_initializerList.end();++currElem)
    {
        itOut = iterableOut.add(*currElem);
    }

    return itOut;
}

template<typename IteratorIn, typename IteratorOutput>
inline IteratorOutput transform(IteratorIn& itInitInput, IteratorIn& itEndInput, cIterableBase<IteratorOutput>& iterableOutput, const ytl::function<typename IteratorIn::value_type(typename IteratorIn::const_reference)>& i_transformOp)
{
    IteratorOutput itOut = iterableOutput.begin();

    for(;itInitInput!=itEndInput;++itInitInput)
    {
        itOut = iterableOutput.add(i_transformOp(*itInitInput));
    }

    return itOut;
}

}
}

template<typename Iterator>
inline bool equal(Iterator itInitA, Iterator itEndA, Iterator itInitB, Iterator itEndB, typename mpl::enable_if<mpl::is_base_of<container::detail::impl::InputIteratorTag,Iterator>::value>::type* = __null)
{
    return container::detail::equal(itInitA,itEndA, itInitB, itEndB,ytl::function<bool(typename Iterator::const_reference, typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename Iterator::const_reference i_rhs){ return i_lhs == i_rhs;}));
}

template<typename Iterator>
inline bool equal(Iterator itInitA, Iterator itEndA, Iterator itInitB, Iterator itEndB, const ytl::function<bool(typename Iterator::const_reference,typename Iterator::const_reference)>& i_eqOp, typename mpl::enable_if<mpl::is_base_of<container::detail::impl::InputIteratorTag,Iterator>::value>::type* = __null)
{
    return container::detail::equal(itInitA,itEndA, itInitB, itEndB,!i_eqOp);
}

template<typename Iterator>
inline bool equal(const container::detail::cConstIterableBase<Iterator>& iterableA, const container::detail::cConstIterableBase<Iterator>& iterableB)
{
    typename Iterator::const_iterator_type itInitA = iterableA.cbegin();
    typename Iterator::const_iterator_type itEndA = iterableA.cend();

    typename Iterator::const_iterator_type itInitB = iterableB.cbegin();
    typename Iterator::const_iterator_type itEndB = iterableB.cend();

    return container::detail::equal(itInitA,itEndA, itInitB, itEndB,ytl::function<bool(typename Iterator::const_reference, typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename Iterator::const_reference i_rhs){ return i_lhs == i_rhs;}));
}

template<typename Iterator>
inline bool equal(const container::detail::cConstIterableBase<Iterator>& iterableA, const container::detail::cConstIterableBase<Iterator>& iterableB, const ytl::function<bool(typename Iterator::const_reference,typename Iterator::const_reference)>& i_eqOp)
{
    typename Iterator::const_iterator_type itInitA = iterableA.cbegin();
    typename Iterator::const_iterator_type itEndA = iterableA.cend();

    typename Iterator::const_iterator_type itInitB = iterableB.cbegin();
    typename Iterator::const_iterator_type itEndB = iterableB.cend();

    return container::detail::equal(itInitA,itEndA, itInitB, itEndB,!i_eqOp);
}

template<typename Iterator>
inline Iterator min(Iterator itInit, Iterator itEnd, const ytl::function<bool(typename Iterator::const_reference,typename Iterator::const_reference)>& i_lessOp, typename mpl::enable_if<mpl::is_base_of<container::detail::impl::InputIteratorTag,Iterator>::value>::type* = __null)
{
    return container::detail::cmp(itInit,itEnd,i_lessOp);
}

template<typename Iterator>
inline Iterator max(Iterator itInit, Iterator itEnd, const ytl::function<bool(typename Iterator::const_reference,typename Iterator::const_reference)>& i_moreOp, typename mpl::enable_if<mpl::is_base_of<container::detail::impl::InputIteratorTag,Iterator>::value>::type* = __null)
{
    return container::detail::cmp(itInit,itEnd,i_moreOp);
}

template<typename Iterator>
inline Iterator min(Iterator itInit, Iterator itEnd, typename mpl::enable_if<mpl::is_base_of<container::detail::impl::InputIteratorTag,Iterator>::value>::type* = __null)
{
    return container::detail::cmp(itInit,itEnd,ytl::function<bool(typename Iterator::const_reference, typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename Iterator::const_reference i_rhs){ return i_lhs < i_rhs;}));
}

template<typename Iterator>
inline Iterator max(Iterator itInit, Iterator itEnd, typename mpl::enable_if<mpl::is_base_of<container::detail::impl::InputIteratorTag,Iterator>::value>::type* = __null)
{
    return container::detail::cmp(itInit,itEnd,ytl::function<bool(typename Iterator::const_reference, typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename Iterator::const_reference i_rhs){ return i_lhs > i_rhs;}));
}

template<typename Iterator>
inline typename Iterator::const_iterator_type min(const container::detail::cConstIterableBase<Iterator>& iterable, const ytl::function<bool(typename Iterator::const_reference,typename Iterator::const_reference)>& i_lessOp)
{
    typename Iterator::const_iterator_type itInit = iterable.cbegin();
    typename Iterator::const_iterator_type itEnd = iterable.cend();

    return container::detail::cmp(itInit,itEnd,i_lessOp);
}

template<typename Iterator>
inline typename Iterator::const_iterator_type max(const container::detail::cConstIterableBase<Iterator>& iterable, const ytl::function<bool(typename Iterator::const_reference,typename Iterator::const_reference)>& i_moreOp)
{
    typename container::detail::cIterableBase<Iterator>::const_iterator_type itInit = iterable.cbegin();
    typename container::detail::cIterableBase<Iterator>::const_iterator_type itEnd = iterable.cend();

    return container::detail::cmp(itInit,itEnd,i_moreOp);
}

template<typename Iterator>
inline typename Iterator::const_iterator_type min(const container::detail::cConstIterableBase<Iterator>& iterable)
{
    typename Iterator::const_iterator_type itInit = iterable.cbegin();
    typename Iterator::const_iterator_type itEnd = iterable.cend();

    return container::detail::cmp(itInit,itEnd,ytl::function<bool(typename Iterator::const_reference, typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename Iterator::const_reference i_rhs){ return i_lhs < i_rhs;}));
}

template<typename Iterator>
inline typename Iterator::const_iterator_type max(const container::detail::cConstIterableBase<Iterator>& iterable)
{
    typename Iterator::const_iterator_type itInit = iterable.cbegin();
    typename Iterator::const_iterator_type itEnd = iterable.cend();

    return container::detail::cmp(itInit,itEnd,ytl::function<bool(typename Iterator::const_reference, typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename container::detail::cIterableBase<Iterator>::const_reference i_rhs){ return i_lhs > i_rhs;}));
}
template<typename Iterator>
inline typename Iterator::value_type apply(const container::detail::cConstIterableBase<Iterator>& iterable, const ytl::function<typename Iterator::value_type(typename Iterator::const_reference,typename Iterator::const_reference)>& i_op)
{
    typename Iterator::const_iterator_type itInit = iterable.cbegin();
    typename Iterator::const_iterator_type itEnd = iterable.cend();

    return container::detail::apply(itInit,itEnd,i_op);
}
template<typename T>
inline typename T::value_type apply(T itInit, T itEnd, const ytl::function<typename T::value_type(typename T::const_reference,typename T::const_reference)>& i_op, typename mpl::enable_if<mpl::is_base_of<container::detail::impl::InputIteratorTag,T>::value>::type* = __null)
{
    return container::detail::apply(itInit,itEnd,i_op);
}
template<typename Iterator>
inline typename Iterator::value_type sum(const container::detail::cConstIterableBase<Iterator>& iterable)
{
    typename Iterator::const_iterator_type itInit = iterable.cbegin();
    typename Iterator::const_iterator_type itEnd = iterable.cend();

    return container::detail::apply(itInit,itEnd,ytl::function<typename Iterator::value_type(typename Iterator::const_reference,typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename Iterator::const_reference i_rhs) { return i_lhs + i_rhs;}));
}
template<typename Iterator>
inline typename Iterator::value_type sum(Iterator itInit, Iterator itEnd, typename mpl::enable_if<mpl::is_base_of<container::detail::impl::InputIteratorTag,Iterator>::value>::type* = __null)
{
    return container::detail::apply(itInit,itEnd,ytl::function<typename Iterator::value_type(typename Iterator::const_reference, typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename Iterator::const_reference i_rhs){ return i_lhs + i_rhs;}));
}
template<typename Iterator>
inline typename Iterator::value_type prod(const container::detail::cConstIterableBase<Iterator>& iterable)
{
    typename Iterator::const_iterator_type itInit = iterable.cbegin();
    typename Iterator::const_iterator_type itEnd = iterable.cend();

    return container::detail::apply(itInit,itEnd,ytl::function<typename Iterator::value_type(typename Iterator::const_reference,typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename Iterator::const_reference i_rhs) { return i_lhs * i_rhs;}));
}
template<typename Iterator>
inline typename Iterator::value_type prod(Iterator itInit, Iterator itEnd, typename mpl::enable_if<mpl::is_base_of<container::detail::impl::InputIteratorTag,Iterator>::value>::type* = __null)
{
    return container::detail::apply(itInit,itEnd,ytl::function<typename Iterator::value_type(typename Iterator::const_reference, typename Iterator::const_reference)>([](typename Iterator::const_reference i_lhs,typename Iterator::const_reference i_rhs){ return i_lhs * i_rhs;}));
}
template<typename Traits>
inline void sort(container::detail::impl::cRandomAccessIteratorImpl<Traits> itInit, container::detail::impl::cRandomAccessIteratorImpl<Traits> itEnd, const ytl::function<bool(typename Traits::const_reference,typename Traits::const_reference)>& i_lessOp)
{
    container::detail::sort(itInit,itEnd,i_lessOp);
}
template<typename Traits>
inline void sort(container::detail::impl::cRandomAccessIteratorImpl<Traits> itInit, container::detail::impl::cRandomAccessIteratorImpl<Traits> itEnd)
{
    container::detail::sort(itInit,itEnd,[](typename Traits::const_reference i_lhs,typename Traits::const_reference i_rhs){ return i_lhs < i_rhs;});
}
template<typename T>
inline void sort(const container::cConstRandomAccessIterable<T>& iterable, const ytl::function<bool(typename container::cRandomAccessIterable<T>::const_reference,typename container::cRandomAccessIterable<T>::const_reference)>& i_lessOp)
{
    typename container::cConstRandomAccessIterable<T>::const_iterator_type itInit = iterable.cbegin();
    typename container::cConstRandomAccessIterable<T>::const_iterator_type itEnd = iterable.cend();

    container::detail::sort(itInit,itEnd,i_lessOp);

    return;
}
template<typename T>
inline void sort(container::cConstRandomAccessIterable<T>& iterable)
{
    typename container::cConstRandomAccessIterable<T>::iterator_type itInit = iterable.begin();
    typename container::cConstRandomAccessIterable<T>::iterator_type itEnd = iterable.end();

    container::detail::sort(itInit,itEnd,ytl::function<bool(typename container::cRandomAccessIterable<T>::const_reference,typename container::cRandomAccessIterable<T>::const_reference)>([](typename container::cRandomAccessIterable<T>::const_reference i_lhs,typename container::cRandomAccessIterable<T>::const_reference i_rhs){ return i_lhs < i_rhs;}));

    return;
}
template<typename T, typename TT>
inline typename TT::iterator_type merge(T itInitA, T itEndA, T itInitB, T itEndB, TT itInitOut, const ytl::function<typename T::value_type(ytl::optional<typename T::const_reference>,ytl::optional<typename T::const_reference>)>& i_moreOp)
{
    return container::detail::merge(itInitA, itEndA, itInitB, itEndB, itInitOut, i_moreOp);
}
template<typename Iterator, typename IIterator>
inline IIterator merge(const container::detail::cConstIterableBase<Iterator>& iterableA, const container::detail::cConstIterableBase<Iterator>& iterableB, container::detail::cIterableBase<IIterator>& iterableOut, const ytl::function<typename Iterator::value_type(ytl::optional<typename Iterator::const_reference>,ytl::optional<typename Iterator::const_reference>)>& i_moreOp)
{
    typename Iterator::const_iterator_type itInitA = iterableA.cbegin();
    typename Iterator::const_iterator_type itEndA = iterableA.cend();
    typename Iterator::const_iterator_type itInitB = iterableB.cbegin();
    typename Iterator::const_iterator_type itEndB = iterableB.cend();

    return container::detail::merge(itInitA, itEndA, itInitB, itEndB, iterableOut, i_moreOp);
}
template<typename Iterator>
inline Iterator find(Iterator itInit, Iterator itEnd, typename Iterator::const_reference i_val)
{
    return container::detail::find_if(itInit, itEnd, ytl::function<bool(typename Iterator::const_reference)>([&i_val](typename Iterator::const_reference i_currVal){ return i_currVal == i_val; }));
}
template<typename Iterator>
inline typename Iterator::const_iterator_type find(const container::detail::cIterableBase<Iterator>& iterable, typename Iterator::const_reference i_val)
{
    typename Iterator::const_iterator_type itInit = iterable.cbegin();
    typename Iterator::const_iterator_type itEnd = iterable.cend();

    return container::detail::find_if(itInit, itEnd, ytl::function<bool(typename Iterator::const_reference)>([&i_val](typename Iterator::const_reference i_currVal){ return i_currVal == i_val; }));
}
template<typename T>
inline T find_if(T itInit, T itEnd, const ytl::function<bool(typename T::const_reference)>& i_findOp)
{
    return container::detail::find_if(itInit, itEnd, i_findOp);
}
template<typename Iterator>
inline typename Iterator::const_iterator_type find_if(const container::detail::cIterableBase<Iterator>& iterable, const ytl::function<bool(typename Iterator::const_reference)>& i_findOp)
{
    typename Iterator::const_iterator_type itInit = iterable.cbegin();
    typename Iterator::const_iterator_type itEnd = iterable.cend();

    return container::detail::find_if(itInit, itEnd, i_findOp);
}
template<typename T>
inline typename T::difference_type distance(T itInit, T itEnd)
{
    return container::detail::distance(itInit, itEnd);
}
template<typename T>
inline T initialize(T itInit, T itEnd, const std::initializer_list<typename T::value_type>& i_initializerList)
{
    return container::detail::initialize(itInit, itEnd, i_initializerList);
}
template<typename Iterator>
inline typename Iterator::iterator_type initialize(container::detail::cConstIterableBase<Iterator>& iterable, const std::initializer_list<typename Iterator::value_type>& i_initializerList)
{
    typename Iterator::iterator_type itInit = iterable.begin();
    typename Iterator::iterator_type itEnd = iterable.end();

    return container::detail::initialize(itInit, itEnd, i_initializerList);
}
template<typename Iterator, typename T>
inline typename Iterator::iterator_type assign(container::detail::cIterableBase<Iterator>& iterableOut, T itInit, T itEnd)
{
    return container::detail::initialize(iterableOut, itInit, itEnd);
}
template<typename Iterator>
inline typename Iterator::iterator_type assign(container::detail::cIterableBase<Iterator>& iterableOut, const container::detail::cConstIterableBase<Iterator>& iterableIn)
{
    typename Iterator::const_iterator_type itInit = iterableIn.cbegin();
    typename Iterator::const_iterator_type itEnd = iterableIn.cend();

    return container::detail::assign(iterableOut, itInit, itEnd);
}
template<typename Iterator>
inline typename Iterator::iterator_type assign(container::detail::cIterableBase<Iterator>& iterableOut, const std::initializer_list<typename Iterator::value_type>& i_initializerList)
{
    return container::detail::assign(iterableOut, i_initializerList);
}
template<typename T, typename TT>
inline typename TT::iterator_type transform(T itInitInput, T itEndInput, TT itInitOutput, const ytl::function<typename T::value_type(typename T::const_reference)>& i_transformOp)
{
    return container::detail::transform(itInitInput, itEndInput, itInitOutput, i_transformOp);
}
template<typename Iterator, typename IIterator>
inline IIterator transform(const container::detail::cConstIterableBase<Iterator>& iterableInput, container::detail::cIterableBase<IIterator>& iterableOutput, const ytl::function<typename Iterator::value_type(typename Iterator::const_reference)>& i_transformOp)
{
    typename Iterator::const_iterator_type itInitInput = iterableInput.cbegin();
    typename Iterator::const_iterator_type itEndInput = iterableInput.cend();

    return container::detail::transform(itInitInput, itEndInput, iterableOutput, i_transformOp);
}

}
# 3 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp" 2

namespace yame
{
namespace container
{

template<typename T, typename A>
typename cArray<T,A>::value_type* cArray<T,A>::acquireMem(size_t size)
{
    return (value_type*)m_alloc.allocate(size, sizeof(T));
}
template<typename T, typename A>
void cArray<T,A>::releaseMem(value_type* node)
{
    if(node)
    {

        m_alloc.deallocate((void *)node);
    }

    return;
}
template<typename T, typename A>
typename cArray<T,A>::value_type* cArray<T,A>::allocate(size_t size)
{
    value_type* mem = (size > 0) ? acquireMem(size) : this->getHead();


    if(mem != this->getHead())
    {
        value_type* pointer = mem;
        for(size_t i=0;i<size;i++)
        {
            if(pointer)
            {
                construct(pointer);
                pointer++;
            }
        }
    }
    return mem;
}
template<typename T, typename A>
typename cArray<T,A>::value_type* cArray<T,A>::reallocate(value_type* ptr, size_t oldSize, size_t newSize)
{

    value_type* mem = (newSize > 0) ? acquireMem(newSize) : this->getHead();


    if(mem != this->getHead())
    {
        value_type* pointer = mem;

        for(size_t i=0;i<newSize;i++)
        {
            if(pointer)
            {
                (i < oldSize) ? construct(pointer, mpl::move(ptr[i])) : construct(pointer);
                pointer++;
            }
        }


        deallocate(ptr);
    }
    else
    {

        ((false && "wtf") ? static_cast<void> (0) : __assert_fail ("false && \"wtf\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 71, __PRETTY_FUNCTION__));
        mem = ptr;
    }

    return mem;
}
template<typename T, typename A>
void cArray<T,A>::deallocate(value_type* node, bool destroy)
{
    if(node != this->getHead())
    {
        ((isInBounds(node) && "Trying to free unbounded node!") ? static_cast<void> (0) : __assert_fail ("isInBounds(node) && \"Trying to free unbounded node!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 82, __PRETTY_FUNCTION__));

        if(destroy)
        {
            destruct(node,getAddressAtIndex(m_size));
        }


        releaseMem(node);
        node = __null;
    }

    return;
}
template<typename T, typename A>
bool cArray<T,A>::isInBounds(const value_type* address) const
{
    return address >= this->getRootNode() && address - this->getRootNode() <= m_size;
}
template<typename T, typename A>
void cArray<T,A>::construct(const value_type* address)
{

    if(address != this->getHead())
    {
        mpl::construct(address);
    }

    return;
}
template<typename T, typename A>
template<typename TT, typename ... TTs>
void cArray<T,A>::construct(const value_type* address, TT&& i_arg, TTs&& ... i_args)
{
    if(address != this->getHead())
    {
        new(const_cast<typename mpl::drop_constness<value_type>::type*>(address)) T(mpl::forward<TT>(i_arg), mpl::forward<TTs>(i_args)...);
    }

    return;
}
template<typename T, typename A>
void cArray<T,A>::destruct(value_type* addressInit, value_type* addressEnd)
{
    ((addressInit && addressEnd && addressInit <= addressEnd && "Unconsistent address range") ? static_cast<void> (0) : __assert_fail ("addressInit && addressEnd && addressInit <= addressEnd && \"Unconsistent address range\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 126, __PRETTY_FUNCTION__));


    value_type* currAddress = addressInit;

    for(;currAddress!=addressEnd;currAddress++)
    {
        (*currAddress).~T();
    }

    return;
}
template<typename T, typename A>
template<typename TT>
void cArray<T,A>::assign(TT&& val, value_type* address)
{
    ((isInBounds(address) && "Out of bounds!") ? static_cast<void> (0) : __assert_fail ("isInBounds(address) && \"Out of bounds!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 142, __PRETTY_FUNCTION__));

    *address = mpl::forward<TT>(val);
}
template<typename T, typename A>
template<typename ... TT>
typename cArray<T,A>::lreference cArray<T,A>::_insert(size_t pos, TT&& ... i_args)
{
    cArray data;

    if(pos > m_size)
    {
        pos = m_size;
    }

    if(m_size > pos)
    {

        data.reserve(m_size-pos+1);
        for(size_t i=0;i < m_size - pos;i++)
        {
            data.construct(data.getAddressAtIndex(i), mpl::move(*getAddressAtIndex(pos+i)));
        }
        data.m_size = m_size - pos;
    }

    if(m_size + 1 >= m_capacity)
    {
        m_capacity = 2*(m_size + 1);
        this->setRootNode((this->getRootNode() == this->getHead()) ? allocate(m_capacity) : reallocate(this->getRootNode(),m_size,m_capacity));
    }

    construct(getAddressAtIndex(pos), mpl::forward<TT>(i_args)...);

    if(data.getSize())
    {

        for(size_t i=0;i<m_size-pos;i++)
        {
            construct(getAddressAtIndex(pos+1+i), mpl::move(*data.getAddressAtIndex(i)));
        }
    }

    m_size++;

    return *getAddressAtIndex(pos);
}
template<typename T, typename A>
cArray<T,A>::cArray()
: detail::cRandomAccessIterableBaseImpl<T,T&>()
, m_size(0)
, m_alloc(memory::cMemoryProvider<A>::acquire())
{
    m_capacity = 0;
}
template<typename T, typename A>
cArray<T,A>::cArray(const cArray& other)
: detail::cRandomAccessIterableBaseImpl<T,T&>()
, m_capacity(0)
, m_size(0)
, m_alloc(memory::cMemoryProvider<A>::acquire())
{
    m_capacity = other.getCapacity();
    m_size = other.getSize();
    this->setRootNode(allocate(m_capacity));

    for(size_t i=0;i<m_size;i++)
    {
        construct(getAddressAtIndex(i), *other.getAddressAtIndex(i));
    }
}
template<typename T, typename A>
cArray<T,A>::cArray(cArray&& other)
: detail::cRandomAccessIterableBaseImpl<T,T&>()
, m_capacity(0)
, m_size(0)
, m_alloc(memory::cMemoryProvider<A>::acquire())
{
    m_capacity = other.m_capacity;
    m_size = other.getSize();
    this->setRootNode(other.getRootNode());

    other.setRootNode(this->getHead());
    other.m_capacity = 0;
    other.m_size = 0;
}
template<typename T, typename A>
cArray<T,A>::cArray(const std::initializer_list<T>& i_initList)
: detail::cRandomAccessIterableBaseImpl<T,T&>()
, m_capacity(0)
, m_size(0)
, m_alloc(memory::cMemoryProvider<A>::acquire())
{
    yame::assign(*this, i_initList);
}
template<typename T, typename A>
cArray<T,A>::cArray(const_lreference value, u32 length)
: detail::cRandomAccessIterableBaseImpl<T,T&>()
, m_capacity(0)
, m_size(0)
, m_alloc(memory::cMemoryProvider<A>::acquire())
{
    m_size = length;
    m_capacity = 2*length;

    if(length > 0)
    {
        this->setRootNode(allocate(m_capacity));

        for(u32 i=0;i<this->length;i++)
        {
            construct(getAddressAtIndex(i), value);
        }
    }
}
template<typename T, typename A>
cArray<T,A>::cArray(rreference value, u32 length)
: detail::cRandomAccessIterableBaseImpl<T,T&>()
, m_capacity(0)
, m_size(0)
, m_alloc(memory::cMemoryProvider<A>::acquire())
{
    m_size = length;
    m_capacity = 2*length;

    if(length > 0)
    {
        this->setRootNode(allocate(m_capacity));

        for(u32 i=0;i<length;i++)
        {
            construct(getAddressAtIndex(i), mpl::move(value));
        }
    }
}
template<typename T, typename A>
cArray<T,A>::cArray(const value_type* data, u32 length)
: detail::cRandomAccessIterableBaseImpl<T,T&>()
, m_capacity(0)
, m_size(0)
, m_alloc(memory::cMemoryProvider<A>::acquire())
{
    m_size = length;
    m_capacity = 2*length;

    if(length > 0)
    {
        this->setRootNode(allocate(m_capacity));

        for(size_t i=0;i<length;i++)
        {
            construct(getAddressAtIndex(i), data[i]);
        }
    }
}
template<typename T, typename A>
cArray<T,A>::cArray(const std::vector<T>& other)
: detail::cRandomAccessIterableBaseImpl<T,T&>()
, m_capacity(0)
, m_size(0)
, m_alloc(memory::cMemoryProvider<A>::acquire())
{
    m_size = other.size();
    m_capacity = 2*other.size();

    if(other.empty() == false)
    {
        this->setRootNode(allocate(m_capacity));

        for(size_t i=0;i<m_size;i++)
        {
            construct(getAddressAtIndex(i), other[i]);
        }
    }
}
template<typename T, typename A>
cArray<T,A>::~cArray()
{

    deallocate(this->getRootNode());
    this->setRootNode(this->getHead());
    m_capacity = 0;
    m_size = 0;
}
template<typename T, typename A>
cArray<T,A>& cArray<T,A>::operator=(const cArray& other)
{
    u32 newCap = other.m_capacity;

    deallocate(this->getRootNode());

    this->setRootNode(allocate(newCap));
    m_capacity = newCap;
    m_size = other.getSize();

    for(size_t i=0;i<m_size;i++)
    {
        assign(*other.getAddressAtIndex(i), getAddressAtIndex(i));
    }

    return *this;
}
template<typename T, typename A>
cArray<T,A>& cArray<T,A>::operator=(cArray&& other)
{
    deallocate(this->getRootNode());

    m_capacity = other.m_capacity;
    m_size = other.getSize();
    this->setRootNode(other.getRootNode());

    other.setRootNode(this->getHead());
    other.m_capacity = 0;
    other.m_size = 0;

    return *this;
}
template<typename T, typename A>
cArray<T,A> cArray<T,A>::operator+(const cArray<T,A>& other) const
{
    cArray<T,A> res = cArray<T,A>();
    size_t thisSize = m_size;


    res.reserve(thisSize+other.getSize());


    if(thisSize > 0)
    {
        res.insert(res.cbegin(),this->cbegin(),this->cend());
    }


    if(other.getSize() > 0)
    {
        res.insert(res.cend(),other.cbegin(),other.cend());
    }

    return res;
}
template<typename T, typename A>
cArray<T,A>& cArray<T,A>::operator+=(const cArray<T,A>& other)
{
    *this = *this + other;

    return *this;
}
template<typename T, typename A>
typename cArray<T,A>::const_lreference cArray<T,A>::operator[](const u32 index) const
{
    ((index >= 0 && index < m_size && "Index out of bounds") ? static_cast<void> (0) : __assert_fail ("index >= 0 && index < m_size && \"Index out of bounds\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 392, __PRETTY_FUNCTION__));

    return *getAddressAtIndex(index);
}
template<typename T, typename A>
typename cArray<T,A>::lreference cArray<T,A>::operator[](const u32 index)
{

    ((index >= 0 && index < m_size && "Index out of bounds") ? static_cast<void> (0) : __assert_fail ("index >= 0 && index < m_size && \"Index out of bounds\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 400, __PRETTY_FUNCTION__));

    return *getAddressAtIndex(index);
}
template<typename T, typename A>
typename cArray<T,A>::lreference cArray<T,A>::at(const u32 index)
{

    ((index >= 0 && index < m_size && "Index out of bounds") ? static_cast<void> (0) : __assert_fail ("index >= 0 && index < m_size && \"Index out of bounds\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 408, __PRETTY_FUNCTION__));

    return *getAddressAtIndex(index);
}
template<typename T, typename A>
bool cArray<T,A>::operator==(const cArray& other) const
{
    return (m_size != other.getSize()) ? false : memcmp(this->getRootNode(),other.getArray(),m_size*sizeof(T))==0;
}
template<typename T, typename A>
bool cArray<T,A>::operator!=(const cArray& other) const
{
    return !operator==(other);
}
template<typename T, typename A>
cArray<T,A> cArray<T,A>::subArr(const u32 initPos, const u32 length) const
{
    cArray res = cArray();
    res.reserve(length);

    for(u32 i=0;i<length && (initPos+i)<m_size;i++)
    {
        res.push_back(*getAddressAtIndex(initPos+i));
    }

    return res;
}
template<typename T, typename A>
const typename cArray<T,A>::value_type* cArray<T,A>::getArray() const
{
    return this->getRootNode();
}
template<typename T, typename A>
typename cArray<T,A>::value_type* cArray<T,A>::getArray()
{
    return this->getRootNode();
}
template<typename T, typename A>
void cArray<T,A>::reset(T value)
{
    for(u32 i=0;i<m_size;i++)
    {
        assign(value, getAddressAtIndex(i));
    }

    return;
}
template<typename T, typename A>
void cArray<T,A>::reset(const T& value)
{
    for(u32 i=0;i<m_size;i++)
    {
        assign(value,getAddressAtIndex(i));
    }

    return;
}
template<typename T, typename A>
void cArray<T,A>::reset(T&& value)
{
    for(u32 i=0;i<m_size;i++)
    {
        assign(mpl::move(value),getAddressAtIndex(i));
    }

    return;
}
template<typename T, typename A>
void cArray<T,A>::insert(const_iterator_type itPos, const_iterator_type itOtherInit, const_iterator_type itOtherEnd)
{
    size_t localPos = (itPos != this->cend()) ? itPos - this->constructConstIteratorAtNode(this->getRootNode()) : m_size;

    ((localPos <= m_size && "Inserting out of bounds") ? static_cast<void> (0) : __assert_fail ("localPos <= m_size && \"Inserting out of bounds\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 480, __PRETTY_FUNCTION__));


    u32 otherSize = itOtherEnd - itOtherInit;

    reserve(2*(m_size+otherSize+1));

    for(const_iterator_type itOther=itOtherInit;itOther!=itOtherEnd;++itOther)
    {
        _insert(localPos,*itOther);
        localPos++;
    }

    return;
}
template<typename T, typename A>
template<typename ... TT>
typename cArray<T,A>::lreference cArray<T,A>::insert(const_iterator_type itPos, TT&& ... i_args)
{
    size_t localPos = (itPos != this->cend()) ? itPos - this->constructConstIteratorAtNode(this->getRootNode()) : m_size;

    ((localPos <= m_size && "Inserting out of bounds") ? static_cast<void> (0) : __assert_fail ("localPos <= m_size && \"Inserting out of bounds\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 501, __PRETTY_FUNCTION__));

    return _insert(localPos,mpl::forward<TT>(i_args)...);
}
template<typename T, typename A>
template<typename ... TT>
typename cArray<T,A>::lreference cArray<T,A>::push_back(TT&& ... i_args)
{
    return _insert(m_size,mpl::forward<TT>(i_args)...);
}
template<typename T, typename A>
template<typename ... TT>
typename cArray<T,A>::lreference cArray<T,A>::push_front(TT&& ... i_args)
{
    return _insert(0,mpl::forward<TT>(i_args)...);
}
template<typename T, typename A>
typename cArray<T,A>::lreference cArray<T,A>::front()
{
    return *getAddressAtIndex(0);
}
template<typename T, typename A>
typename cArray<T,A>::lreference cArray<T,A>::back()
{
    return *getAddressAtIndex(m_size - 1);
}
template<typename T, typename A>
typename cArray<T,A>::const_lreference cArray<T,A>::front() const
{
    return *getAddressAtIndex(0);
}
template<typename T, typename A>
typename cArray<T,A>::const_lreference cArray<T,A>::back() const
{
    return *getAddressAtIndex(m_size - 1);
}
template<typename T, typename A>
void cArray<T,A>::resize(u32 size)
{
    if(size > m_capacity)
    {
        u32 prevCap = m_capacity;
        m_capacity = 2*size;
        if(this->getRootNode() != this->getHead())
        {

            this->setRootNode(reallocate(this->getRootNode(),m_size,m_capacity));
        }
        else
        {
            this->setRootNode(allocate(m_capacity));
        }
    }
    else if(size < m_size)
    {
        destruct(getAddressAtIndex(size),getAddressAtIndex(m_size));
    }

    m_size = size;

    return;
}
template<typename T, typename A>
void cArray<T,A>::pop()
{
    if(this->getRootNode() != this->getHead())
    {
        resize(m_size-1);
    }
}
template<typename T, typename A>
void cArray<T,A>::clear()
{
    if(this->getRootNode() != this->getHead())
    {
        resize(0);
    }

    return;
}
template<typename T, typename A>
typename cArray<T,A>::iterator_type cArray<T,A>::erase(u32 initPos, u32 length)
{
    if(initPos < m_size)
    {
        if(initPos + length > m_size)
        {
            length = m_size - initPos;
        }

        if(this->getRootNode() != this->getHead())
        {
            for(size_t i=initPos;i<m_size-length;i++)
            {
                assign(mpl::move(*getAddressAtIndex(i+length)),getAddressAtIndex(i));
            }

            for(size_t i=m_size-length;i<m_size;i++)
            {
                construct(getAddressAtIndex(i));
            }
        }

        m_size -= length;

        return this->constructIteratorAtNode(this->getRootNode() + initPos);
    }

    return this->constructIteratorAtNode(iterator_type::m_pHead);
}
template<typename T, typename A>
size_t cArray<T,A>::getCapacity() const
{
    return m_capacity;
}
template<typename T, typename A>
size_t cArray<T,A>::getSize() const
{
    return m_size;
}
template<typename T, typename A>
void cArray<T,A>::reserve(u32 newCap)
{
    this->setRootNode((this->getRootNode() == this->getHead()) ? allocate(newCap) : reallocate(this->getRootNode(),m_size,newCap));

    m_capacity = newCap;

    return;
}
template<typename T, typename A>
cArray<s16> cArray<T,A>::find(const cArray<T>& other) const
{

    size_t thisSize = m_size;
    size_t otherSize = other.getSize();
    bool precond = thisSize>0 && otherSize>0 && thisSize>=otherSize;
    cArray<s16> res;
    u32 numOk = 0;
    u32 counterThis, counterOther;
    counterOther = 0;
    const value_type* block = other.getArray();
    u32 blockSize = otherSize;
    s8 shift;

    if(precond)
    {
        counterThis = 0;
        shift = 1;


        cArray<s16> kmpTable;

        kmpTable.reserve(otherSize);

        kmpTable.push_back(-1);
        kmpTable.push_back(0);

        size_t kmpPos = 2;
        size_t kmpCond = 0;

        while(kmpPos < otherSize)
        {
            if(other[kmpPos-1] == other[kmpCond])
            {
                kmpCond++;
                kmpTable.push_back(kmpCond);
                kmpPos++;
            }
            else if(kmpCond > 0)
            {
                kmpCond = kmpTable[kmpCond];
            }
            else
            {
                kmpTable.push_back(0);
                kmpPos++;
            }
        }


        while(counterThis+counterOther < thisSize)
        {
            if(*getAddressAtIndex(counterThis+counterOther) == other[counterOther])
            {
                counterOther++;
                if(counterOther == otherSize)
                {
                    numOk++;
                    res.push_back(counterThis);
                    counterThis += counterOther;
                    counterOther = 0;
                }
            }
            else
            {
                if(kmpTable[counterOther] > 0)
                {
                    counterThis += shift*(counterOther - kmpTable[counterOther]);
                    counterOther = kmpTable[counterOther];
                }
                else if(kmpTable[counterOther] != -1)
                {
                    counterThis += shift*(counterOther + 1);
                    counterOther = 0;
                }
                else
                {
                    counterOther = 0;
                    counterThis += shift;
                }
            }
        }

    }

    return res;
}
template<typename T, typename A>
s16 cArray<T,A>::find_first_of(const_lreference other) const
{
    cArray<s16> resFind = find(other);
    s16 res = (resFind.getSize() > 0) ? resFind[0] : cArray<s16>::npos;

    return res;
}
template<typename T, typename A>
s16 cArray<T,A>::find_last_of(const_lreference other) const
{
    cArray<s16> resFind = find(other);
    s16 res = (resFind.getSize() > 0) ? resFind[resFind.getSize()-1] : cArray<s16>::npos;

    return res;
}
template<typename T, typename A>
void cArray<T,A>::replace(u32 prevPos, u32 newPos)
{
    s8 sign = (prevPos > newPos) ? -1 : 1;
    size_t thisSize = m_size;
    u32 counter = 0;

    if(prevPos < thisSize && newPos < thisSize)
    {
        value_type tmp = *getAddressAtIndex(prevPos);

        while((newPos-prevPos)*sign > counter)
        {
            *getAddressAtIndex(prevPos+counter*sign) = *getAddressAtIndex(prevPos+(counter+1)*sign);
            counter++;
        }

        *getAddressAtIndex(newPos) = tmp;
    }

    return;
}
template<typename T, typename A>
cArray<cArray<T> > cArray<T,A>::tokenize(cArray<T> stream, value_type separator)
{
    cArray<cArray<T> > res;
    cArray<s16> tokens = stream.find(separator);

    if(tokens.getSize() > 0)
    {
        u8 counter = 0;
        size_t initBound = 0;

        while(counter < tokens.getSize())
        {
            size_t endBound = tokens[counter];
            res.push_back(stream.subArr(initBound,endBound-initBound));
            initBound = endBound+1;
            counter++;
        }

        res.push_back(stream.subArr(initBound,stream.getSize()-initBound));
    }
    else
    {
        res = stream;
    }

    return res;
}
template<typename T, typename A>
cArray<cArray<T> > cArray<T,A>::tokenize(value_type separator) const
{
    return tokenize(*this,separator);
}
template<typename T, typename A>
bool cArray<T,A>::equal(const cArray& arrayA, const cArray& arrayB)
{
    bool res = true;
    u32 counter = 0;
    const value_type* dataA = arrayA.getArray();
    const value_type* dataB = arrayB.getArray();
    size_t sizeA = arrayA.getSize();
    size_t sizeB = arrayB.getSize();

    u32 maxSize = (sizeA > sizeB) ? sizeA : sizeB;

    while(maxSize > counter)
    {
        if(*dataA != *dataB)
        {
            res = false;
            break;
        }
        counter++;
        dataA++;
        dataB++;
    }

    return res;
}
template<typename T, typename A>
bool cArray<T,A>::equal(const cArray& other) const
{
    bool res = equal(*this,other);

    return res;
}
template<typename T, typename A>
u32 cArray<T,A>::copyBlock(const value_type* source, value_type* dest, u32 numBits, u8 offset, u8 endianess)
{
    u32 numBytes = numBits>>3;
    u32 numRemBits = numBits - numBytes*8;
    u32 res = numBytes*8 + numRemBits;
    u8 sizeBlock = sizeof(T)/sizeof(u8);


    if(offset && numBits)
    {
        numRemBits = numBits - (8-offset);
        numBytes = numRemBits>>3;
        numRemBits = numRemBits - numBytes*8;
        if(endianess)
        {
            *((u8 *)dest) = (((*((u8 *)source) * 0x0802LU & 0x22110LU) | (*((u8 *)source) * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16)&(~(1<<(8-offset)));
        }
        else
        {
            *((u8 *)dest) = *((u8 *)source)&(~(1<<(8-offset)));
        }
    }


    for(u32 i=0;i<numBytes;i++)
    {
        for(u8 j=0;j<sizeBlock;j++)
        {
            if(endianess)
            {
                *((u8 *)(dest)+(offset>0)+i*sizeBlock+j) = ((*((u8 *)(source)+(offset>0)+i*sizeBlock+j) * 0x0802LU & 0x22110LU) | (*((u8 *)(source)+(offset>0)+i*sizeBlock+j) * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
            }
            else
            {
                *((u8 *)(dest)+(offset>0)+i*sizeBlock+j) = *((u8 *)(source)+(offset>0)+i*sizeBlock+j);
            }
        }
    }

    if(numRemBits)
    {
        if(endianess)
        {
            *((u8 *)(dest)+(offset>0)+sizeBlock*numBytes) = (((*((u8 *)(source)+(offset>0)+sizeBlock*numBytes) * 0x0802LU & 0x22110LU) | (*((u8 *)(source)+(offset>0)+sizeBlock*numBytes) * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16)&((1<<numRemBits));
        }
        else
        {
            *((u8 *)(dest)+(offset>0)+sizeBlock*numBytes) = *((u8 *)(source)+(offset>0)+sizeBlock*numBytes)&((1<<numRemBits));
        }
    }

    return res;
}
template<typename T, typename A>
typename cArray<T,A>::value_type* cArray<T,A>::getAddressAtIndex(size_t index) const
{
    ((index >= 0 && index < m_capacity && "Index out of bounds") ? static_cast<void> (0) : __assert_fail ("index >= 0 && index < m_capacity && \"Index out of bounds\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 879, __PRETTY_FUNCTION__));

    return this->getRootNode() + index;
}
template<typename T, typename A>
typename cArray<T,A>::pointer_type cArray<T,A>::getFirstElem() const
{
    return (m_size > 0) ? this->getRootNode() : this->getHead();
}
template<typename T, typename A>
typename cArray<T,A>::pointer_type cArray<T,A>::getLastElem() const
{
    return (m_size > 0) ? this->getRootNode() + m_size - 1 : __null;
}
template<typename T, typename A>
typename cArray<T,A>::pointer_type cArray<T,A>::getNextElem(pointer_type currNode) const
{
    if(m_size > 0)
    {
        if(currNode + 1 - this->getRootNode() < m_size)
        {
            return currNode + 1;
        }
        else
        {
            return this->getHead();
        }
    }
    else
    {
        return this->getHead();
    }
}
template<typename T, typename A>
typename cArray<T,A>::pointer_type cArray<T,A>::getPrevElem(pointer_type currNode) const
{
    if(m_size > 0)
    {
        if(currNode > this->getRootNode())
        {
            return currNode - 1;
        }
        else
        {
            return this->getHead();
        }
    }
    else
    {
        return this->getHead();
    }
}
template<typename T, typename A>
typename cArray<T,A>::pointer_type cArray<T,A>::shiftNodeByIndex(pointer_type currNode, int index) const
{
    const int finalIndex = (currNode - this->getRootNode()) + index;

    return (finalIndex >= 0 && finalIndex < m_size) ? currNode + static_cast<size_t>(index) : this->getHead();
}
template<typename T, typename A>
size_t cArray<T,A>::getIndexOfNode(pointer_type node) const
{
    if(node != this->getHead())
    {
        ((isInBounds(node) && "Trying to free unbounded node!") ? static_cast<void> (0) : __assert_fail ("isInBounds(node) && \"Trying to free unbounded node!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 943, __PRETTY_FUNCTION__));

        return node - this->getRootNode();
    }
    else
    {
        return m_size;
    }
}
template<typename T, typename A>
void cArray<T,A>::eraseNode(pointer_type i_valueNode)
{
    pointer_type rootNode = this->getRootNode();

    size_t localPos = i_valueNode - rootNode;

    ((localPos >= 0 && localPos < m_size && "Inserting out of bounds") ? static_cast<void> (0) : __assert_fail ("localPos >= 0 && localPos < m_size && \"Inserting out of bounds\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cArray.tpp", 959, __PRETTY_FUNCTION__));

    erase(localPos);

    return;
}
template<typename T, typename A>
typename cArray<T,A>::pointer_type cArray<T,A>::addNode(add_type i_value)
{
    _insert(m_size,mpl::forward<add_type>(i_value));

    return getLastElem();
}

}
}

template<typename T, typename A>
yame::container::cArray<T,A>& operator<<(yame::container::cArray<T,A>& o_array, const yame::container::cArray<T,A>& i_array)
{
    o_array.insert(o_array.cend(), i_array.cbegin(), i_array.cend());

    return o_array;
}
template<typename T, typename A>
yame::container::cArray<T,A>& operator>>(const yame::container::cArray<T,A>& i_array, yame::container::cArray<T,A>& o_array)
{
    o_array.insert(o_array.cbegin(), i_array.cbegin(), i_array.cend());

    return o_array;
}
template<typename T, typename A>
yame::container::cArray<T,A>& operator<<(yame::container::cArray<T,A>& o_array, const typename yame::container::cArray<T,A>::particle& i_value)
{
    o_array.push_back(i_value);

    return o_array;
}
template<typename T, typename A>
yame::container::cArray<T,A>& operator>>(const typename yame::container::cArray<T,A>::particle& i_value, yame::container::cArray<T,A>& o_array)
{
    o_array.push_front(i_value);

    return o_array;
}
# 180 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cArray.h" 2
# 25 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cString.h" 2



namespace yame
{
namespace container
{

template<typename A = memory::cTypedSystemAllocator<char> >
class cString : public cArray<char,A>
{
private:
    char m_string[12];

    protected:
    void endString();
    u16 getLengthStringArray(const char *data);
    bool isStaticAddress(const char* address) const;
    bool isStaticAddress() const;
    bool isInBounds(const char* itPos) const;
    char* acquireMem(size_t size);
    void releaseMem(char* node);

public:
    static const char invalid_value = '\0';
    typedef typename cArray<char,A>::iterator_type iterator_type;
    typedef typename cArray<char,A>::const_iterator_type const_iterator_type;
    typedef typename cArray<char,A>::reverse_iterator_type reverse_iterator_type;
    typedef typename cArray<char,A>::const_reverse_iterator_type const_reverse_iterator_type;
    typedef typename cArray<char,A>::iterable_public_interface iterable_public_interface;
    typedef typename cArray<char,A>::pointer_type pointer_type;


    cString<A>();
    cString<A>(const cArray<char,A>& other);
    cString<A>(cArray<char,A>&& other);
    cString<A>(const cString<A>& other);
    cString<A>(cString<A>&& other);
    cString<A>(const char *data);
    cString<A>(const char *data, u32 length);
    cString<A>(char value, u16 length=1);
    cString<A>(std::string str);
    ~cString<A>();
    void resize(u16 size, u16 initPos=0);
    const char *getStr() const;
    char *getStr();
    cString<A> subStr(const u32 initPos, const u32 length) const;
    cString<A> subStr(const u32 initPos) const;
    std::string getStdString() const;
    template<typename ... T>
    void Scan(const char *format,T...args) const;
    static cString<A> Format(const char *format, ... );
    static cArray<cString<A> > tokenize(const cString<A>& stream, char separator);
    cArray<cString<A> > tokenize(char separator) const;
    cString<A> subArr(const u32 initPos, const u32 length) const;
    static bool equal(const cString<A>& stringA, const cString<A>& stringB);
    bool equal(const cString<A>& other) const;
    cString<A>& operator=(const cString<A>& other);
    cString<A>& operator=(cString<A>&& other);
    cString<A> operator+(const cString<A>& other) const;
    cString<A>& operator+=(const char& append);
    cString<A>& operator +=(const cString<A>& append);
    cString<A>& operator<<(const cString<A>& append);
    bool operator==(const cString<A>& other) const;
    bool operator!=(const cString<A>& other) const;
    bool operator<(const cString<A>& other) const;
    bool operator>(const cString<A>& other) const;
    cArray<char,A>& operator()();
};

template<typename T, typename A = memory::cTypedSystemAllocator<T > >
struct listComp
{
    bool operator()(const yame::container::cArray<T,A>& lhs, const yame::container::cArray<T,A>& rhs) const
    {
        return lhs<rhs;
    }
};

typedef cString<memory::cTypedSystemAllocator<char> > string;
typedef listComp<char> stringComp;
}
}

inline yame::container::string operator+(const char* i_lhs, const yame::container::string& i_rhs);

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cString.tpp" 1

namespace yame
{

namespace container
{
template<typename A>
void cString<A>::endString()
{
    if(this->m_size > 0)
    {
        char cmp;
        memset(&cmp,invalid_value,sizeof(char));

        cArray<char,A>::push_back(cmp);

        this->m_size--;
    }

    return;
}
template<typename A>
u16 cString<A>::getLengthStringArray(const char *data)
{
    u16 res = 0;
    char cmp;

    memset(&cmp,invalid_value,sizeof(char));

    while(data+res && memcmp(data+res,&cmp,sizeof(char)) != 0)
    {
        res++;
    }

    return res;
}
template<typename A>
bool cString<A>::isStaticAddress(const char* address) const
{
    return address == m_string;
}
template<typename A>
bool cString<A>::isStaticAddress() const
{
    return this->getRootNode() == m_string;
}
template<typename A>
bool cString<A>::isInBounds(const char* itPos) const
{
    bool isBounded = isStaticAddress() || cArray<char,A>::isInBounds(itPos);

    ((isBounded && "Bad bounds!") ? static_cast<void> (0) : __assert_fail ("isBounded && \"Bad bounds!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/detail/cString.tpp", 52, __PRETTY_FUNCTION__));

    return isBounded;
}
template<typename A>
char* cString<A>::acquireMem(size_t size)
{
    return (size < 12) ? m_string : cArray<char,A>::acquireMem(size);
}
template<typename A>
void cString<A>::releaseMem(char* node)
{
    if(!isStaticAddress(node))
    {
        cArray<char,A>::releaseMem(node);
    }

    return;
}
template<typename A>
cString<A>::cString() : cArray<char,A>()
{
    memset(m_string,0,sizeof(char)*12);
    this->m_size = 0;
    this->setRootNode(m_string);
    this->m_capacity = 12;
}
template<typename A>
cString<A>::cString(const cArray<char,A>& other)
{
    this->m_size = other.getSize();
    this->setRootNode(cArray<char,A>::allocate(other.getCapacity()));
    this->m_capacity = (isStaticAddress(this->getRootNode())) ? 12 : other.getCapacity();


    memcpy(this->getRootNode(),other.getArray(),sizeof(char)*other.getSize());

    endString();
}
template<typename A>
cString<A>::cString(cArray<char,A>&& other) : cArray<char,A>(mpl::move(other))
{
    endString();
}
template<typename A>
cString<A>::cString(const cString<A>& other)
{
    this->m_size = other.getSize();
    this->setRootNode(cArray<char,A>::allocate(other.getCapacity()));
    this->m_capacity = (isStaticAddress(this->getRootNode())) ? 12 : other.getCapacity();


    memcpy(this->getRootNode(),other.getStr(),sizeof(char)*other.getSize());

    endString();
}
template<typename A>
cString<A>::cString(cString<A>&& other) : cArray<char,A>()
{

    if(other.isStaticAddress())
    {

        this->m_size = other.getSize();
        this->setRootNode(cArray<char,A>::allocate(other.getCapacity()));
        this->m_capacity = (isStaticAddress(this->getRootNode())) ? 12 : other.getCapacity();


        memcpy(this->getRootNode(),other.getStr(),sizeof(char)*other.getSize());

        endString();


        other.setRootNode(this->getHead());
        other.m_capacity = 0;
        other.m_size = 0;
    }
    else
    {
        cArray<char,A>::operator=(mpl::move(other));
    }
}
template<typename A>
cString<A>::cString(const char *data)
{
    u32 dataSize = getLengthStringArray(data);
    this->m_size = dataSize;
    this->setRootNode(acquireMem(dataSize+1));
    this->m_capacity = (isStaticAddress(this->getRootNode())) ? 12 : dataSize+1;


    memcpy(this->getRootNode(),data,sizeof(char)*dataSize);

    endString();
}
template<typename A>
cString<A>::cString(const char *data, u32 length)
{
    this->m_size = length;
    this->setRootNode(acquireMem(length+1));
    this->m_capacity = (isStaticAddress(this->getRootNode())) ? 12 : length+1;


    memcpy(this->getRootNode(),data,sizeof(char)*length);

    endString();
}
template<typename A>
cString<A>::cString(char value, u16 length)
{
    this->m_size = length;
    this->m_capacity = length+1;
    this->setRootNode(acquireMem(length+1));

    pointer_type currChar = this->getFirstElem();

    for(u32 i=0;i<this->m_size;i++)
    {
        *(currChar + i) = value;
    }

    endString();
}
template<typename A>
cString<A>::cString(std::string str)
{
    u32 strSize = str.size();
    this->m_size = strSize;
    this->m_capacity = strSize+1;
    this->setRootNode(acquireMem(strSize+1));


    memcpy(this->getRootNode(),str.c_str(),sizeof(char)*strSize);

    endString();
}
template<typename A>
cString<A>::~cString()
{
    if(isStaticAddress(this->getRootNode()))
    {

        this->setRootNode(this->getHead());
    }
}
template<typename A>
void cString<A>::resize(u16 size, u16 initPos)
{
    cArray<char,A>::resize(size);

    endString();

    return;
}
template<typename A>
const char* cString<A>::getStr() const
{
    return cArray<char,A>::getArray();
}
template<typename A>
char* cString<A>::getStr()
{
    return cArray<char,A>::getArray();
}
template<typename A>
cString<A> cString<A>::subStr(const u32 initPos, const u32 length) const
{
    return cArray<char,A>::subArr(initPos,length);
}
template<typename A>
cString<A> cString<A>::subStr(const u32 initPos) const
{
    return cArray<char,A>::subArr(initPos,cArray<char,A>::getSize() - initPos);
}
template<typename A>
std::string cString<A>::getStdString() const
{
    std::string res(this->getRootNode());

    return res;
}
template<typename A>
template<typename ... T>
void cString<A>::Scan(const char *format,T...args) const
{
    if(format)
    {
        sscanf(this->getRootNode(),format,args...);
    }

    return;
}
template<typename A>
cString<A> cString<A>::Format(const char *format, ... )
{
    char entry[64];
    va_list args;
    __builtin_va_start(args,format);
    bool formatting = false;
    cString<A> resFormat = cString<A>();

    while (*format != '\0')
    {
        memset(entry,0,sizeof(char)*64);
        if(!formatting)
        {
            if (*format == '%')
            {
                formatting = true;
            }
            else
            {
                resFormat.push_back(*format);
            }
        }
        else
        {
            if (*format == 'd')
            {
                int i = __builtin_va_arg(args,int);
                sprintf(entry,"%d",i);
                resFormat += entry;
            }
            else if (*format == 'u')
            {
                int i = __builtin_va_arg(args,int);
                sprintf(entry,"%u",i);
                resFormat += entry;
            }
            else if (*format == 'c')
            {

                int c = __builtin_va_arg(args,int);
                sprintf(entry,"%c",c);
                resFormat += entry;
            }
            else if (*format == 'f')
            {
                double d = __builtin_va_arg(args,double);
                sprintf(entry,"%f",d);
                resFormat += entry;
            }
            else if (*format == 'g')
            {
                double d = __builtin_va_arg(args,double);
                sprintf(entry,"%g",d);
                resFormat += entry;
            }
            else if(*format == 's')
            {
                char *pData = __builtin_va_arg(args,char *);

                while(pData && *pData != 0)
                {
                    sprintf(entry,"%c",*pData);
                    resFormat += entry;
                    pData++;
                }
            }
            else
            {
                formatting = false;
                resFormat.push_back(*format);
            }
        }
        ++format;
    }

    __builtin_va_end(args);

    return resFormat;
}
template<typename A>
cArray<cString<A> > cString<A>::tokenize(const cString<A>& stream, char separator)
{
    cArray<cString<A> > res;
    cArray<cArray<char,A> > resLocal = cArray<char,A>::tokenize(stream,separator);


    for(u32 i=0;i<resLocal.getSize();i++)
    {
        res.push_back(mpl::move(resLocal[i]));
    }

    return res;
}
template<typename A>
cArray<cString<A> > cString<A>::tokenize(char separator) const
{
    return tokenize(*this,separator);
}
template<typename A>
cString<A> cString<A>::subArr(const u32 initPos, const u32 length) const
{
    cString<A> res = cArray<char,A>::subArr(initPos,length);

    res.endString();

    return res;
}
template<typename A>
bool cString<A>::equal(const cString<A>& stringA, const cString<A>& stringB)
{
    return stringA.equal(stringB);
}
template<typename A>
bool cString<A>::equal(const cString<A>& other) const
{
    return cArray<char,A>::equal(other);
}
template<typename A>
cString<A>& cString<A>::operator=(const cString<A>& other)
{
    cArray<char,A>::operator=(other);

    return *this;
}
template<typename A>
cString<A>& cString<A>::operator=(cString<A>&& other)
{

    if(!other.isStaticAddress())
    {
        cArray<char,A>::operator=(mpl::move(other));
    }
    else
    {
        cArray<char,A>::operator=(other);
    }

    return *this;
}
template<typename A>
cString<A> cString<A>::operator+(const cString<A>& other) const
{
    cString res = cString(*this);

    res += other;

    return res;
}
template<typename A>
cString<A>& cString<A>::operator+=(const char& append)
{
    cArray<char,A>::insert(cArray<char,A>::cend(),append);

    endString();

    return *this;
}
template<typename A>
cString<A>& cString<A>::operator +=(const cString<A>& append)
{
    u32 appendSize = append.getSize();

    if(appendSize)
    {
        cArray<char,A>::reserve(2*(this->m_size+appendSize+1));

        cArray<char,A>::insert(cArray<char,A>::cend(),append.cbegin(),append.cend());
    }

    return *this;
}
template<typename A>
cString<A>& cString<A>::operator<<(const cString<A>& append)
{
    cArray<char,A>::operator<<(append);

    return *this;
}
template<typename A>
bool cString<A>::operator==(const cString<A>& other) const
{
    return cArray<char,A>::operator==(other);
}
template<typename A>
bool cString<A>::operator!=(const cString<A>& other) const
{
    return !operator==(other);
}
template<typename A>
bool cString<A>::operator<(const cString<A>& other) const
{
    bool res = true;

    u16 size = (this->m_size < other.getSize()) ? this->m_size : other.getSize();
    bool diff = true;

    const_iterator_type itThis = this->cbegin();
    const_iterator_type itOther = other.cbegin();
    const_iterator_type endStr = this->cend();

    for(;itThis!=endStr&&itOther!=endStr;++itThis,++itOther)
    {
        if(*itThis!=*itOther)
        {
            if(*itThis>*itOther)
            {
                res = false;
            }
            diff = false;
            break;
        }
    }
    if(this->m_size == other.getSize() && diff)
    {
        res = false;
    }

    return res;
}
template<typename A>
bool cString<A>::operator>(const cString<A>& other) const
{
    return !(*this<other);
}
template<typename A>
cArray<char,A>& cString<A>::operator()()
{
    return *this;
}
}
}

yame::container::string operator+(const char* i_lhs, const yame::container::string& i_rhs)
{
    return yame::container::string(i_lhs) + i_rhs;
}
# 111 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/container/cString.h" 2
# 21 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/smartPtr.h" 2

namespace yame
{
namespace ytl
{

template<typename T, int policy>
class smart_ptr
{
template<typename TT, int ppolicy>
friend class smart_ptr;

private:
    T* m_pData;
    refCounter<policy>* m_pRefCounter;

protected:
    void acquireReferenceCounter();
    void releaseReferenceCounter();
    void setData(T* data);
    T* getData() const;
    void setReferenceCounter(refCounter<smartPolicyId::UNIQUE>* pRefCounter);
    refCounter<smartPolicyId::UNIQUE>* getReferenceCounter() const;
    refCounter<smartPolicyId::UNIQUE>* extractReferenceCounter();
    u32 getNumReferences() const;
    u32 getNumWeakReferences() const;
    u32 getNumStrongReferences() const;

    smart_ptr();
    smart_ptr(const smart_ptr<T,policy>& other);
    smart_ptr(T *pData);
    smart_ptr(T *pData, refCounter<policy>* counter);
    template<typename TT>
    smart_ptr(const smart_ptr<TT,policy>& other);
    template<typename TT>
    smart_ptr(TT *pData);
    template<typename TT>
    smart_ptr(TT *pData, refCounter<policy>* counter);

public:
    operator bool() const;
    T& operator*() const;
    T* operator->() const;
    T* get();
    virtual T* release();
    virtual void reset();
    template<typename TT>
    void swap(smart_ptr<TT,policy>& other);
    bool operator==(const smart_ptr<T,policy>& other) const;
    bool operator!=(const smart_ptr<T,policy>& other) const;
    bool operator==(mpl::null_ptr_type);
    bool operator!=(mpl::null_ptr_type);
};

template<typename T, typename TT, int policy>
inline T& access(smart_ptr<TT,policy>& i_smartPtr, const yame::container::string& i_memberName);
template<typename T, typename TT, int policy>
inline const T& access(const smart_ptr<TT,policy>& i_smartPtr, const yame::container::string& i_memberName);

}
}

template<typename T, int policy>
inline bool operator==(yame::mpl::null_ptr_type i_lhs, const yame::ytl::smart_ptr<T,policy>& i_rhs);
template<typename T, int policy>
inline bool operator!=(yame::mpl::null_ptr_type i_lhs, const yame::ytl::smart_ptr<T,policy>& i_rhs);

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/smartPtr.tpp" 1


# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/rtti.h" 1
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/TypeConversionInstantiator.h" 1
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/TypeConversion.h" 1
       



namespace yame
{
namespace rtti
{
namespace detail
{

template<typename T, typename TT>
struct rtti_conversor_tag
{
    friend constexpr std::ptrdiff_t _relate(const rtti_conversor_tag<T,TT>&);
    friend constexpr std::ptrdiff_t _relate(const rtti_conversor_tag<TT,T>&);
};

template<typename ...>
struct rtti_conversor;

template<typename T, typename TT>
struct rtti_conversor<T,TT>
{
    static_assert(mpl::is_base_of<TT,T>::value, "You shall provide inherited classes");

    static const bool _expansion = true;
    constexpr static const TT* s_lhsPtr = reinterpret_cast<T*>(0xDEAD);
    constexpr static const T* s_rhsPtr = reinterpret_cast<T*>(0xDEAD);

    friend inline constexpr std::ptrdiff_t _relate(const rtti_conversor_tag<T,TT>&)
    {
        return reinterpret_cast<const char*>(s_lhsPtr) - reinterpret_cast<const char*>(s_rhsPtr);
    }
    friend inline constexpr std::ptrdiff_t _relate(const rtti_conversor_tag<TT,T>&)
    {
        return reinterpret_cast<const char*>(s_rhsPtr) - reinterpret_cast<const char*>(s_lhsPtr);
    }
};

template<typename T, typename TT, typename Joint>
struct rtti_conversor<T,TT,Joint>
{
    static_assert(mpl::is_base_of<T,Joint>::value, "You shall provide inherited classes");
    static_assert(mpl::is_base_of<TT,Joint>::value, "You shall provide inherited classes");

    static const bool _expansion = true;
    constexpr static const Joint* s_refPtr = reinterpret_cast<Joint*>(0xDEAD);
    constexpr static const T* s_lhsPtr = s_refPtr;
    constexpr static const TT* s_rhsPtr = s_refPtr;

    friend inline constexpr std::ptrdiff_t _relate(const rtti_conversor_tag<T,TT>&)
    {
        return (reinterpret_cast<const char*>(s_refPtr) - reinterpret_cast<const char*>(s_lhsPtr)) - (reinterpret_cast<const char*>(s_refPtr) - reinterpret_cast<const char*>(s_rhsPtr));
    }
};

template<typename T, typename TT, std::ptrdiff_t _foo = _relate(rtti_conversor_tag<T,TT>{})>
inline constexpr std::ptrdiff_t relate(const rtti_conversor_tag<T,TT>& i_val)
{
    return _foo;
}

}
}
}
# 4 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/TypeConversionInstantiator.h" 2


namespace yame
{
namespace rtti
{
namespace detail
{

template<typename ...>
struct TypeConversionExpansion;

template<typename, typename ...>
struct TypeConversionCombinator;

template<typename,typename ...>
struct TypeDescent;

template<>
struct TypeConversionExpansion<>
{
    static constexpr bool _expansor(bool i_value = true)
    {
        return i_value;
    }
};

template<typename T, typename ... TT>
struct TypeConversionExpansion<T,TT...>
{
    static constexpr bool _expansor(bool i_value = T::_expansion)
    {
        return TypeConversionExpansion<TT...>::_expansor() && i_value;
    }
};

template<typename Joint,typename T>
struct TypeDescent<Joint,T>
{
    static constexpr bool _expansor()
    {
        return true;
    }
};

template<typename Joint,typename T2>
struct TypeDescent<Joint,container::parameter_pack<>,T2>
{
    static constexpr bool _expansor()
    {
        return true;
    }
};

template<typename Joint,typename T1>
struct TypeDescent<Joint,T1,container::parameter_pack<>>
{
    static constexpr bool _expansor()
    {
        return true;
    }
};

template<typename Joint,typename T1, typename ... T2>
struct TypeDescent<Joint,T1,container::parameter_pack<T2...>>
{
    static constexpr bool _expansor()
    {
        return TypeConversionExpansion<rtti_conversor<Joint,T1>>::_expansor() &&
                TypeConversionExpansion<rtti_conversor<T1,T2,Joint>...>::_expansor() &&
                TypeDescent<Joint,T1,T2...>::_expansor();
    }
};

template<typename Joint,typename ... T1, typename T2>
struct TypeDescent<Joint,container::parameter_pack<T1...>,T2>
{
    static constexpr bool _expansor()
    {
        return TypeConversionExpansion<rtti_conversor<Joint,T2>>::_expansor() &&
                TypeConversionExpansion<rtti_conversor<T1,T2,Joint>...>::_expansor() &&
                TypeDescent<Joint,T2,T1...>::_expansor();
    }
};

template<typename Joint,typename T1, typename T2, typename ... TT2>
struct TypeDescent<Joint,T1,T2,TT2...>
{
    static constexpr bool _expansor()
    {
        return TypeDescent<Joint,typename T1::rtti_base,T2>::_expansor() &&
                TypeDescent<Joint,T2,typename T1::rtti_base>::_expansor() &&
                TypeDescent<Joint,T1,typename T2::rtti_base>::_expansor() &&
                TypeDescent<Joint,typename T2::rtti_base,T1>::_expansor() &&
                TypeDescent<Joint,T1,TT2...>::_expansor();
    }
};

template<typename Joint, typename T>
struct TypeConversionCombinator<Joint,T>
{
    static constexpr bool _expansor()
    {
        return true;
    }
};

template<typename Joint, typename T, typename TT, typename ... TTT>
struct TypeConversionCombinator<Joint,T,TT,TTT...>
{
    static constexpr bool _expansor()
    {
        return TypeConversionExpansion<rtti_conversor<T,TT,Joint>>::_expansor() &&
                TypeConversionExpansion<rtti_conversor<T,TTT,Joint>...>::_expansor() &&
                TypeDescent<Joint,T,TT,TTT...>::_expansor() &&
                TypeConversionCombinator<Joint,TT,TTT...>::_expansor();
    }
};

template<typename Type, typename ...>
struct TypeConversionInstantiator;

template<typename Type, typename ... Bases>
struct TypeConversionInstantiator
{

    template<bool _foo = TypeConversionExpansion<rtti_conversor<Type,Bases>...>::_expansor() && TypeConversionCombinator<Type,Bases...>::_expansor()>
    static constexpr bool _expansor()
    {
        return _foo;
    }


};

template<typename Type, typename ... Bases>
struct TypeConversionInstantiator<Type,TypeConversionExpansion<Bases...>> : TypeConversionInstantiator<Type,Bases...>
{
};

}
}
}
# 4 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/rtti.h" 2

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/TypeInfo.h" 1
       

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/rttiDefs.h" 1
       

# 1 "/usr/lib/gcc/i686-linux-gnu/4.8/include/stddef.h" 1 3 4
# 4 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/rttiDefs.h" 2

namespace yame
{
namespace rtti
{

typedef size_t TypeId;

}
}
# 4 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/TypeInfo.h" 2




namespace yame
{
namespace rtti
{

class TypeInfo;

}


namespace mpl
{
template<>
struct is_copy_constructible<rtti::TypeInfo>
{
static const bool value = true;
};
}

namespace rtti
{

class TypeInfo
{
    typedef container::cArray<const TypeInfo*> base_container;
    typedef container::cArray<container::cPair<container::string,const TypeInfo*>> member_container;
    typedef yame::container::cConstRandomAccessIntraIterable<const TypeInfo*&,const TypeInfo&> const_base_view;
    typedef yame::container::cConstRandomAccessIntraIterable<container::cPair<container::string,const TypeInfo*>&,const TypeInfo&> const_member_view;

public:
    typedef container::cConstRandomAccessIterable<const TypeInfo&> base_iterable;
    typedef container::cConstRandomAccessIterable<const TypeInfo&> member_iterable;


    TypeInfo(const container::string& i_name, TypeId i_id, const container::cArray<const TypeInfo*>& i_bases, const yame::container::cArray<yame::container::cPair<yame::container::string,const TypeInfo*>>& i_members);
    TypeInfo(const TypeInfo& other);
    TypeInfo(TypeInfo&& other);

    container::string getName() const;
    TypeId getId() const;
    const base_iterable& getBases() const;
    const member_iterable& getMembers() const;

    TypeInfo& operator=(const TypeInfo& other);
    TypeInfo& operator=(const TypeInfo&& other);

private:
    container::string m_name;
    TypeId m_id;
    container::string m_typeName;
    base_container m_bases;
    const_base_view m_baseView;
    member_container m_members;
    const_member_view m_memberView;
};

template<typename T>
inline const TypeInfo* _getTypeInfo(typename T::rtti_members*)
{
    return __get_rtti_type_info(static_cast<const T*>(__null),__get_rtti_members(static_cast<const T*>(__null)));
}
template<typename T>
inline const TypeInfo* _getTypeInfo(...)
{
    static const yame::container::cArray<yame::container::cPair<yame::container::string,const yame::rtti::TypeInfo*>> emptyMembers;
    return __get_rtti_type_info(static_cast<const T*>(__null),emptyMembers);
}

template<typename T>
inline TypeInfo getTypeInfo()
{
    static const TypeInfo* res = _getTypeInfo<T>(__null);

    return *res;
}

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/detail/TypeInfo.tpp" 1

namespace yame
{
namespace rtti
{
namespace detail
{

inline TypeId _getNextTypeId()
{
    static TypeId s_currTypeId = 0;

    return s_currTypeId++;
}

}

template<typename T>
inline TypeId getNextTypeId()
{
    static TypeId s_currTypeId = detail::_getNextTypeId();

    return s_currTypeId++;
}

}
}
# 87 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/TypeInfo.h" 2
# 6 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/rtti.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/cMacroHelper.h" 1
       
# 7 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/rtti.h" 2
# 1 "/usr/include/c++/4.8/typeinfo" 1 3
# 32 "/usr/include/c++/4.8/typeinfo" 3
       
# 33 "/usr/include/c++/4.8/typeinfo" 3






#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/4.8/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/4.8/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/usr/include/c++/4.8/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 8 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/rtti.h" 2
# 106 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/Utils/rtti/rtti.h"
namespace yame
{
namespace rtti
{

template<typename T, typename TT>
inline const TypeInfo* __get_rtti_type_info(const T*,const TT&)
{
    static const TypeInfo builtinTypeInfo = TypeInfo(yame::container::string(typeid(T).name()),getNextTypeId<T>(), {}, {});

    return &builtinTypeInfo;
}

template<typename TT, typename T>
TT* staticCast(T* i_ptr)
{
    return static_cast<TT*>(i_ptr);
}

template<typename TT, typename T>
TT* dynamicCast(T* i_ptr)
{
    constexpr std::ptrdiff_t diffPtr = relate(yame::rtti::detail::rtti_conversor_tag<T,TT>{});
    yame::container::cPair<const char*,size_t> layout = i_ptr->_rtti_layout();
    char* charPtr = reinterpret_cast<char*>(i_ptr) + diffPtr;

    if(charPtr >= layout.first && charPtr < layout.first + layout.second)
    {
        return reinterpret_cast<TT*>(charPtr);
    }
    else
    {
        return __null;
    }
}
template<typename TT, typename T>
TT& access(T* i_ptr, const yame::container::string& i_memberName)
{
    if(size_t T::* memberPtr = __get_rtti_member_address(static_cast<const T*>(__null),i_memberName))
    {
        return i_ptr->*reinterpret_cast<TT T::*>(memberPtr);
    }
    else
    {
        return *reinterpret_cast<TT*>(0xDEAD);
    }
}
template<typename TT, typename T>
const TT& access(const T* i_ptr, const yame::container::string& i_memberName)
{
    if(size_t T::* memberPtr = __get_rtti_member_address(static_cast<const T*>(__null),i_memberName))
    {
        return i_ptr->*reinterpret_cast<TT T::*>(memberPtr);
    }
    else
    {
        return *reinterpret_cast<const TT*>(0xDEAD);
    }
}

}
}
# 4 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/smartPtr.tpp" 2

namespace yame
{
namespace ytl
{

template<typename T, int policy>
void smart_ptr<T,policy>::setData(T* data)
{
    if(m_pData != data)
    {
        m_pData = data;
    }

    return;
}
template<typename T, int policy>
T* smart_ptr<T,policy>::getData() const
{
    return m_pData;
}
template<typename T, int policy>
void smart_ptr<T,policy>::setReferenceCounter(refCounter<smartPolicyId::UNIQUE>* pRefCounter)
{
    if(m_pRefCounter != pRefCounter)
    {
        m_pRefCounter = pRefCounter;
    }
}
template<typename T, int policy>
refCounter<smartPolicyId::UNIQUE>* smart_ptr<T,policy>::getReferenceCounter() const
{
    return m_pRefCounter;
}
template<typename T, int policy>
refCounter<smartPolicyId::UNIQUE>* smart_ptr<T,policy>::extractReferenceCounter()
{
    refCounter<smartPolicyId::UNIQUE>* res = m_pRefCounter;

    m_pRefCounter = __null;

    return res;
}
template<typename T, int policy>
u32 smart_ptr<T,policy>::getNumReferences() const
{
    return (m_pRefCounter) ? m_pRefCounter->getNumWeakReferences() : 0;
}
template<typename T, int policy>
u32 smart_ptr<T,policy>::getNumWeakReferences() const
{
    return (m_pRefCounter) ? m_pRefCounter->getNumWeakReferences() : 0;
}
template<typename T, int policy>
u32 smart_ptr<T,policy>::getNumStrongReferences() const
{
    return (m_pRefCounter) ? 1 : 0;
}
template<typename T, int policy>
void smart_ptr<T,policy>::acquireReferenceCounter()
{
    if(m_pRefCounter == __null)
    {
        m_pRefCounter = new refCounter<policy>();
    }
}
template<typename T, int policy>
void smart_ptr<T,policy>::releaseReferenceCounter()
{
    if(m_pRefCounter)
    {
        delete m_pRefCounter;

        m_pRefCounter = __null;
    }
}
template<typename T, int policy>
smart_ptr<T,policy>::smart_ptr()
: m_pData(__null)
, m_pRefCounter(__null)
{
}
template<typename T, int policy>
smart_ptr<T,policy>::smart_ptr(const smart_ptr<T,policy>& other)
: m_pData(other.m_pData)
, m_pRefCounter(other.m_pRefCounter)
{
}
template<typename T, int policy>
smart_ptr<T,policy>::smart_ptr(T *pData)
: m_pData(pData)
, m_pRefCounter(__null)
{

}
template<typename T, int policy>
smart_ptr<T,policy>::smart_ptr(T *pData, refCounter<policy>* counter)
: m_pData(pData)
, m_pRefCounter(counter)
{
}
template<typename T, int policy>
template<typename TT>
smart_ptr<T,policy>::smart_ptr(const smart_ptr<TT,policy>& other)
: m_pData(static_cast<T *>(other.m_pData))
, m_pRefCounter(other.m_pRefCounter)
{
    static_assert(mpl::is_base_of<T,TT>::value, "You shall provide a base of T as TT");
}
template<typename T, int policy>
template<typename TT>
smart_ptr<T,policy>::smart_ptr(TT *pData)
: m_pData(static_cast<T *>(pData))
, m_pRefCounter(__null)
{
    static_assert(mpl::is_base_of<T,TT>::value, "You shall provide a base of T as TT");
}
template<typename T, int policy>
template<typename TT>
smart_ptr<T,policy>::smart_ptr(TT *pData, refCounter<policy>* counter)
: m_pData(static_cast<T *>(pData))
, m_pRefCounter(counter)
{
    static_assert(mpl::is_base_of<T,TT>::value, "You shall provide a base of T as TT");
}
template<typename T, int policy>
smart_ptr<T,policy>::operator bool() const
{
    return m_pData != __null;
}
template<typename T, int policy>
T& smart_ptr<T,policy>::operator*() const
{
    ((m_pData && "Trying to dereference null smart pointer!") ? static_cast<void> (0) : __assert_fail ("m_pData && \"Trying to dereference null smart pointer!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/smartPtr.tpp", 137, __PRETTY_FUNCTION__));

    return *m_pData;
}
template<typename T, int policy>
T* smart_ptr<T,policy>::operator->() const
{
    ((m_pData && "Trying to access null smart pointer!") ? static_cast<void> (0) : __assert_fail ("m_pData && \"Trying to access null smart pointer!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/smartPtr.tpp", 144, __PRETTY_FUNCTION__));

    return m_pData;
}
template<typename T, int policy>
T* smart_ptr<T,policy>::get()
{
    return m_pData;
}
template<typename T, int policy>
T* smart_ptr<T,policy>::release()
{
    T* res = m_pData;

    m_pData = __null;
    m_pRefCounter = __null;

    return res;
}
template<typename T, int policy>
void smart_ptr<T,policy>::reset()
{
    m_pData = __null;
    m_pRefCounter = __null;

    return;
}
template<typename T, int policy>
template<typename TT>
void smart_ptr<T,policy>::swap(smart_ptr<TT,policy>& other)
{

    mpl::swapItems(m_pRefCounter,other.m_pRefCounter);
    T* otherData = static_cast<T *>(other.m_pData);
    mpl::swapItems(m_pData,otherData);
    other.m_pData = static_cast<TT *>(otherData);

    return;
}
template<typename T, int policy>
bool smart_ptr<T,policy>::operator==(const smart_ptr<T,policy>& other) const
{
    return m_pData == other.m_pData;
}
template<typename T, int policy>
bool smart_ptr<T,policy>::operator!=(const smart_ptr<T,policy>& other) const
{
    return m_pData != other.m_pData;
}
template<typename T, int policy>
bool smart_ptr<T,policy>::operator==(mpl::null_ptr_type)
{
    return m_pData == __null;
}
template<typename T, int policy>
bool smart_ptr<T,policy>::operator!=(mpl::null_ptr_type)
{
    return m_pData != __null;
}

template<typename T, typename TT, int policy>
T& access(smart_ptr<TT,policy>& i_smartPtr, const yame::container::string& i_memberName)
{
    return yame::rtti::access<T>(i_smartPtr.get(),i_memberName);
}
template<typename T, typename TT, int policy>
const T& access(const smart_ptr<TT,policy>& i_smartPtr, const yame::container::string& i_memberName)
{
    return yame::rtti::access<T>(i_smartPtr.get(),i_memberName);
}

}
}

template<typename T, int policy>
bool operator==(yame::mpl::null_ptr_type i_lhs, const yame::ytl::smart_ptr<T,policy>& i_rhs)
{
    return i_rhs == i_lhs;
}
template<typename T, int policy>
bool operator!=(yame::mpl::null_ptr_type i_lhs, const yame::ytl::smart_ptr<T,policy>& i_rhs)
{
    return i_rhs != i_lhs;
}
# 88 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/smartPtr.h" 2
# 18 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/refPtr.h" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/enable_ref_from_this.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/enable_ref_from_this.h"
       




namespace yame
{
namespace ytl
{
template<typename TT>
class uniquePtr;

template<typename TT>
class refPtr;

template<typename T>
class enable_ref_from_this
{
template<typename TT>
friend class uniquePtr;

template<typename TT>
friend class refPtr;

public:
    typedef T innerType;

    enable_ref_from_this();
    enable_ref_from_this(const enable_ref_from_this& other);
    enable_ref_from_this(enable_ref_from_this&& other)=delete;
    ~enable_ref_from_this();
    enable_ref_from_this& operator=(const enable_ref_from_this& other);
    enable_ref_from_this& operator=(const enable_ref_from_this&& other)=delete;
    const enable_ref_from_this& ref_from_this();

private:
    void setRefCtr(refCounter<smartPolicyId::UNIQUE>* pCounter);
    refCounter<smartPolicyId::UNIQUE>* getRefCounter() const;

    refCounter<smartPolicyId::UNIQUE>* m_pCounter;
};

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/enable_ref_from_this.tpp" 1

namespace yame
{
namespace ytl
{

template<typename T>
void enable_ref_from_this<T>::setRefCtr(refCounter<smartPolicyId::UNIQUE>* pCounter)
{
    if(m_pCounter == __null)
    {
        m_pCounter = pCounter;
    }

    return;
}
template<typename T>
refCounter<smartPolicyId::UNIQUE>* enable_ref_from_this<T>::getRefCounter() const
{
    refCounter<smartPolicyId::UNIQUE>* res = (m_pCounter) ? m_pCounter : new refCounter<smartPolicyId::UNIQUE>();

    return res;
}
template<typename T>
enable_ref_from_this<T>::enable_ref_from_this()
: m_pCounter(__null)
{
}
template<typename T>
enable_ref_from_this<T>::enable_ref_from_this(const enable_ref_from_this& other)
: m_pCounter(__null)
{
}
template<typename T>
enable_ref_from_this<T>::~enable_ref_from_this()
{
    if(m_pCounter)
    {
        ((m_pCounter->getNumWeakReferences()==0 && "Still remaining reference pointers to this while destroying!") ? static_cast<void> (0) : __assert_fail ("m_pCounter->getNumWeakReferences()==0 && \"Still remaining reference pointers to this while destroying!\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/enable_ref_from_this.tpp", 39, __PRETTY_FUNCTION__));

        delete m_pCounter;
    }
}
template<typename T>
enable_ref_from_this<T>& enable_ref_from_this<T>::operator=(const enable_ref_from_this& other)
{
    return *this;
}
template<typename T>
const enable_ref_from_this<T>& enable_ref_from_this<T>::ref_from_this()
{
    return *this;
}

}
}
# 60 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/enable_ref_from_this.h" 2
# 19 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/refPtr.h" 2

namespace yame
{
namespace ytl
{

template<typename>
class unique_ptr;
template<typename>
class unique_ref;
template<typename>
class lent_ptr;
template<typename>
class lent_ref;

template<typename T>
inline lent_ref<T> promote_to_ref(const lent_ptr<T>& other);
template<typename TT, typename T>
lent_ptr<TT> dynamic_lent_cast(const lent_ptr<T>& other);
template<typename TT, typename T>
lent_ptr<TT> static_lent_cast(const lent_ptr<T>& other);
template<typename TT, typename T>
lent_ptr<TT> dynamic_lent_cast(const lent_ref<T>& other);
template<typename TT, typename T>
lent_ref<TT> static_lent_cast(const lent_ref<T>& other);
template<typename T>
lent_ptr<T> const_lent_cast(const lent_ptr<const T>& other);
template<typename T>
lent_ref<T> const_lent_cast(const lent_ref<const T>& other);

template<typename T>
class lent_ptr : public smart_ptr<T,smartPolicyId::UNIQUE>
{
    template<typename TT>
    friend class lent_ptr;
    template<typename TT>
    friend lent_ref<TT> promote_to_ref(const lent_ptr<TT>& other);
    template<typename TTT, typename TT>
    friend lent_ptr<TTT> dynamic_lent_cast(const lent_ptr<TT>& other);
    template<typename TTT, typename TT>
    friend lent_ptr<TTT> static_lent_cast(const lent_ptr<TT>& other);
    template<typename TTT, typename TT>
    friend lent_ptr<TTT> dynamic_lent_cast(const lent_ref<TT>& other);
    template<typename TTT, typename TT>
    friend lent_ref<TTT> static_lent_cast(const lent_ref<TT>& other);
    template<typename TT>
    friend lent_ptr<TT> const_lent_cast(const lent_ptr<const TT>& other);
    template<typename TT>
    friend lent_ref<TT> const_lent_cast(const lent_ref<const TT>& other);

public:
    using smart_ptr<T,smartPolicyId::UNIQUE>::get;
    using smart_ptr<T,smartPolicyId::UNIQUE>::swap;
    using smart_ptr<T,smartPolicyId::UNIQUE>::operator==;
    using smart_ptr<T,smartPolicyId::UNIQUE>::operator!=;
    using smart_ptr<T,smartPolicyId::UNIQUE>::operator*;
    using smart_ptr<T,smartPolicyId::UNIQUE>::operator->;

    lent_ptr<T>();
    lent_ptr<T>(mpl::null_ptr_type nullPtr);
    lent_ptr<T>(const lent_ptr<T>& other);
    lent_ptr<T>(const unique_ptr<T>& other);
    lent_ptr<T>(lent_ptr<T>&& other);
    template<typename TT>
    lent_ptr<T>(const lent_ptr<TT>& other);
    template<typename TT>
    lent_ptr<T>(const unique_ptr<TT>& other);
    lent_ptr<T>(unique_ptr<T>&& other) = delete;
    template<typename TT>
    lent_ptr<T>(lent_ptr<TT>&& other);
    template<typename TT>
    lent_ptr<T>(const enable_ref_from_this<TT>& other);
    ~lent_ptr<T>();
    lent_ptr<T>& operator=(mpl::null_ptr_type);
    lent_ptr<T>& operator=(const lent_ptr<T>& other);
    lent_ptr<T>& operator=(lent_ptr<T>&& other);
    lent_ptr<T>& operator=(const unique_ptr<T>& other);
    lent_ptr<T>& operator=(unique_ptr<T>&& other) = delete;
    template<typename TT>
    lent_ptr<T>& operator=(const lent_ptr<TT>& other);
    template<typename TT>
    lent_ptr<T>& operator=(lent_ptr<TT>&& other);
    template<typename TT>
    lent_ptr<T>& operator=(const unique_ptr<TT>& other);
    template<typename TT>
    lent_ptr<T>& operator=(unique_ptr<TT>&& other) = delete;
    T* release();
    void reset();
protected:
    template<typename TT>
    lent_ptr(TT *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter);
};

template<typename T>
class lent_ref : public lent_ptr<T>
{
    template<typename TT>
    friend lent_ref<TT> promote_to_ref(const lent_ptr<TT>& other);
    template<typename TTT, typename TT>
    friend lent_ptr<TTT> dynamic_lent_cast(const lent_ptr<TT>& other);
    template<typename TTT, typename TT>
    friend lent_ptr<TTT> static_lent_cast(const lent_ptr<TT>& other);
    template<typename TTT, typename TT>
    friend lent_ptr<TTT> dynamic_lent_cast(const lent_ref<TT>& other);
    template<typename TTT, typename TT>
    friend lent_ref<TTT> static_lent_cast(const lent_ref<TT>& other);
    template<typename TT>
    friend lent_ptr<TT> const_lent_cast(const lent_ptr<const TT>& other);
    template<typename TT>
    friend lent_ref<TT> const_lent_cast(const lent_ref<const TT>& other);

public:
    using lent_ptr<T>::get;
    using lent_ptr<T>::swap;
    using lent_ptr<T>::operator==;
    using lent_ptr<T>::operator!=;
    using lent_ptr<T>::operator*;
    using lent_ptr<T>::operator->;
    using lent_ptr<T>::operator=;

    template<typename TT>
    lent_ref(const lent_ref<TT>& other);
    template<typename TT>
    lent_ref(lent_ref<TT>&& other);
    template<typename TT>
    lent_ref(const unique_ref<TT>& other);

private:
    template<typename TT>
    lent_ref(TT *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter);
};

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/ref_ptr.tpp" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/ref_ptr.tpp"
namespace yame
{
namespace ytl
{

template<typename T>
lent_ptr<T>::lent_ptr()
: smart_ptr<T,smartPolicyId::UNIQUE>()
{
}
template<typename T>
lent_ptr<T>::lent_ptr(mpl::null_ptr_type nullPtr)
: smart_ptr<T,smartPolicyId::UNIQUE>()
{
}
template<typename T>
lent_ptr<T>::lent_ptr(const lent_ptr<T>& other)
: smart_ptr<T,smartPolicyId::UNIQUE>(other)
{
    if(this->getReferenceCounter()) { this->getReferenceCounter()->addWeakReference(); }
}
template<typename T>
lent_ptr<T>::lent_ptr(const unique_ptr<T>& other)
: smart_ptr<T,smartPolicyId::UNIQUE>(other.getData(), other.getReferenceCounter())
{
    if(this->getReferenceCounter()) { this->getReferenceCounter()->addWeakReference(); }
}
template<typename T>
lent_ptr<T>::lent_ptr(lent_ptr<T>&& other)
: smart_ptr<T,smartPolicyId::UNIQUE>(other.getData(), other.getReferenceCounter())
{
    other.setReferenceCounter(__null);
    other.setData(__null);
}
template<typename T>
template<typename TT>
lent_ptr<T>::lent_ptr(const lent_ptr<TT>& other)
: smart_ptr<T,smartPolicyId::UNIQUE>(other)
{
    if(this->getReferenceCounter()) { this->getReferenceCounter()->addWeakReference(); }
}
template<typename T>
template<typename TT>
lent_ptr<T>::lent_ptr(const unique_ptr<TT>& other)
: smart_ptr<T,smartPolicyId::UNIQUE>(other.getData(), other.getReferenceCounter())
{
    if(this->getReferenceCounter()) { this->getReferenceCounter()->addWeakReference(); }
}
template<typename T>
template<typename TT>
lent_ptr<T>::lent_ptr(lent_ptr<TT>&& other)
: smart_ptr<T,smartPolicyId::UNIQUE>(other.getData(), other.getReferenceCounter())
{
    other.setReferenceCounter(__null);
    other.setData(__null);
}
template<typename T>
template<typename TT>
lent_ptr<T>::lent_ptr(const enable_ref_from_this<TT>& other)
: smart_ptr<T,smartPolicyId::UNIQUE>(static_cast<TT *>(&const_cast<enable_ref_from_this<TT>&>(other)),other.getRefCounter())
{
    if(this->getReferenceCounter()) { this->getReferenceCounter()->addWeakReference(); }
}
template<typename T>
template<typename TT>
lent_ptr<T>::lent_ptr(TT *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter)
: smart_ptr<T,smartPolicyId::UNIQUE>(pData, referenceCounter)
{
    if(this->getReferenceCounter()) { this->getReferenceCounter()->addWeakReference(); }
}
template<typename T>
lent_ptr<T>::~lent_ptr()
{
    if(this->getReferenceCounter()) { this->getReferenceCounter()->removeWeakReference(); this->setReferenceCounter(__null); }
}
template<typename T>
lent_ptr<T>& lent_ptr<T>::operator=(mpl::null_ptr_type)
{
    reset();

    return *this;
}
template<typename T>
lent_ptr<T>& lent_ptr<T>::operator=(const lent_ptr<T>& other)
{
    smart_ptr<T,smartPolicyId::UNIQUE>::operator=(other);

    return *this;
}
template<typename T>
lent_ptr<T>& lent_ptr<T>::operator=(lent_ptr<T>&& other)
{
    smart_ptr<T,smartPolicyId::UNIQUE>::operator=(mpl::move(other));

    return *this;
}
template<typename T>
lent_ptr<T>& lent_ptr<T>::operator=(const unique_ptr<T>& other)
{
    smart_ptr<T,smartPolicyId::UNIQUE>::operator=(other);

    if(this->getReferenceCounter()) { this->getReferenceCounter()->addWeakReference(); }

    return *this;
}
template<typename T>
template<typename TT>
lent_ptr<T>& lent_ptr<T>::operator=(const lent_ptr<TT>& other)
{
    smart_ptr<T,smartPolicyId::UNIQUE>::operator=(other);

    if(this->getReferenceCounter()) { this->getReferenceCounter()->addWeakReference(); }

    return *this;
}
template<typename T>
template<typename TT>
lent_ptr<T>& lent_ptr<T>::operator=(lent_ptr<TT>&& other)
{
    smart_ptr<T,smartPolicyId::UNIQUE>::operator=(mpl::move(other));

    return *this;
}
template<typename T>
template<typename TT>
lent_ptr<T>& lent_ptr<T>::operator=(const unique_ptr<TT>& other)
{
    smart_ptr<T,smartPolicyId::UNIQUE>::operator=(other);

    if(this->getReferenceCounter()) { this->getReferenceCounter()->addWeakReference(); }

    return *this;
}
template<typename T>
T* lent_ptr<T>::release()
{
    if(this->getReferenceCounter()) { this->getReferenceCounter()->removeWeakReference(); this->setReferenceCounter(__null); }

    return smart_ptr<T,smartPolicyId::UNIQUE>::release();
}
template<typename T>
void lent_ptr<T>::reset()
{
    if(this->getReferenceCounter()) { this->getReferenceCounter()->removeWeakReference(); this->setReferenceCounter(__null); }

    smart_ptr<T,smartPolicyId::UNIQUE>::reset();

    return;
}

template<typename T>
template<typename TT>
lent_ref<T>::lent_ref(const lent_ref<TT>& other)
: lent_ptr<T>(other)
{
}
template<typename T>
template<typename TT>
lent_ref<T>::lent_ref(lent_ref<TT>&& other)
: lent_ptr<T>(mpl::move(other))
{
}
template<typename T>
template<typename TT>
lent_ref<T>::lent_ref(const unique_ref<TT>& other)
: lent_ptr<T>(other)
{
}
template<typename T>
template<typename TT>
lent_ref<T>::lent_ref(TT *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter)
: lent_ptr<T>(pData, referenceCounter)
{
}


template<typename T>
lent_ref<T> promote_to_ref(const lent_ptr<T>& other)
{
    return lent_ref<T>(other.getData(), other.getReferenceCounter());
}
template<typename TT, typename T>
lent_ptr<TT> dynamic_lent_cast(const lent_ptr<T>& other)
{
    static_assert(mpl::is_base_of<T,TT>::value, "You shall provide related classes by inheritance");
    static_assert(std::is_polymorphic<T>::value, "You shall work with polymprphic classes, try providing virtual destructor");

    if(T* pData = other.getData())
    {
        if(TT* innerData = dynamic_cast<TT*>(pData))
        {
            return lent_ref<TT>(innerData, other.getReferenceCounter());
        }
        else
        {
            return null_ptr;
        }
    }
    else
    {
        return null_ptr;
    }}
template<typename TT, typename T>
lent_ptr<TT> static_lent_cast(const lent_ptr<T>& other)
{
    if(T* pData = other.getData())
    {
        TT* innerData = static_cast<TT*>(pData);

        return lent_ref<TT>(innerData, other.getReferenceCounter());
    }
    else
    {
        return null_ptr;
    }
}
template<typename TT, typename T>
lent_ptr<TT> dynamic_lent_cast(const lent_ref<T>& other)
{
    static_assert(mpl::is_base_of<T,TT>::value, "You shall provide related classes by inheritance");
    static_assert(std::is_polymorphic<T>::value, "You shall work with polymprphic classes, try providing virtual destructor");
    ((other.getData() && "You shall provide a non empty pointer as ref") ? static_cast<void> (0) : __assert_fail ("other.getData() && \"You shall provide a non empty pointer as ref\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/ref_ptr.tpp", 236, __PRETTY_FUNCTION__));

    if(TT* innerData = dynamic_cast<TT*>(other.getData()))
    {
        return lent_ref<TT>(innerData, other.getReferenceCounter());
    }
    else
    {
        return null_ptr;
    }
}
template<typename TT, typename T>
lent_ref<TT> static_lent_cast(const lent_ref<T>& other)
{
    ((other.getData() && "You shall provide a non empty pointer as ref") ? static_cast<void> (0) : __assert_fail ("other.getData() && \"You shall provide a non empty pointer as ref\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/ref_ptr.tpp", 250, __PRETTY_FUNCTION__));

    TT* innerData = static_cast<TT*>(other.getData());

    return lent_ref<TT>(innerData, other.getReferenceCounter());
}
template<typename T>
lent_ptr<T> const_lent_cast(const lent_ptr<const T>& other)
{
    if(const T* pData = other.getData())
    {
        T* innerData = const_cast<T*>(pData);

        return lent_ref<T>(innerData, other.getReferenceCounter());
    }
    else
    {
        return null_ptr;
    }
}
template<typename T>
lent_ref<T> const_lent_cast(const lent_ref<const T>& other)
{
    ((other.getData() && "You shall provide a non empty ref") ? static_cast<void> (0) : __assert_fail ("other.getData() && \"You shall provide a non empty ref\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/ref_ptr.tpp", 273, __PRETTY_FUNCTION__));
    T* innerData = const_cast<T*>(other.getData());

    return lent_ref<T>(innerData, other.getReferenceCounter());
}


}
}
# 154 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/refPtr.h" 2
# 3 "test_smartPtr.cpp" 2
# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/uniquePtr.h" 1
# 15 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/uniquePtr.h"
       




namespace yame
{
namespace ytl
{

template<typename T>
class unique_ref;
template<typename T>
class unique_ptr;

template<typename T, typename ... Args>
inline unique_ref<T> make_unique_ptr(Args&& ... args);
template<typename T>
inline unique_ref<T> promote_to_ref(unique_ptr<T>&& other);
template<typename TT, typename T>
unique_ptr<TT> dynamic_unique_cast(unique_ptr<T>&& other);
template<typename TT, typename T>
unique_ptr<TT> static_unique_cast(unique_ptr<T>&& other);
template<typename TT, typename T>
unique_ptr<TT> dynamic_unique_cast(unique_ref<T>&& other);
template<typename TT, typename T>
unique_ref<TT> static_unique_cast(unique_ref<T>&& other);
template<typename T>
unique_ptr<T> const_unique_cast(unique_ptr<const T>&& other);
template<typename T>
unique_ref<T> const_unique_cast(unique_ref<const T>&& other);

template<typename>
class lent_ptr;

template<typename T>
class unique_ptr : public smart_ptr<T,smartPolicyId::UNIQUE>
{
    template<typename TT>
    friend class unique_ptr;
    template<typename TT>
    friend class lent_ptr;
    template<typename TT, typename ... Args>
    friend unique_ref<TT> make_unique_ptr(Args&& ...);
    template<typename TT>
    friend unique_ref<TT> promote_to_ref(unique_ptr<TT>&& other);
    template<typename TTT, typename TT>
    friend unique_ptr<TTT> dynamic_unique_cast(unique_ptr<TT>&& other);
    template<typename TTT, typename TT>
    friend unique_ptr<TTT> static_unique_cast(unique_ptr<TT>&& other);
    template<typename TTT, typename TT>
    friend unique_ptr<TTT> dynamic_unique_cast(unique_ref<TT>&& other);
    template<typename TTT, typename TT>
    friend unique_ref<TTT> static_unique_cast(unique_ref<TT>&& other);
    template<typename TT>
    friend unique_ptr<TT> const_unique_cast(unique_ptr<const TT>&& other);
    template<typename TT>
    friend unique_ref<TT> const_unique_cast(unique_ref<const TT>&& other);

public:
    using smart_ptr<T,smartPolicyId::UNIQUE>::get;
    using smart_ptr<T,smartPolicyId::UNIQUE>::operator==;
    using smart_ptr<T,smartPolicyId::UNIQUE>::operator!=;
    using smart_ptr<T,smartPolicyId::UNIQUE>::operator*;
    using smart_ptr<T,smartPolicyId::UNIQUE>::operator->;

    unique_ptr<T>();
    unique_ptr<T>(mpl::null_ptr_type nullPtr);
    unique_ptr<T>(T *pData, Deleter* deleter=__null);
    unique_ptr<T>(unique_ptr<T>&& other);
    template<typename TT>
    unique_ptr<T>(TT *pData, Deleter* deleter=__null);
    unique_ptr<T>(const unique_ptr<T>& other) = delete;
    template<typename TT>
    unique_ptr<T>(const unique_ptr<TT>& other) = delete;
    template<typename TT>
    unique_ptr<T>(unique_ptr<TT>&& other);
    ~unique_ptr<T>();
    unique_ptr<T>& operator=(mpl::null_ptr_type nullPtr);
    unique_ptr<T>& operator=(const unique_ptr<T>& other) = delete;
    template<typename TT>
    unique_ptr<T>& operator=(const unique_ptr<TT>& other) = delete;
    unique_ptr<T>& operator=(unique_ptr<T>&& other);
    template<typename TT>
    unique_ptr<T>& operator=(unique_ptr<TT>&& other);
    T* release();
    void reset();
    template<typename TT>
    void swap(unique_ptr<TT>& other);

protected:
    unique_ptr<T>(T *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter, bool embedded, Deleter* deleter = __null);
    template<typename TT>
    unique_ptr<T>(TT *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter, bool embedded, Deleter* deleter = __null);
    Deleter* getDeleter() const;
    void setDeleter(Deleter* _del);
    void _delete(T* ptr);
    template<typename TT>
    void shareCounterIfRefEnabled(enable_ref_from_this<TT>* enabledData);
    void shareCounterIfRefEnabled(...);
    bool isEmbedded() const;

    Deleter* m_pDeleter = __null;
    bool m_referenceCounterEmbedded = false;
};

template<typename T>
class unique_ref : public unique_ptr<T>
{
    template<typename TT>
    friend class unique_ptr;
    template<typename TT, typename ... Args>
    friend unique_ref<TT> make_unique_ptr(Args&& ...);
    template<typename TT>
    friend unique_ref<TT> promote_to_ref(unique_ptr<TT>&& other);
    template<typename TTT, typename TT>
    friend unique_ptr<TTT> dynamic_unique_cast(unique_ptr<TT>&& other);
    template<typename TTT, typename TT>
    friend unique_ptr<TTT> static_unique_cast(unique_ptr<TT>&& other);
    template<typename TTT, typename TT>
    friend unique_ptr<TTT> dynamic_unique_cast(unique_ref<TT>&& other);
    template<typename TTT, typename TT>
    friend unique_ref<TTT> static_unique_cast(unique_ref<TT>&& other);
    template<typename TT>
    friend unique_ptr<TT> const_unique_cast(unique_ptr<const TT>&& other);
    template<typename TT>
    friend unique_ref<TT> const_unique_cast(unique_ref<const TT>&& other);

public:
    using unique_ptr<T>::operator=;
    using unique_ptr<T>::get;
    using unique_ptr<T>::operator==;
    using unique_ptr<T>::operator!=;
    using unique_ptr<T>::operator*;
    using unique_ptr<T>::operator->;

    unique_ref(T *pData, Deleter* deleter=__null);
    unique_ref(unique_ref<T>&& other);
    unique_ref(const unique_ref&) = delete;
    template<typename TT>
    unique_ref(TT *pData, Deleter* deleter=__null);
    template<typename TT>
    unique_ref(unique_ref<TT>&& other);
    unique_ref& operator=(const unique_ref&) = delete;
    unique_ref& operator=(unique_ref&& other);

private:
    unique_ref(T *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter, bool embedded, Deleter* deleter = __null);
    template<typename TT>
    unique_ref(TT *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter, bool embedded, Deleter* deleter = __null);
};

}
}

# 1 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/unique_ptr.tpp" 1
# 19 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/unique_ptr.tpp"
namespace yame
{
namespace ytl
{

template<typename T>
Deleter* unique_ptr<T>::getDeleter() const
{
    return m_pDeleter;
}
template<typename T>
void unique_ptr<T>::setDeleter(Deleter* _del)
{
    m_pDeleter = _del;

    return;
}
template<typename T>
void unique_ptr<T>::_delete(T* ptr)
{
    if(m_pDeleter && ptr)
    {
        m_pDeleter->releaseMemory(const_cast<typename mpl::drop_constness<T>::type*>(ptr));
    }
    else if(ptr)
    {
        ::delete ptr;
    }
}
template<typename T>
unique_ptr<T>::unique_ptr()
: smart_ptr<T,smartPolicyId::UNIQUE>()
, m_pDeleter(__null)
, m_referenceCounterEmbedded(false)
{
}
template<typename T>
unique_ptr<T>::unique_ptr(mpl::null_ptr_type nullPtr)
: smart_ptr<T,smartPolicyId::UNIQUE>()
, m_pDeleter(__null)
, m_referenceCounterEmbedded(false)
{
}
template<typename T>
unique_ptr<T>::unique_ptr(T *pData, Deleter* deleter)
: smart_ptr<T,smartPolicyId::UNIQUE>(pData)
, m_pDeleter(deleter)
, m_referenceCounterEmbedded(false)
{
    refCounter<smartPolicyId::UNIQUE>* referenceCounter = this->getReferenceCounter();

    ((referenceCounter == __null && "You cannot assign a new reference counter while having a previous one") ? static_cast<void> (0) : __assert_fail ("referenceCounter == __null && \"You cannot assign a new reference counter while having a previous one\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/unique_ptr.tpp", 70, __PRETTY_FUNCTION__));

    this->acquireReferenceCounter();


    shareCounterIfRefEnabled(this->getData());
}
template<typename T>
unique_ptr<T>::unique_ptr(unique_ptr<T>&& other)
: smart_ptr<T,smartPolicyId::UNIQUE>()
, m_pDeleter(__null)
, m_referenceCounterEmbedded(other.m_referenceCounterEmbedded)
{
    swap<T>(other);
}
template<typename T>
template<typename TT>
unique_ptr<T>::unique_ptr(TT *pData, Deleter* deleter)
: smart_ptr<T,smartPolicyId::UNIQUE>(pData)
, m_pDeleter(deleter)
, m_referenceCounterEmbedded(false)
{
    refCounter<smartPolicyId::UNIQUE>* referenceCounter = this->getReferenceCounter();

    ((referenceCounter == __null && "You cannot assign a new reference counter while having a previous one") ? static_cast<void> (0) : __assert_fail ("referenceCounter == __null && \"You cannot assign a new reference counter while having a previous one\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/unique_ptr.tpp", 94, __PRETTY_FUNCTION__));

    this->acquireReferenceCounter();


    shareCounterIfRefEnabled(this->getData());
}
template<typename T>
unique_ptr<T>::unique_ptr(T *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter, bool embedded, Deleter* deleter)
: smart_ptr<T,smartPolicyId::UNIQUE>(pData, referenceCounter)
, m_pDeleter(__null)
, m_referenceCounterEmbedded(embedded)
{

    shareCounterIfRefEnabled(this->getData());
}
template<typename T>
template<typename TT>
unique_ptr<T>::unique_ptr(TT *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter, bool embedded, Deleter* deleter)
: smart_ptr<T,smartPolicyId::UNIQUE>(pData, referenceCounter)
, m_pDeleter(__null)
, m_referenceCounterEmbedded(embedded)
{

    shareCounterIfRefEnabled(this->getData());
}
template<typename T>
template<typename TT>
unique_ptr<T>::unique_ptr(unique_ptr<TT>&& other)
: smart_ptr<T,smartPolicyId::UNIQUE>()
, m_pDeleter(__null)
, m_referenceCounterEmbedded(other.m_referenceCounterEmbedded)
{
    swap<TT>(other);
}
template<typename T>
unique_ptr<T>::~unique_ptr()
{

    refCounter<smartPolicyId::UNIQUE>* referenceCounter = this->getReferenceCounter(); ((referenceCounter == __null || referenceCounter->getNumWeakReferences() == 0 && "You still have weak references this data while destroying it") ? static_cast<void> (0) : __assert_fail ("referenceCounter == __null || referenceCounter->getNumWeakReferences() == 0 && \"You still have weak references this data while destroying it\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/unique_ptr.tpp", 133, __PRETTY_FUNCTION__)); if(m_referenceCounterEmbedded == false) { this->releaseReferenceCounter(); } else { smart_ptr<T,smartPolicyId::UNIQUE>::setReferenceCounter(__null); }

    if(T* data = this->getData())
    {
        _delete(data);

        this->setData(__null);
    }
}
template<typename T>
unique_ptr<T>& unique_ptr<T>::operator=(mpl::null_ptr_type nullPtr)
{
    reset();

    return *this;
}
template<typename T>
unique_ptr<T>& unique_ptr<T>::operator=(unique_ptr<T>&& other)
{
    reset();

    swap<T>(other);

    return *this;
}
template<typename T>
template<typename TT>
unique_ptr<T>& unique_ptr<T>::operator=(unique_ptr<TT>&& other)
{
    reset();

    swap<TT>(other);

    return *this;
}
template<typename T>
T* unique_ptr<T>::release()
{
    refCounter<smartPolicyId::UNIQUE>* referenceCounter = this->getReferenceCounter(); ((referenceCounter == __null || referenceCounter->getNumWeakReferences() == 0 && "You still have weak references this data while destroying it") ? static_cast<void> (0) : __assert_fail ("referenceCounter == __null || referenceCounter->getNumWeakReferences() == 0 && \"You still have weak references this data while destroying it\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/unique_ptr.tpp", 171, __PRETTY_FUNCTION__)); if(m_referenceCounterEmbedded == false) { this->releaseReferenceCounter(); } else { smart_ptr<T,smartPolicyId::UNIQUE>::setReferenceCounter(__null); }

    m_pDeleter = __null;

    return smart_ptr<T,smartPolicyId::UNIQUE>::release();
}
template<typename T>
void unique_ptr<T>::reset()
{
    refCounter<smartPolicyId::UNIQUE>* referenceCounter = this->getReferenceCounter(); ((referenceCounter == __null || referenceCounter->getNumWeakReferences() == 0 && "You still have weak references this data while destroying it") ? static_cast<void> (0) : __assert_fail ("referenceCounter == __null || referenceCounter->getNumWeakReferences() == 0 && \"You still have weak references this data while destroying it\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/unique_ptr.tpp", 180, __PRETTY_FUNCTION__)); if(m_referenceCounterEmbedded == false) { this->releaseReferenceCounter(); } else { smart_ptr<T,smartPolicyId::UNIQUE>::setReferenceCounter(__null); }

    m_pDeleter = __null;
    m_referenceCounterEmbedded = false;


    if(T* data = this->getData())
    {
        _delete(data);

        this->setData(__null);
    }
}
template<typename T>
template<typename TT>
void unique_ptr<T>::swap(unique_ptr<TT>& other)
{

    mpl::swapItems(m_pDeleter,other.m_pDeleter);
    mpl::swapItems(m_referenceCounterEmbedded,other.m_referenceCounterEmbedded);
    smart_ptr<T,smartPolicyId::UNIQUE>::swap(other);

    return;
}
template<typename T>
template<typename TT>
void unique_ptr<T>::shareCounterIfRefEnabled(enable_ref_from_this<TT>* enabledData)
{
    if(enabledData)
    {
        enabledData->setRefCtr(this->getReferenceCounter());
    }

    return;
}
template<typename T>
void unique_ptr<T>::shareCounterIfRefEnabled(...)
{

}
template<typename T>
bool unique_ptr<T>::isEmbedded() const
{
    return m_referenceCounterEmbedded;
}

template<typename T>
unique_ref<T>::unique_ref(T *pData, Deleter* deleter)
: unique_ptr<T>(pData,deleter)
{
}
template<typename T>
unique_ref<T>::unique_ref(T *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter, bool embedded, Deleter* deleter)
: unique_ptr<T>(pData,referenceCounter,embedded,deleter)
{
}
template<typename T>
unique_ref<T>::unique_ref(unique_ref<T>&& other)
: unique_ptr<T>(mpl::move(other))
{
}
template<typename T>
template<typename TT>
unique_ref<T>::unique_ref(TT *pData, Deleter* deleter)
: unique_ptr<T>(pData,deleter)
{
}
template<typename T>
template<typename TT>
unique_ref<T>::unique_ref(TT *pData, refCounter<smartPolicyId::UNIQUE>* referenceCounter, bool embedded, Deleter* deleter)
: unique_ptr<T>(pData,referenceCounter,embedded,deleter)
{
}
template<typename T>
template<typename TT>
unique_ref<T>::unique_ref(unique_ref<TT>&& other)
: unique_ptr<T>(mpl::move(other))
{
}
template<typename T>
unique_ref<T>& unique_ref<T>::operator=(unique_ref&& other)
{
    unique_ptr<T>::operator=(mpl::move(other));

    return *this;
}

template<typename T, typename ... Args>
unique_ref<T> make_unique_ptr(Args&& ... args)
{
    typedef refCounter<smartPolicyId::UNIQUE> reference_counter;

    void* voidData = malloc(sizeof(T) + sizeof(reference_counter));
    T* pData = static_cast<T*>(voidData);
    void* pDataRefCounter = static_cast<void*>(pData + 1);

    new(voidData) T(mpl::forward<Args>(args)...);
    new(pDataRefCounter) reference_counter();

    return unique_ref<T>(pData, static_cast<reference_counter*>(pDataRefCounter), true);
}

template<typename T>
inline unique_ref<T> promote_to_ref(unique_ptr<T>&& other)
{
    refCounter<smartPolicyId::UNIQUE>* referenceCounter = other.extractReferenceCounter();
    bool isEmbedded = other.isEmbedded();
    Deleter* deleter = other.getDeleter();
    T* pData = other.getData();

    other.release();

    return unique_ref<T>(pData, referenceCounter,isEmbedded,deleter);
}
template<typename TT, typename T>
unique_ptr<TT> dynamic_unique_cast(unique_ptr<T>&& other)
{
    static_assert(std::is_polymorphic<T>::value, "You shall work with polymprphic classes, try providing virtual destructor");

    if(T* pData = other.getData())
    {
        if(TT* innerData = rtti::dynamicCast<TT>(pData))
        {
            refCounter<smartPolicyId::UNIQUE>* referenceCounter = other.extractReferenceCounter();
            bool isEmbedded = other.isEmbedded();
            Deleter* deleter = other.getDeleter();

            other.release();

            return unique_ref<TT>(innerData, referenceCounter, isEmbedded, deleter);
        }
        else
        {
            return null_ptr;
        }
    }
    else
    {
        return null_ptr;
    }
}
template<typename TT, typename T>
unique_ptr<TT> static_unique_cast(unique_ptr<T>&& other)
{
    static_assert(mpl::is_base_of<T,TT>::value || mpl::is_base_of<TT,T>::value, "You shall provide related classes by inheritance");
    static_assert(std::is_polymorphic<T>::value, "You shall work with polymprphic classes, try providing virtual destructor");

    if(T* pData = other.getData())
    {
        TT* innerData = rtti::staticCast<TT>(pData);
        refCounter<smartPolicyId::UNIQUE>* referenceCounter = other.extractReferenceCounter();
        bool isEmbedded = other.isEmbedded();
        Deleter* deleter = other.getDeleter();

        other.release();

        return unique_ref<TT>(innerData, referenceCounter, isEmbedded, deleter);
    }
    else
    {
        return null_ptr;
    }
}
template<typename TT, typename T>
unique_ptr<TT> dynamic_unique_cast(unique_ref<T>&& other)
{
    static_assert(std::is_polymorphic<T>::value, "You shall work with polymprphic classes, try providing virtual destructor");

    refCounter<smartPolicyId::UNIQUE>* referenceCounter = other.extractReferenceCounter();
    bool isEmbedded = other.isEmbedded();
    Deleter* deleter = other.getDeleter();

    if(TT* innerData = rtti::dynamicCast<TT>(other.getData()))
    {
        other.release();

        return unique_ref<TT>(innerData, referenceCounter, isEmbedded, deleter);
    }
    else
    {
        return null_ptr;
    }
}
template<typename TT, typename T>
unique_ref<TT> static_unique_cast(unique_ref<T>&& other)
{
    refCounter<smartPolicyId::UNIQUE>* referenceCounter = other.extractReferenceCounter();
    bool isEmbedded = other.isEmbedded();
    Deleter* deleter = other.getDeleter();
    TT* innerData = rtti::staticCast<TT>(other.getData());

    other.release();

    return unique_ref<TT>(innerData, referenceCounter, isEmbedded, deleter);
}
template<typename T>
unique_ptr<T> const_unique_cast(unique_ptr<const T>&& other)
{
    if(const T* pData = other.getData())
    {
        refCounter<smartPolicyId::UNIQUE>* referenceCounter = other.extractReferenceCounter();
        bool isEmbedded = other.isEmbedded();
        Deleter* deleter = other.getDeleter();
        T* innerData = const_cast<T*>(pData);

        other.release();

        return unique_ptr<T>(innerData, referenceCounter, isEmbedded, deleter);
    }
    else
    {
        return null_ptr;
    }
}
template<typename T>
unique_ref<T> const_unique_cast(unique_ref<const T>&& other)
{
    const T* pData = other.getData();
    ((pData && "You shall provide a non empty ref") ? static_cast<void> (0) : __assert_fail ("pData && \"You shall provide a non empty ref\"", "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/detail/unique_ptr.tpp", 398, __PRETTY_FUNCTION__));
    refCounter<smartPolicyId::UNIQUE>* referenceCounter = other.extractReferenceCounter();
    bool isEmbedded = other.isEmbedded();
    Deleter* deleter = other.getDeleter();
    T* innerData = const_cast<T*>(pData);

    other.release();

    return unique_ref<T>(innerData, referenceCounter, isEmbedded, deleter);
}


}
}
# 170 "/home/marta/workspace/editorFrameworkTestSuite/../editorFramework/YTL/smartPtr/uniquePtr.h" 2
# 4 "test_smartPtr.cpp" 2

namespace
{

class StackDeleter : public yame::ytl::Deleter
{
public:
    void releaseMemory(void* ptr) override
    {

    }
};

class TestNullUniquePtr : public UnitTest::Test { public: TestNullUniquePtr() : Test("NullUniquePtr", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 17) {} private: virtual void RunImpl() const; } testNullUniquePtrInstance; UnitTest::ListAdder adderNullUniquePtr (UnitTest::Test::GetTestList(), &testNullUniquePtrInstance); void TestNullUniquePtr::RunImpl() const
{
    yame::ytl::unique_ptr<int> foo;

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), true, foo == null_ptr, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 21)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 21), "Unhandled exception in CHECK_EQUAL(" "true" ", " "foo == null_ptr" ")"); } } while (0);
}

class TestUniquePtrConstr : public UnitTest::Test { public: TestUniquePtrConstr() : Test("UniquePtrConstr", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 24) {} private: virtual void RunImpl() const; } testUniquePtrConstrInstance; UnitTest::ListAdder adderUniquePtrConstr (UnitTest::Test::GetTestList(), &testUniquePtrConstrInstance); void TestUniquePtrConstr::RunImpl() const
{
    int a = 10;
    StackDeleter stackDeleter;
    yame::ytl::unique_ptr<int> foo(&a, &stackDeleter);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 30)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 30), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo" ")"); } } while (0);
}


class C7
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); typedef yame::container::parameter_pack<> rtti_base; template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C7)); }
public:
    C7(int i_c)
    : c7(i_c)
    {
    }
    int getC7() const
    {
        return c7;
    }

private:
    int c7;

    template<typename T> friend const yame::rtti::TypeInfo* yame::rtti::_getTypeInfo(typename T::rtti_members*); 
typedef C7 _rtti_class; typedef yame::container::parameter_pack<decltype(_rtti_class::c7) , decltype(_rtti_class::) > 
rtti_members; friend inline const yame::container::cArray<yame::container::cPair<yame::container::string,const yame::rtti::TypeInfo*>>& __get_rtti_members(const C7*) { static const yame::container::cArray<yame::container::cPair<yame::container::string,const yame::rtti::TypeInfo*>> __rtti_member_type_info = { yame::container::make_pair(yame::container::string("HEAD( c7 )"),yame::rtti::_getTypeInfo<decltype(_rtti_class::c7)>(__null)) , yame::container::make_pair(yame::container::string(""),yame::rtti::_getTypeInfo<decltype(_rtti_class::)>(__null)) }; return __rtti_member_type_info; } friend inline size_t __get_rtti_member_pos(const C7*, const yame::container::string& i_memberName) { static const size_t __rtti_num_member_types = yame::mpl::get_parameter_pack_num_types<C7::rtti_members>::value; static const yame::container::string __rtti_member_names[__rtti_num_member_types] = { "HEAD(c7)" , "" }; for(size_t memberIndex=0;memberIndex<__rtti_num_member_types;++memberIndex) { if(i_memberName == __rtti_member_names[memberIndex]) { return memberIndex; } } return -1; } friend inline size_t C7::* __get_rtti_member_address(const C7* i_foo, const yame::container::string& i_memberName) { static size_t C7::* rtti_members[] = { reinterpret_cast<size_t _rtti_class::*>(&_rtti_class::c7) , reinterpret_cast<size_t _rtti_class::*>(&_rtti_class::) }; const size_t memberPos = __get_rtti_member_pos(i_foo,i_memberName); return (memberPos != -1) ? rtti_members[memberPos] : __null; }
};
class C8
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); typedef yame::container::parameter_pack<> rtti_base; template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C8)); }
public:
    C8(int i_c)
    : c8(i_c)
    {
    }
    int getC8() const
    {
        return c8;
    }

private:
    int c8;
};
class C9
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); typedef yame::container::parameter_pack<> rtti_base; template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C9)); }
public:
    C9(int i_c)
    : c9(i_c)
    {
    }
    int getC9() const
    {
        return c9;
    }

private:
    int c9;
};
class C10
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); typedef yame::container::parameter_pack<> rtti_base; template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C10)); }
public:
    C10(int i_c)
    : c10(i_c)
    {
    }
    int getC10() const
    {
        return c10;
    }

private:
    int c10;
};
class C11
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); typedef yame::container::parameter_pack<> rtti_base; template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C11)); }
public:
    C11(int i_c)
    : c11(i_c)
    {
    }
    int getC11() const
    {
        return c11;
    }

private:
    int c11;
};
class C12
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); typedef yame::container::parameter_pack<> rtti_base; template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C12)); }
public:
    C12(int i_c)
    : c12(i_c)
    {
    }
    int getC12() const
    {
        return c12;
    }

private:
    int c12;
};
class C13
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); typedef yame::container::parameter_pack<> rtti_base; template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C13)); }
public:
    C13(int i_c)
    : c13(i_c)
    {
    }
    int getC13() const
    {
        return c13;
    }

private:
    int c13;
};
class C14
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); typedef yame::container::parameter_pack<> rtti_base; template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C14)); }
public:
    C14(int i_c)
    : c14(i_c)
    {
    }
    int getC14() const
    {
        return c14;
    }

private:
    int c14;
};
class C3 : public C7, public C8
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); static_assert(yame::rtti::detail::TypeConversionInstantiator<C3,C7,C8>::template _expansor<>(), "Invalid rtti type instantiation"); typedef yame::container::parameter_pack<C7,C8> rtti_base; virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C3)); }
public:
    C3(int i_c1, int i_c2)
    : C7(i_c1)
    , C8(i_c2)
    {
    }
};
class C4 : public C9, public C10
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); static_assert(yame::rtti::detail::TypeConversionInstantiator<C4,C9,C10>::template _expansor<>(), "Invalid rtti type instantiation"); typedef yame::container::parameter_pack<C9,C10> rtti_base; virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C4)); }
public:
    C4(int i_c1, int i_c2)
    : C9(i_c1)
    , C10(i_c2)
    {
    }
};
class C5 : public C11, public C12
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); static_assert(yame::rtti::detail::TypeConversionInstantiator<C5,C11,C12>::template _expansor<>(), "Invalid rtti type instantiation"); typedef yame::container::parameter_pack<C11,C12> rtti_base; virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C5)); }
public:
    C5(int i_c1, int i_c2)
    : C11(i_c1)
    , C12(i_c2)
    {
    }
};
class C6 : public C13, public C14
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); static_assert(yame::rtti::detail::TypeConversionInstantiator<C6,C13,C14>::template _expansor<>(), "Invalid rtti type instantiation"); typedef yame::container::parameter_pack<C13,C14> rtti_base; virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C6)); }
public:
    C6(int i_c1, int i_c2)
    : C13(i_c1)
    , C14(i_c2)
    {
    }
};
class C1 : public C3, public C4
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); static_assert(yame::rtti::detail::TypeConversionInstantiator<C1,C3,C4>::template _expansor<>(), "Invalid rtti type instantiation"); typedef yame::container::parameter_pack<C3,C4> rtti_base; virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C1)); }
public:
    C1(int i_c1, int i_c2, int i_c3, int i_c4)
    : C3(i_c1,i_c2)
    , C4(i_c3,i_c4)
    {
    }
};
class C2 : public C5, public C6
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); static_assert(yame::rtti::detail::TypeConversionInstantiator<C2,C5,C6>::template _expansor<>(), "Invalid rtti type instantiation"); typedef yame::container::parameter_pack<C5,C6> rtti_base; virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C2)); }
public:
    C2(int i_c1, int i_c2, int i_c3, int i_c4)
    : C5(i_c1,i_c2)
    , C6(i_c3,i_c4)
    {
    }
};
class C : public C1, public C2
{
    template<typename Joint,typename T1, typename T2, typename ... TT2> friend bool yame::rtti::detail::TypeDescent<Joint,T1,T2,TT2...>::_expansor(); template<typename TT, typename T> friend TT* yame::rtti::dynamicCast(T* i_ptr); static_assert(yame::rtti::detail::TypeConversionInstantiator<C,C1,C2>::template _expansor<>(), "Invalid rtti type instantiation"); typedef yame::container::parameter_pack<C1,C2> rtti_base; virtual yame::container::cPair<const char*,size_t> _rtti_layout() const { return yame::container::make_pair(reinterpret_cast<const char*>(this),sizeof(C)); }

public:
    C(int i_c1, int i_c2, int i_c3, int i_c4, int i_c5, int i_c6, int i_c7, int i_c8)
    : C1(i_c1,i_c2,i_c3,i_c4)
    , C2(i_c5,i_c6,i_c7,i_c8)
    , a(100)
    , b(200.5f)
    , d('c')
    {
    }

private:
    int a;
    float b;
    char d;

    template<typename T> friend const yame::rtti::TypeInfo* yame::rtti::_getTypeInfo(typename T::rtti_members*); typedef C _rtti_class; typedef yame::container::parameter_pack<decltype(_rtti_class::a) , decltype(_rtti_class::b) , decltype(_rtti_class::d) > rtti_members; friend inline const yame::container::cArray<yame::container::cPair<yame::container::string,const yame::rtti::TypeInfo*>>& __get_rtti_members(const C*) { static const yame::container::cArray<yame::container::cPair<yame::container::string,const yame::rtti::TypeInfo*>> __rtti_member_type_info = { yame::container::make_pair(yame::container::string("HEAD( a,b,d )"),yame::rtti::_getTypeInfo<decltype(_rtti_class::a)>(__null)) , yame::container::make_pair(yame::container::string("b"),yame::rtti::_getTypeInfo<decltype(_rtti_class::b)>(__null)) , yame::container::make_pair(yame::container::string("d"),yame::rtti::_getTypeInfo<decltype(_rtti_class::d)>(__null)) }; return __rtti_member_type_info; } friend inline size_t __get_rtti_member_pos(const C*, const yame::container::string& i_memberName) { static const size_t __rtti_num_member_types = yame::mpl::get_parameter_pack_num_types<C::rtti_members>::value; static const yame::container::string __rtti_member_names[__rtti_num_member_types] = { "HEAD(a,b,d)" , "b" , "d" }; for(size_t memberIndex=0;memberIndex<__rtti_num_member_types;++memberIndex) { if(i_memberName == __rtti_member_names[memberIndex]) { return memberIndex; } } return -1; } friend inline size_t C::* __get_rtti_member_address(const C* i_foo, const yame::container::string& i_memberName) { static size_t C::* rtti_members[] = { reinterpret_cast<size_t _rtti_class::*>(&_rtti_class::a) , reinterpret_cast<size_t _rtti_class::*>(&_rtti_class::b) , reinterpret_cast<size_t _rtti_class::*>(&_rtti_class::d) }; const size_t memberPos = __get_rtti_member_pos(i_foo,i_memberName); return (memberPos != -1) ? rtti_members[memberPos] : __null; }

    template<typename ... Bases> friend inline const yame::rtti::TypeInfo* __get_rtti_C_info_deps(const yame::container::parameter_pack<Bases...>*, const yame::container::cArray<yame::container::cPair<yame::container::string,const yame::rtti::TypeInfo*>>& i_members) { static const yame::rtti::TypeInfo __rtti_type_info("C",yame::rtti::getNextTypeId<C>(),{yame::rtti::_getTypeInfo<Bases>(__null)...},i_members); return &__rtti_type_info; } friend inline const yame::rtti::TypeInfo* __get_rtti_type_info(const C*, const yame::container::cArray<yame::container::cPair<yame::container::string,const yame::rtti::TypeInfo*>>& i_members) { static const yame::rtti::TypeInfo* __rtti_type_info = __get_rtti_C_info_deps(static_cast<const C::rtti_base*>(__null),i_members); return __rtti_type_info; }
};

class TestMakeUniquePtr : public UnitTest::Test { public: TestMakeUniquePtr() : Test("MakeUniquePtr", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 248) {} private: virtual void RunImpl() const; } testMakeUniquePtrInstance; UnitTest::ListAdder adderMakeUniquePtr (UnitTest::Test::GetTestList(), &testMakeUniquePtrInstance); void TestMakeUniquePtr::RunImpl() const
{
    yame::ytl::unique_ptr<int> foo = yame::ytl::make_unique_ptr<int>(10);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 252)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 252), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo" ")"); } } while (0);
}

class TestMakeUniqueRef : public UnitTest::Test { public: TestMakeUniqueRef() : Test("MakeUniqueRef", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 255) {} private: virtual void RunImpl() const; } testMakeUniqueRefInstance; UnitTest::ListAdder adderMakeUniqueRef (UnitTest::Test::GetTestList(), &testMakeUniqueRefInstance); void TestMakeUniqueRef::RunImpl() const
{
    yame::ytl::unique_ref<int> foo = yame::ytl::make_unique_ptr<int>(10);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 259)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 259), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo" ")"); } } while (0);
}

class TestUniquePtrAssign : public UnitTest::Test { public: TestUniquePtrAssign() : Test("UniquePtrAssign", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 262) {} private: virtual void RunImpl() const; } testUniquePtrAssignInstance; UnitTest::ListAdder adderUniquePtrAssign (UnitTest::Test::GetTestList(), &testUniquePtrAssignInstance); void TestUniquePtrAssign::RunImpl() const
{
    yame::ytl::unique_ptr<int> foo1;
    yame::ytl::unique_ptr<int> foo2 = yame::ytl::make_unique_ptr<int>(10);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo2, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 267)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 267), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo2" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), true, foo1 == null_ptr, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 268)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 268), "Unhandled exception in CHECK_EQUAL(" "true" ", " "foo1 == null_ptr" ")"); } } while (0);

    foo1 = yame::mpl::move(foo2);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo1, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 272)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 272), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo1" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), true, foo2 == null_ptr, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 273)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 273), "Unhandled exception in CHECK_EQUAL(" "true" ", " "foo2 == null_ptr" ")"); } } while (0);
}

class TestUniquePtrPromotion : public UnitTest::Test { public: TestUniquePtrPromotion() : Test("UniquePtrPromotion", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 276) {} private: virtual void RunImpl() const; } testUniquePtrPromotionInstance; UnitTest::ListAdder adderUniquePtrPromotion (UnitTest::Test::GetTestList(), &testUniquePtrPromotionInstance); void TestUniquePtrPromotion::RunImpl() const
{
    yame::ytl::unique_ptr<int> foo1 = yame::ytl::make_unique_ptr<int>(10);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo1, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 280)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 280), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo1" ")"); } } while (0);

    yame::ytl::unique_ref<int> foo2 = yame::ytl::promote_to_ref(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo2, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 284)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 284), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo2" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), true, foo1 == null_ptr, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 285)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 285), "Unhandled exception in CHECK_EQUAL(" "true" ", " "foo1 == null_ptr" ")"); } } while (0);
}

class TestUniqueRefAssign : public UnitTest::Test { public: TestUniqueRefAssign() : Test("UniqueRefAssign", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 288) {} private: virtual void RunImpl() const; } testUniqueRefAssignInstance; UnitTest::ListAdder adderUniqueRefAssign (UnitTest::Test::GetTestList(), &testUniqueRefAssignInstance); void TestUniqueRefAssign::RunImpl() const
{
    yame::ytl::unique_ref<int> foo1 = yame::ytl::make_unique_ptr<int>(10);
    yame::ytl::unique_ref<int> foo2 = yame::ytl::make_unique_ptr<int>(20);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo1, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 293)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 293), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo1" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 20, *foo2, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 294)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 294), "Unhandled exception in CHECK_EQUAL(" "20" ", " "*foo2" ")"); } } while (0);

    foo1 = yame::mpl::move(foo2);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 20, *foo1, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 298)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 298), "Unhandled exception in CHECK_EQUAL(" "20" ", " "*foo1" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), true, foo2 == null_ptr, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 299)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 299), "Unhandled exception in CHECK_EQUAL(" "true" ", " "foo2 == null_ptr" ")"); } } while (0);
}

class TestUniquePtrSwap : public UnitTest::Test { public: TestUniquePtrSwap() : Test("UniquePtrSwap", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 302) {} private: virtual void RunImpl() const; } testUniquePtrSwapInstance; UnitTest::ListAdder adderUniquePtrSwap (UnitTest::Test::GetTestList(), &testUniquePtrSwapInstance); void TestUniquePtrSwap::RunImpl() const
{
    yame::ytl::unique_ptr<int> foo1 = yame::ytl::make_unique_ptr<int>(10);
    yame::ytl::unique_ptr<int> foo2 = yame::ytl::make_unique_ptr<int>(20);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo1, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 307)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 307), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo1" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 20, *foo2, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 308)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 308), "Unhandled exception in CHECK_EQUAL(" "20" ", " "*foo2" ")"); } } while (0);

    foo1 = yame::mpl::move(foo2);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 20, *foo1, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 312)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 312), "Unhandled exception in CHECK_EQUAL(" "20" ", " "*foo1" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), true, foo2 == null_ptr, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 313)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 313), "Unhandled exception in CHECK_EQUAL(" "true" ", " "foo2 == null_ptr" ")"); } } while (0);
}

class TestUniquePtrAssignNull : public UnitTest::Test { public: TestUniquePtrAssignNull() : Test("UniquePtrAssignNull", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 316) {} private: virtual void RunImpl() const; } testUniquePtrAssignNullInstance; UnitTest::ListAdder adderUniquePtrAssignNull (UnitTest::Test::GetTestList(), &testUniquePtrAssignNullInstance); void TestUniquePtrAssignNull::RunImpl() const
{
    yame::ytl::unique_ptr<int> foo = yame::ytl::make_unique_ptr<int>(10);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, *foo, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 320)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 320), "Unhandled exception in CHECK_EQUAL(" "10" ", " "*foo" ")"); } } while (0);

    foo = null_ptr;

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), true, foo == null_ptr, UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 324)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 324), "Unhandled exception in CHECK_EQUAL(" "true" ", " "foo == null_ptr" ")"); } } while (0);
}

class TestUniquePtrCtoC1DynamicCast : public UnitTest::Test { public: TestUniquePtrCtoC1DynamicCast() : Test("UniquePtrCtoC1DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 327) {} private: virtual void RunImpl() const; } testUniquePtrCtoC1DynamicCastInstance; UnitTest::ListAdder adderUniquePtrCtoC1DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrCtoC1DynamicCastInstance); void TestUniquePtrCtoC1DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C1> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 331)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 331), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 332)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 332), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 9, foo1->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 333)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 333), "Unhandled exception in CHECK_EQUAL(" "9" ", " "foo1->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, foo1->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 334)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 334), "Unhandled exception in CHECK_EQUAL(" "10" ", " "foo1->getC10()" ")"); } } while (0);

    yame::rtti::TypeInfo foo1TypeInfo = yame::rtti::getTypeInfo<C>();

    yame::ytl::unique_ptr<C> foo2 = yame::ytl::dynamic_unique_cast<C>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo2->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 340)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 340), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo2->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo2->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 341)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 341), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo2->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 9, foo2->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 342)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 342), "Unhandled exception in CHECK_EQUAL(" "9" ", " "foo2->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 343)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 343), "Unhandled exception in CHECK_EQUAL(" "10" ", " "foo2->getC10()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 344)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 344), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 345)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 345), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC12()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 346)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 346), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 347)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 347), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC14()" ")"); } } while (0);
}

class TestUniquePtrCtoC2DynamicCast : public UnitTest::Test { public: TestUniquePtrCtoC2DynamicCast() : Test("UniquePtrCtoC2DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 350) {} private: virtual void RunImpl() const; } testUniquePtrCtoC2DynamicCastInstance; UnitTest::ListAdder adderUniquePtrCtoC2DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrCtoC2DynamicCastInstance); void TestUniquePtrCtoC2DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C2> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 354)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 354), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 355)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 355), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC12()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 9, foo1->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 356)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 356), "Unhandled exception in CHECK_EQUAL(" "9" ", " "foo1->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, foo1->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 357)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 357), "Unhandled exception in CHECK_EQUAL(" "10" ", " "foo1->getC14()" ")"); } } while (0);

    yame::ytl::unique_ptr<C> foo2 = yame::ytl::dynamic_unique_cast<C>(yame::mpl::move(foo1));

    const int& aValue = yame::ytl::access<int>(foo2,"a");
    const float& bValue = yame::ytl::access<float>(foo2,"b");
    const char& dValue = yame::ytl::access<char>(foo2,"d");

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo2->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 365)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 365), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo2->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo2->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 366)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 366), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo2->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 9, foo2->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 367)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 367), "Unhandled exception in CHECK_EQUAL(" "9" ", " "foo2->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 368)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 368), "Unhandled exception in CHECK_EQUAL(" "10" ", " "foo2->getC10()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 369)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 369), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 370)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 370), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC12()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 371)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 371), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 372)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 372), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC14()" ")"); } } while (0);
}

class TestUniquePtrC3toC1DynamicCast : public UnitTest::Test { public: TestUniquePtrC3toC1DynamicCast() : Test("UniquePtrC3toC1DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 375) {} private: virtual void RunImpl() const; } testUniquePtrC3toC1DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC3toC1DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC3toC1DynamicCastInstance); void TestUniquePtrC3toC1DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C3> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 379)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 379), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 380)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 380), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC8()" ")"); } } while (0);

    yame::ytl::unique_ptr<C1> foo2 = yame::ytl::dynamic_unique_cast<C1>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 384)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 384), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 385)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 385), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 386)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 386), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 387)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 387), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC10()" ")"); } } while (0);
}

class TestUniquePtrC3toC2DynamicCast : public UnitTest::Test { public: TestUniquePtrC3toC2DynamicCast() : Test("UniquePtrC3toC2DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 390) {} private: virtual void RunImpl() const; } testUniquePtrC3toC2DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC3toC2DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC3toC2DynamicCastInstance); void TestUniquePtrC3toC2DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C3> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 394)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 394), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 395)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 395), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC8()" ")"); } } while (0);

    yame::ytl::unique_ptr<C2> foo2 = yame::ytl::dynamic_unique_cast<C2>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 399)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 399), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 400)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 400), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC12()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 401)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 401), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 402)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 402), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC14()" ")"); } } while (0);
}

class TestUniquePtrC3toCDynamicCast : public UnitTest::Test { public: TestUniquePtrC3toCDynamicCast() : Test("UniquePtrC3toCDynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 405) {} private: virtual void RunImpl() const; } testUniquePtrC3toCDynamicCastInstance; UnitTest::ListAdder adderUniquePtrC3toCDynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC3toCDynamicCastInstance); void TestUniquePtrC3toCDynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C3> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 409)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 409), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 410)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 410), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC8()" ")"); } } while (0);

    yame::ytl::unique_ptr<C> foo2 = yame::ytl::dynamic_unique_cast<C>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo2->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 414)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 414), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo2->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo2->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 415)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 415), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo2->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 9, foo2->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 416)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 416), "Unhandled exception in CHECK_EQUAL(" "9" ", " "foo2->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 10, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 417)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 417), "Unhandled exception in CHECK_EQUAL(" "10" ", " "foo2->getC10()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 418)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 418), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 419)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 419), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC12()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 420)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 420), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 421)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 421), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC14()" ")"); } } while (0);
}

class TestUniquePtrC4toC1DynamicCast : public UnitTest::Test { public: TestUniquePtrC4toC1DynamicCast() : Test("UniquePtrC4toC1DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 424) {} private: virtual void RunImpl() const; } testUniquePtrC4toC1DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC4toC1DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC4toC1DynamicCastInstance); void TestUniquePtrC4toC1DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C4> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 428)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 428), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 429)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 429), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC10()" ")"); } } while (0);

    yame::ytl::unique_ptr<C1> foo2 = yame::ytl::dynamic_unique_cast<C1>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 433)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 433), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 434)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 434), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 435)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 435), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 436)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 436), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC10()" ")"); } } while (0);
}

class TestUniquePtrC4toC2DynamicCast : public UnitTest::Test { public: TestUniquePtrC4toC2DynamicCast() : Test("UniquePtrC4toC2DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 439) {} private: virtual void RunImpl() const; } testUniquePtrC4toC2DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC4toC2DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC4toC2DynamicCastInstance); void TestUniquePtrC4toC2DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C4> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 443)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 443), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 444)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 444), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC10()" ")"); } } while (0);

    yame::ytl::unique_ptr<C2> foo2 = yame::ytl::dynamic_unique_cast<C2>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 448)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 448), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 449)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 449), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC12()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 450)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 450), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 451)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 451), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC14()" ")"); } } while (0);
}

class TestUniquePtrC5toC2DynamicCast : public UnitTest::Test { public: TestUniquePtrC5toC2DynamicCast() : Test("UniquePtrC5toC2DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 454) {} private: virtual void RunImpl() const; } testUniquePtrC5toC2DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC5toC2DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC5toC2DynamicCastInstance); void TestUniquePtrC5toC2DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C5> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 458)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 458), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 459)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 459), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC12()" ")"); } } while (0);

    yame::ytl::unique_ptr<C2> foo2 = yame::ytl::dynamic_unique_cast<C2>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 463)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 463), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 464)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 464), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC12()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 465)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 465), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 466)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 466), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC14()" ")"); } } while (0);
}

class TestUniquePtrC5toC1DynamicCast : public UnitTest::Test { public: TestUniquePtrC5toC1DynamicCast() : Test("UniquePtrC5toC1DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 469) {} private: virtual void RunImpl() const; } testUniquePtrC5toC1DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC5toC1DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC5toC1DynamicCastInstance); void TestUniquePtrC5toC1DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C5> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 473)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 473), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 474)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 474), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC12()" ")"); } } while (0);

    yame::ytl::unique_ptr<C1> foo2 = yame::ytl::dynamic_unique_cast<C1>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 478)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 478), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 479)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 479), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 480)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 480), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 481)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 481), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC10()" ")"); } } while (0);
}

class TestUniquePtrC6toC2DynamicCast : public UnitTest::Test { public: TestUniquePtrC6toC2DynamicCast() : Test("UniquePtrC6toC2DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 484) {} private: virtual void RunImpl() const; } testUniquePtrC6toC2DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC6toC2DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC6toC2DynamicCastInstance); void TestUniquePtrC6toC2DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C6> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 488)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 488), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 489)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 489), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC14()" ")"); } } while (0);

    yame::ytl::unique_ptr<C2> foo2 = yame::ytl::dynamic_unique_cast<C2>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC11(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 493)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 493), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC11()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC12(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 494)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 494), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC12()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 495)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 495), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 496)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 496), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC14()" ")"); } } while (0);
}

class TestUniquePtrC6toC1DynamicCast : public UnitTest::Test { public: TestUniquePtrC6toC1DynamicCast() : Test("UniquePtrC6toC1DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 499) {} private: virtual void RunImpl() const; } testUniquePtrC6toC1DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC6toC1DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC6toC1DynamicCastInstance); void TestUniquePtrC6toC1DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C6> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 503)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 503), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 8, foo1->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 504)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 504), "Unhandled exception in CHECK_EQUAL(" "8" ", " "foo1->getC14()" ")"); } } while (0);

    yame::ytl::unique_ptr<C1> foo2 = yame::ytl::dynamic_unique_cast<C1>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 11, foo2->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 508)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 508), "Unhandled exception in CHECK_EQUAL(" "11" ", " "foo2->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 12, foo2->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 509)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 509), "Unhandled exception in CHECK_EQUAL(" "12" ", " "foo2->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 510)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 510), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 511)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 511), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC10()" ")"); } } while (0);
}

class TestUniquePtrC7toC1DynamicCast : public UnitTest::Test { public: TestUniquePtrC7toC1DynamicCast() : Test("UniquePtrC7toC1DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 514) {} private: virtual void RunImpl() const; } testUniquePtrC7toC1DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC7toC1DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC7toC1DynamicCastInstance); void TestUniquePtrC7toC1DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C7> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 518)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 518), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC7()" ")"); } } while (0);

    yame::ytl::unique_ptr<C1> foo2 = yame::ytl::dynamic_unique_cast<C1>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 522)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 522), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 523)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 523), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 524)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 524), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 525)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 525), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC10()" ")"); } } while (0);
}

class TestUniquePtrC7toC6DynamicCast : public UnitTest::Test { public: TestUniquePtrC7toC6DynamicCast() : Test("UniquePtrC7toC6DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 528) {} private: virtual void RunImpl() const; } testUniquePtrC7toC6DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC7toC6DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC7toC6DynamicCastInstance); void TestUniquePtrC7toC6DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C7> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 532)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 532), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC7()" ")"); } } while (0);

    yame::ytl::unique_ptr<C6> foo2 = yame::ytl::dynamic_unique_cast<C6>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 13, foo2->getC13(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 536)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 536), "Unhandled exception in CHECK_EQUAL(" "13" ", " "foo2->getC13()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 537)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 537), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC14()" ")"); } } while (0);
}

class TestUniquePtrC7toC14DynamicCast : public UnitTest::Test { public: TestUniquePtrC7toC14DynamicCast() : Test("UniquePtrC7toC14DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 540) {} private: virtual void RunImpl() const; } testUniquePtrC7toC14DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC7toC14DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC7toC14DynamicCastInstance); void TestUniquePtrC7toC14DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C7> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 544)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 544), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC7()" ")"); } } while (0);

    yame::ytl::unique_ptr<C14> foo2 = yame::ytl::dynamic_unique_cast<C14>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 548)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 548), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC14()" ")"); } } while (0);
}

class TestUniquePtrC7toC10DynamicCast : public UnitTest::Test { public: TestUniquePtrC7toC10DynamicCast() : Test("UniquePtrC7toC10DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 551) {} private: virtual void RunImpl() const; } testUniquePtrC7toC10DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC7toC10DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC7toC10DynamicCastInstance); void TestUniquePtrC7toC10DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C7> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 555)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 555), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC7()" ")"); } } while (0);

    yame::ytl::unique_ptr<C10> foo2 = yame::ytl::dynamic_unique_cast<C10>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 559)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 559), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC10()" ")"); } } while (0);
}

class TestUniquePtrC14toC1DynamicCast : public UnitTest::Test { public: TestUniquePtrC14toC1DynamicCast() : Test("UniquePtrC14toC1DynamicCast", UnitTestSuite::GetSuiteName(), "test_smartPtr.cpp", 562) {} private: virtual void RunImpl() const; } testUniquePtrC14toC1DynamicCastInstance; UnitTest::ListAdder adderUniquePtrC14toC1DynamicCast (UnitTest::Test::GetTestList(), &testUniquePtrC14toC1DynamicCastInstance); void TestUniquePtrC14toC1DynamicCast::RunImpl() const
{
    yame::ytl::unique_ptr<C14> foo1 = yame::ytl::make_unique_ptr<C>(7,8,9,10,11,12,13,14);

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 7, foo1->getC14(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 566)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 566), "Unhandled exception in CHECK_EQUAL(" "7" ", " "foo1->getC14()" ")"); } } while (0);

    yame::ytl::unique_ptr<C1> foo2 = yame::ytl::dynamic_unique_cast<C1>(yame::mpl::move(foo1));

    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC7(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 570)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 570), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC7()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC8(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 571)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 571), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC8()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC9(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 572)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 572), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC9()" ")"); } } while (0);
    do { try { UnitTest::CheckEqual(*UnitTest::CurrentTest::Results(), 14, foo2->getC10(), UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 573)); } catch (...) { UnitTest::CurrentTest::Results()->OnTestFailure(UnitTest::TestDetails(*UnitTest::CurrentTest::Details(), 573), "Unhandled exception in CHECK_EQUAL(" "14" ", " "foo2->getC10()" ")"); } } while (0);
}
# 804 "test_smartPtr.cpp"
}
